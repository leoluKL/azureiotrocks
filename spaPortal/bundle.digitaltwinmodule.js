(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":1,"buffer":2,"ieee754":3}],3:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],4:[function(require,module,exports){
'use strict';
const topologyDOM=require("./topologyDOM.js")
const mapDOM=require("./mapDOM.js")
const twinsTree=require("./twinsTree")
const startSelectionDialog = require("../sharedSourceFiles/startSelectionDialog")
const modelManagerDialog = require("../sharedSourceFiles/modelManagerDialog")
const projectSettingDialog = require("../sharedSourceFiles/projectSettingDialog")
const modelEditorDialog = require("../sharedSourceFiles/modelEditorDialog")
const editLayoutDialog = require("./editLayoutDialog")
const mainToolbar = require("./mainToolbar")
const infoPanel= require("./infoPanel");
const globalAppSettings = require("../globalAppSettings.js");
const msalHelper=require("../msalHelper")
const newTwinDialog=require("../sharedSourceFiles/newTwinDialog");
const floatInfoWindow=require("./floatInfoWindow")
const serviceWorkerHelper=require("../sharedSourceFiles/serviceWorkerHelper")
const globalCache = require("../sharedSourceFiles/globalCache")

function digitaltwinmoduleUI() {
    globalCache.checkTooLongIdle()
    this.initUILayout()

    this.twinsTree= new twinsTree($("#treeHolder"),$("#treeSearch"))
    
    mainToolbar.render()
    this.topologyInstance=new topologyDOM($('#canvas'))
    this.topologyInstance.init()

    this.mapDOM = new mapDOM($('#canvas'))

    this.broadcastMessage() //initialize all ui components to have the broadcast capability

    //try if it already B2C signed in, if not going back to the start page
    this.myMSALObj = new msal.PublicClientApplication(globalAppSettings.msalConfig);


    var theAccount=msalHelper.fetchAccount();
    if(theAccount==null && !globalAppSettings.isLocalTest) window.open(globalAppSettings.logoutRedirectUri,"_self")

    this.initData()
    //setTimeout(()=>{this.stallPage()},1000)
}



digitaltwinmoduleUI.prototype.initData=async function(){
    try{
        await msalHelper.reloadUserAccountData()
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
        return
    }

    startSelectionDialog.popup()
}

digitaltwinmoduleUI.prototype.broadcastMessage=function(source,msgPayload){
    var componentsArr=[this.twinsTree,startSelectionDialog,modelManagerDialog,modelEditorDialog,editLayoutDialog,
         mainToolbar,this.topologyInstance,this.mapDOM,infoPanel,newTwinDialog,floatInfoWindow,projectSettingDialog,serviceWorkerHelper,globalCache]

    if(source==null){
        for(var i=0;i<componentsArr.length;i++){
            var theComponent=componentsArr[i]
            this.assignBroadcastMessage(theComponent)
        }
    }else{
        for(var i=0;i<componentsArr.length;i++){
            var theComponent=componentsArr[i]
            if(theComponent.rxMessage && theComponent!=source) theComponent.rxMessage(msgPayload)
        }
    }
}

digitaltwinmoduleUI.prototype.assignBroadcastMessage=function(uiComponent){
    uiComponent.broadcastMessage=(msgObj)=>{this.broadcastMessage(uiComponent,msgObj)}
}

digitaltwinmoduleUI.prototype.initUILayout = function () {
    $('body').layout({
        //	reference only - these options are NOT required because 'true' is the default
        closable: true	// pane can open & close
        , resizable: true	// when open, pane can be resized 
        , slidable: true	// when closed, pane can 'slide' open over other panes - closes on mouse-out
        , livePaneResizing: true

        //	some resizing/toggling settings
        , north__slidable: false	// OVERRIDE the pane-default of 'slidable=true'
        //, north__togglerLength_closed: '100%'	// toggle-button is full-width of resizer-bar
        , north__spacing_closed: 6		// big resizer-bar when open (zero height)
        , north__spacing_open:0
        , north__resizable: false	// OVERRIDE the pane-default of 'resizable=true'
        , north__closable: false
        , west__closable: false
        , east__closable: false
        

        //	some pane-size settings
        , west__minSize: 100
        , east__size: 300
        , east__minSize: 200
        , east__maxSize: 0.5 // 50% of layout width
        , center__minWidth: 100
        ,east__initClosed:	true
    });


    /*
     *	DISABLE TEXT-SELECTION WHEN DRAGGING (or even _trying_ to drag!)
     *	this functionality will be included in RC30.80
     */
    $.layout.disableTextSelection = function () {
        var $d = $(document)
            , s = 'textSelectionDisabled'
            , x = 'textSelectionInitialized'
            ;
        if ($.fn.disableSelection) {
            if (!$d.data(x)) // document hasn't been initialized yet
                $d.on('mouseup', $.layout.enableTextSelection).data(x, true);
            if (!$d.data(s))
                $d.disableSelection().data(s, true);
        }
        //console.log('$.layout.disableTextSelection');
    };
    $.layout.enableTextSelection = function () {
        var $d = $(document)
            , s = 'textSelectionDisabled';
        if ($.fn.enableSelection && $d.data(s))
            $d.enableSelection().data(s, false);
        //console.log('$.layout.enableTextSelection');
    };
    $(".ui-layout-resizer-north").hide()
    $(".ui-layout-west").css("border-right","solid 1px lightGray")
    $(".ui-layout-west").addClass("w3-card")
}


module.exports = new digitaltwinmoduleUI();
},{"../globalAppSettings.js":17,"../msalHelper":18,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/modelEditorDialog":23,"../sharedSourceFiles/modelManagerDialog":24,"../sharedSourceFiles/newTwinDialog":26,"../sharedSourceFiles/projectSettingDialog":27,"../sharedSourceFiles/serviceWorkerHelper":29,"../sharedSourceFiles/startSelectionDialog":35,"./editLayoutDialog":5,"./floatInfoWindow":6,"./infoPanel":7,"./mainToolbar":9,"./mapDOM.js":10,"./topologyDOM.js":11,"./twinsTree":16}],5:[function(require,module,exports){
const simpleSelectMenu= require("../sharedSourceFiles/simpleSelectMenu")
const simpleConfirmDialog = require("../sharedSourceFiles/simpleConfirmDialog")
const globalCache=require("../sharedSourceFiles/globalCache")
const msalHelper=require("../msalHelper")

function editLayoutDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:101" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

editLayoutDialog.prototype.refillOptions = function () {
    this.switchLayoutSelector.clearOptions()
    
    for(var ind in globalCache.layoutJSON){
        var oneLayoutObj=globalCache.layoutJSON[ind]
        if(oneLayoutObj.owner==globalCache.accountInfo.id)  this.switchLayoutSelector.addOption(ind)
    }
}

editLayoutDialog.prototype.popup = function () {
    this.DOM.show()
    this.DOM.empty()

    this.DOM.css({"width":"320px","padding-bottom":"3px"})
    this.DOM.append($('<div style="height:40px;margin-bottom:2px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.2em">Layout</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.DOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var nameInput=$('<input type="text" style="outline:none; width:180px; display:inline;margin-left:2px;margin-right:2px"  placeholder="Fill in a new layout name..."/>').addClass("w3-input w3-border");   
    this.DOM.append(nameInput)
    var saveAsNewBtn=$('<button class="w3-button w3-green w3-hover-light-green">Save New Layout</button>')
    this.DOM.append(saveAsNewBtn)
    saveAsNewBtn.on("click",()=>{this.saveIntoLayout(nameInput.val())})


    if(!$.isEmptyObject(globalCache.layoutJSON)){
        var lbl=$('<div class="w3-bar w3-padding-16" style="text-align:center;">- OR -</div>')
        this.DOM.append(lbl) 
        var switchLayoutSelector=new simpleSelectMenu("",{fontSize:"1em",colorClass:"w3-light-gray",width:"120px"})
        this.switchLayoutSelector=switchLayoutSelector
        this.refillOptions()
        this.switchLayoutSelector.callBack_clickOption=(optionText,optionValue)=>{
            if(optionText==null) this.switchLayoutSelector.changeName(" ")
            else this.switchLayoutSelector.changeName(optionText)
        }
            
        var saveAsBtn=$('<button class="w3-button w3-green w3-hover-light-green" style="margin-left:2px;margin-right:5px">Save As</button>')
        var deleteBtn=$('<button class="w3-ripple w3-button w3-red w3-hover-pink" style="margin-left:5px">Delete Layout</button>')
        this.DOM.append(saveAsBtn,switchLayoutSelector.DOM,deleteBtn)
        saveAsBtn.on("click",()=>{this.saveIntoLayout(switchLayoutSelector.curSelectVal)})
        deleteBtn.on("click",()=>{this.deleteLayout(switchLayoutSelector.curSelectVal)})

        if(globalCache.currentLayoutName!=null){
            switchLayoutSelector.triggerOptionValue(globalCache.currentLayoutName)
        }else{
            switchLayoutSelector.triggerOptionIndex(0)
        }
    }
}

editLayoutDialog.prototype.saveIntoLayout = function (layoutName) {
    if(layoutName=="" || layoutName==null){
        alert("Please choose target layout Name")
        return
    }
    this.broadcastMessage({ "message": "saveLayout", "layoutName": layoutName})
    this.DOM.hide()
}


editLayoutDialog.prototype.deleteLayout = function (layoutName) {
    if(layoutName=="" || layoutName==null){
        alert("Please choose target layout Name")
        return;
    }

    var confirmDialogDiv=new simpleConfirmDialog()

    confirmDialogDiv.show(
        { width: "250px" },
        {
            title: "Confirm"
            , content: "Confirm deleting layout \"" + layoutName + "\"?"
            , buttons:[
                {
                    colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": async () => {
                        delete globalCache.layoutJSON[layoutName]
                        if (layoutName == globalCache.currentLayoutName) globalCache.currentLayoutName = null
                        confirmDialogDiv.close()
                        this.broadcastMessage({ "message": "layoutsUpdated"})
                        this.refillOptions()
                        this.switchLayoutSelector.triggerOptionIndex(0)
                        try{
                            await msalHelper.callAPI("digitaltwin/deleteLayout", "POST", { "layoutName": layoutName },"withProjectID")
                        }catch(e){
                            console.log(e)
                            if(e.responseText) alert(e.responseText)
                        }
                    }
                },
                {
                    colorClass: "w3-gray",text: "Cancel", "clickFunc": () => {
                        confirmDialogDiv.close()
                }}
            ]
        }
    )

}

module.exports = new editLayoutDialog();
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/simpleConfirmDialog":31,"../sharedSourceFiles/simpleSelectMenu":33}],6:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache")
const baseInfoPanel = require("../sharedSourceFiles/baseInfoPanel")


class floatInfoWindow extends baseInfoPanel{
    constructor() {
        super()
        if(!this.DOM){
            this.DOM=$('<div class="w3-card" style="position:absolute;z-index:101;"></div>')
            this.hideSelf()
            this.DOM.css("background-color","rgba(255, 255, 255, 0.9)")
            $('body').append(this.DOM)
        }
        this.readOnly=true
    }

    hideSelf(){
        this.DOM.hide()
        this.DOM.css("width","0px")
        if(this.aTimerSinceShowing) clearTimeout(this.aTimerSinceShowing)
        this.aTimerSinceShowing=null;
        this.currentShowingTwinID=null;
    }


    rxMessage(msgPayload) {
        if (msgPayload.message == "hideFloatInfoPanel") {
            this.hideSelf()
        }else if (msgPayload.message == "showInfoHoveredEle") {
            if (!globalCache.showFloatInfoPanel) return;
            this.DOM.empty()
            var arr = msgPayload.info;
            if (arr == null || arr.length == 0) return;
            this.DOM.css("left", "-2000px") //it is always outside of browser so it wont block mouse and cause mouse out
            
            var singleElementInfo = arr[0];
            if(singleElementInfo==null) return;
            singleElementInfo=this.fetchRealElementInfo(singleElementInfo)
            
            this.DOM.css("width","325px")
            this.DOM.show()
            var contentDOM=$('<div class="w3-container"/>')
            this.DOM.append(contentDOM)
            
            var documentBodyWidth = $('body').width()
            if (singleElementInfo["$dtId"]) {// select a node
                var singleDBTwinInfo=globalCache.DBTwins[singleElementInfo["$dtId"]]
                this.drawSingleNodeProperties(singleDBTwinInfo,singleElementInfo,contentDOM,"notEmbedMetadata")
            } else if (singleElementInfo["$sourceId"]) {
                this.drawSingleRelationProperties(singleElementInfo,contentDOM)
            } else if(singleElementInfo["simNodeName"]){
                this.drawSimDatasourceInfo(singleElementInfo,contentDOM)
            }

            var screenXY = msgPayload.screenXY
            var windowLeft = screenXY.x + 50

            if (windowLeft + this.DOM.outerWidth() + 10 > documentBodyWidth) {
                windowLeft = documentBodyWidth - this.DOM.outerWidth() - 10
            }
            var windowTop = screenXY.y - this.DOM.outerHeight() - 50
            if (windowTop < 5) windowTop = 5
            this.DOM.css({ "left": windowLeft + "px", "top": windowTop + "px" })
            this.DOM.css("padding-bottom","5px") 

            if (singleElementInfo["$dtId"]) this.currentShowingTwinID=singleElementInfo["$dtId"];
            if(this.currentShowingTwinID==null) return;
            var dbtwin= globalCache.DBTwins[this.currentShowingTwinID]
            if(!dbtwin || !dbtwin.originalScript || dbtwin.originalScript=="") return;
            this.DOM.css("padding-bottom","0px") 
            //var div=$('<div>'+dbtwin.originalScript+'</div>')
            //this.DOM.append(div)
            var holderDiv=$('<div style="padding:1px"/>')
            var scriptTextArea=$('<textarea class="w3-border" spellcheck="false" style="outline:none;font-size:11px;width:100%;font-family:Verdana">'+dbtwin["originalScript"]+'</textarea>')
            this.DOM.append(holderDiv.append(scriptTextArea))
            scriptTextArea.css("height","1px") //to expand scriptTextArea to the height that shows all code
            var theHeight=scriptTextArea[0].scrollHeight+2
            scriptTextArea.css("height",theHeight+"px")
            scriptTextArea.highlightWithinTextarea(
                { highlight: [
                    { "highlight": "_self", "className": "Gray"},
                    { "highlight": "_twinVal", "className": "keyword"},
                ]}
            );
            holderDiv.css("height",theHeight+"px")
            holderDiv.hide()

            var div=$('<div class="w3-amber" style="font-size:6px;text-align:center"><i class="fas fa-ellipsis-h"></i></div>')
            this.DOM.append(div)
            div.fadeTo(400,0.3,"swing",()=>{
                div.fadeTo(400,1,"swing",()=>{
                    div.fadeTo(400,0.3,"swing",()=>{
                        div.fadeTo(400,1,"swing",()=>{
                            holderDiv.slideDown("fast")
                        })
                    })
                })    
            })


        }
    }

}

module.exports = new floatInfoWindow();
},{"../sharedSourceFiles/baseInfoPanel":19,"../sharedSourceFiles/globalCache":21}],7:[function(require,module,exports){
const modelAnalyzer = require("../sharedSourceFiles/modelAnalyzer");
const simpleConfirmDialog = require("../sharedSourceFiles/simpleConfirmDialog")
const globalCache = require("../sharedSourceFiles/globalCache")
const msalHelper = require("../msalHelper")
const baseInfoPanel = require("../sharedSourceFiles/baseInfoPanel")
const simpleExpandableSection= require("../sharedSourceFiles/simpleExpandableSection")
const simpleSelectMenu= require("../sharedSourceFiles/simpleSelectMenu")
const scriptTestDialog = require("../sharedSourceFiles/scriptTestDialog")
const infoPanel_liveMonitor=require("./infoPanel_liveMonitor")

class infoPanel extends baseInfoPanel {
    constructor() {
        super()
        this.openLiveCalculationSection=true
        this.openPropertiesSection=true
        this.containerDOM = $('<div class="w3-card" style="position:absolute;z-index:90;right:0px;top:50%;height:70%;width:350px;transform: translateY(-50%);"></div>')
        this.containerDOM.hide()
        this.containerDOM.append($('<div style="height:50px" class="w3-bar w3-red"></div>'))

        this.closeButton1 = $('<button style="height:100%" class="w3-bar-item w3-button"><i class="fa fa-info-circle fa-2x" style="padding:2px"></i></button>')
        this.livePaneButton = $('<button style="height:100%;margin-right:10px" class="w3-right w3-amber w3-bar-item w3-button">Show Live Pane</button>')
        this.closeButton2 = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em"></button>')
        this.containerDOM.children(':first').append(this.closeButton1, this.closeButton2,this.livePaneButton)

        this.isMinimized = false;
        var buttonAnim = () => {
            if (!this.isMinimized) this.minimizeWindow()
            else this.expandWindow()
        }
        this.closeButton1.on("click", buttonAnim)
        this.closeButton2.on("click", buttonAnim)

        this.DOM = $('<div class="w3-container" style="padding:0px;postion:absolute;top:50px;height:calc(100% - 50px);overflow:hidden"></div>')
        this.containerDOM.css("background-color", "rgba(255, 255, 255, 0.8)")
        this.containerDOM.hover(() => {
            this.containerDOM.css("background-color", "rgba(255, 255, 255, 1)")
        }, () => {
            this.containerDOM.css("background-color", "rgba(255, 255, 255, 0.8)")
        });
        this.containerDOM.append(this.DOM)
        $('body').append(this.containerDOM)

        this.emptyContentAndDrawTabControl()
        this.drawButtons(null,this.infoContentDiv)
        this.selectedObjects = null;

        this.liveMonitorManager=new infoPanel_liveMonitor(this)
        this.liveMonitorManager.showBlank()
    }

    minimizeWindow() {
        var pos=this.containerDOM.width()-60
        this.containerDOM.animate({
            right: `-${pos}px`,
            height: "50px"
        })
        this.isMinimized = true;
    }

    expandWindow() {
        this.containerDOM.animate({
            right: "0px",
            height: "70%"
        })
        this.isMinimized = false;
    }

    rxMessage(msgPayload) {
        if (msgPayload.message == "startSelectionDialog_closed") {
            if (!this.containerDOM.is(":visible")) {
                this.containerDOM.show()
                this.containerDOM.addClass("w3-animate-right")
            }
        } else if (msgPayload.message == "mapFlyingStart") {
            this.minimizeWindow()
        } else if (msgPayload.message == "mapFlyingEnd") {
            this.expandWindow()
        } else if (msgPayload.message == "mapSelectFeature") {
            if (msgPayload.DBTwin != null) {
                var twinID = msgPayload.DBTwin.id
                var adtTwin = globalCache.storedTwins[twinID]
                this.showInfoOfNodes([adtTwin])
            }
        } else if (msgPayload.message == "showInfoSelectedNodes" || msgPayload.message == "showInfoHoveredEle") {
            if (globalCache.showFloatInfoPanel && msgPayload.message == "showInfoHoveredEle") return; //the floating info window will show mouse over element information, do not change info panel content in this case
            this.showInfoOfNodes(msgPayload.info)
        }else if(msgPayload.message == "addLiveMonitor") {
            this.liveMonitorManager.addChart(msgPayload.twinID,msgPayload.propertyPath)
        }else if(msgPayload.message=="liveData"){
            var msgBody=msgPayload.body
            this.liveMonitorManager.drawNewData(msgBody.twinID,msgBody.propertyPath,msgBody.value,msgBody.time)
        }
        
    }

    showInfoOfNodes(arr) {
        this.emptyContentAndDrawTabControl()
        if (arr == null || arr.length == 0) {
            this.drawButtons(null,this.infoContentDiv)
            this.selectedObjects = [];
            return;
        }
        this.selectedObjects = arr;
        if (arr.length == 1) {
            var singleElementInfo = arr[0];
            singleElementInfo=this.fetchRealElementInfo(singleElementInfo)
            if (singleElementInfo["$dtId"]) {// select a node
                this.drawButtons("singleNode",this.infoContentDiv)
            }else if (singleElementInfo["$sourceId"]) {
                this.drawButtons("singleRelationship",this.infoContentDiv)
            }else if(singleElementInfo["simNodeName"]){
                this.drawSimDatasourceInfo(singleElementInfo,this.infoContentDiv)
                return;
            }

            var propertiesSection= new simpleExpandableSection("Properties Section",this.infoContentDiv,{"marginTop":"2px"})
            propertiesSection.callBack_change=(status)=>{this.openPropertiesSection=status}
            if(this.openPropertiesSection) propertiesSection.expand()

            if (singleElementInfo["$dtId"]) {// select a node
                var singleDBTwinInfo=globalCache.DBTwins[singleElementInfo["$dtId"]]
                this.drawSingleNodeProperties(singleDBTwinInfo,singleElementInfo,propertiesSection.listDOM)
            } else if (singleElementInfo["$sourceId"]) {
                this.drawSingleRelationProperties(singleElementInfo,propertiesSection.listDOM)
            }

            if (singleElementInfo["$dtId"]) this.drawFormulaSection(singleElementInfo["$dtId"],singleElementInfo["$metadata"]["$model"])
        } else if (arr.length > 1) {
            this.drawButtons("multiple",this.infoContentDiv)
            this.drawMultipleObj()
        }
    }

    emptyContentAndDrawTabControl(){
        if(this.infoContentDiv) this.infoContentDiv.empty()
        else{
            this.DOM.empty()

            this.infoContentDiv=$('<div class="w3-animate-opacity" style="width:100%;float:left;height:calc(100% - 1px);overflow:auto"></div>')
            this.liveContentDiv=$('<div id="myChart" class="w3-animate-opacity w3-border-left" style="float:left;padding-top:5px;display:none;height:calc(100% - 1px);overflow:auto"></div>')
            this.DOM.append(this.infoContentDiv,this.liveContentDiv)
        
            this.livePaneButton.on("click",()=>{
                if(!this.liveContentDiv.is(":visible")){
                    this.liveContentDiv.show()
                    this.containerDOM.css("width","600px")
                    this.infoContentDiv.css("width","50%")
                    this.liveContentDiv.css("width","50%")
                    this.livePaneButton.text("Hide Live Pane")
                }else{
                    this.liveContentDiv.hide()
                    this.containerDOM.css("width","350px")
                    this.infoContentDiv.css("width","100%")
                    this.livePaneButton.text("Show Live Pane")
                }
                
            })
        }
    }

    drawButtons(selectType,parentDOM) {
        if(selectType==null){
            var div=$("<div style='padding:8px'><a style='display:block;font-style:italic;color:gray'>Right click twins or relationships to operate</a><a style='display:block;font-style:italic;color:gray;padding-top:20px'>Press shift key to draw box and select multiple twins in topology view</a><a style='display:block;font-style:italic;color:gray;padding-top:20px'>Press ctrl+z and ctrl+y to undo/redo in topology view; ctrl+s to save layout</a><a style='display:block;font-style:italic;color:gray;padding-top:20px;padding-bottom:20px'>Press shift or ctrl key to select multiple twins in tree view</a><a style='display:block;font-style:italic;color:gray;padding-top:12px;padding-bottom:5px'>Import twins data by clicking button below</a></div>")
            parentDOM.append(div)
        }

        var buttonHolderDOM=parentDOM

        var impBtn = $('<button class="w3-bar-item w3-button w3-blue"><i class="fas fa-cloud-upload-alt"></i></button>')
        var actualImportTwinsBtn = $('<input type="file" name="modelFiles" multiple="multiple" style="display:none"></input>')
        if (selectType != null) {
            var refreshBtn = $('<button class="w3-ripple w3-bar-item w3-button w3-black"><i class="fas fa-sync-alt"></i></button>')
            var expBtn = $('<button class="w3-ripple w3-bar-item w3-button w3-green"><i class="fas fa-cloud-download-alt"></i></button>')
            buttonHolderDOM.append(refreshBtn, expBtn, impBtn, actualImportTwinsBtn)
            refreshBtn.on("click", () => { this.refreshInfomation() })
            expBtn.on("click", () => {
                //find out the twins in selection and their connections (filter both src and target within the selected twins)
                //and export them
                this.exportSelected()
            })
        } else {
            buttonHolderDOM.append(impBtn, actualImportTwinsBtn)
        }

        impBtn.on("click", () => { actualImportTwinsBtn.trigger('click'); })
        actualImportTwinsBtn.change(async (evt) => {
            var files = evt.target.files; // FileList object
            await this.readTwinsFilesContentAndImport(files)
            actualImportTwinsBtn.val("")
        })
        if (selectType == null) return;

        var numOfNode = 0;
        var arr = this.selectedObjects;
        arr.forEach(element => {
            if (element['$dtId']) numOfNode++
        });
        if (numOfNode > 1) {
            //some additional buttons when select multiple items
            this.drawAdvanceAlignmentButtons()
        }
    }

    async drawAdvanceAlignmentButtons() {
        var label = $("<label class='w3-gray' style='display:block;margin-top:5px;width:20%;text-align:center;font-size:1em;padding:2px 4px;font-weight:normal;border-radius: 2px;'>Arrange</label>")
        this.infoContentDiv.append(label)
        var alignButtonsTable = $("<table style='margin:0 auto'><tr><td></td><td></td><td></td></tr><tr><td></td><td style='text-align:center;font-weight:bold;color:darkGray'>ALIGN</td><td></td></tr><tr><td></td><td></td><td></td></tr></table>")
        this.infoContentDiv.append(alignButtonsTable)
        var alignTopButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-chevron-up"></i></button>')
        var alignLeftButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-chevron-left"></i></button>')
        var alignRightButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-chevron-right"></i></button>')
        var alignBottomButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-chevron-down"></i></button>')
        alignButtonsTable.find("td").eq(1).append(alignTopButton)
        alignButtonsTable.find("td").eq(3).append(alignLeftButton)
        alignButtonsTable.find("td").eq(5).append(alignRightButton)
        alignButtonsTable.find("td").eq(7).append(alignBottomButton)


        var arrangeTable = $("<table style='margin:0 auto'><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></table>")
        this.infoContentDiv.append(arrangeTable)

        var distributeHButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-ellipsis-h fa-lg"></i></button>')
        var distributeVButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-ellipsis-v fa-lg"></i></button>')
        var leftRotateButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-undo-alt fa-lg"></i></button>')
        var rightRotateButton = $('<button class="w3-ripple w3-button w3-border"><i class="fas fa-redo-alt fa-lg"></i></button>')
        var mirrorHButton = $('<button class="w3-ripple w3-button w3-border" style="width:100%"><i class="fas fa-arrows-alt-h"></i></button>')
        var mirrorVButton = $('<button class="w3-ripple w3-button w3-border" style="width:100%"><i class="fas fa-arrows-alt-v"></i></button>')
        var expandButton = $('<button class="w3-ripple w3-button w3-border" style="width:100%"><i class="fas fa-expand-arrows-alt"></i></button>')
        var compressButton = $('<button class="w3-ripple w3-button w3-border" style="width:100%"><i class="fas fa-compress-arrows-alt"></i></button>')

        arrangeTable.find("td").eq(0).append(distributeHButton)
        arrangeTable.find("td").eq(1).append(distributeVButton)
        arrangeTable.find("td").eq(2).append(leftRotateButton)
        arrangeTable.find("td").eq(3).append(rightRotateButton)
        arrangeTable.find("td").eq(4).append(mirrorHButton)
        arrangeTable.find("td").eq(5).append(mirrorVButton)
        arrangeTable.find("td").eq(6).append(expandButton)
        arrangeTable.find("td").eq(7).append(compressButton)


        alignTopButton.on("click", (e) => {
            this.broadcastMessage({ "message": "alignSelectedNode", direction: "top" })
            $(document.activeElement).blur()
        })
        alignLeftButton.on("click", () => {
            this.broadcastMessage({ "message": "alignSelectedNode", direction: "left" })
            $(document.activeElement).blur()
        })
        alignRightButton.on("click", () => {
            this.broadcastMessage({ "message": "alignSelectedNode", direction: "right" })
            $(document.activeElement).blur()
        })
        alignBottomButton.on("click", () => {
            this.broadcastMessage({ "message": "alignSelectedNode", direction: "bottom" })
            $(document.activeElement).blur()
        })

        distributeHButton.on("click", () => {
            this.broadcastMessage({ "message": "distributeSelectedNode", direction: "horizontal" })
            $(document.activeElement).blur()
        })
        distributeVButton.on("click", () => {
            this.broadcastMessage({ "message": "distributeSelectedNode", direction: "vertical" })
            $(document.activeElement).blur()
        })
        leftRotateButton.on("click", () => {
            this.broadcastMessage({ "message": "rotateSelectedNode", direction: "left" })
            $(document.activeElement).blur()
        })
        rightRotateButton.on("click", () => {
            this.broadcastMessage({ "message": "rotateSelectedNode", direction: "right" })
            $(document.activeElement).blur()
        })
        mirrorHButton.on("click", () => {
            this.broadcastMessage({ "message": "mirrorSelectedNode", direction: "horizontal" })
            $(document.activeElement).blur()
        })
        mirrorVButton.on("click", () => {
            this.broadcastMessage({ "message": "mirrorSelectedNode", direction: "vertical" })
            $(document.activeElement).blur()
        })
        expandButton.on("click", () => {
            this.broadcastMessage({ "message": "dimensionSelectedNode", direction: "expand" })
            $(document.activeElement).blur()
        })
        compressButton.on("click", () => {
            this.broadcastMessage({ "message": "dimensionSelectedNode", direction: "compress" })
            $(document.activeElement).blur()
        })
    }


    async exportSelected() {
        var arr = this.selectedObjects;
        if (arr.length == 0) return;
        var twinIDArr = []
        var twinToBeStored = []
        var twinIDs = {}
        arr.forEach(element => {
            if (element['$sourceId']) return
            twinIDArr.push(element['$dtId'])
            var anExpTwin = {}
            anExpTwin["$metadata"] = { "$model": element["$metadata"]["$model"] }
            for (var ind in element) {
                if (ind == "$metadata" || ind == "$etag") continue
                else anExpTwin[ind] = element[ind]
            }
            twinToBeStored.push(anExpTwin)
            twinIDs[element['$dtId']] = 1
        });
        var relationsToBeStored = []
        twinIDArr.forEach(oneID => {
            var relations = globalCache.storedOutboundRelationships[oneID]
            if (!relations) return;
            relations.forEach(oneRelation => {
                var targetID = oneRelation["$targetId"]
                if (twinIDs[targetID]) {
                    var obj = {}
                    for (var ind in oneRelation) {
                        if (ind == "$etag" || ind == "$relationshipId" || ind == "$sourceId" || ind == "sourceModel") continue
                        obj[ind] = oneRelation[ind]
                    }
                    var oneAction = {
                        "$srcId": oneID,
                        "$relationshipId": oneRelation["$relationshipId"],
                        "obj": obj
                    }
                    relationsToBeStored.push(oneAction)
                }
            })
        })
        var finalJSON = { "twins": twinToBeStored, "relations": relationsToBeStored }
        var pom = $("<a></a>")
        pom.attr('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(finalJSON)));
        pom.attr('download', "exportTwinsData.json");
        pom[0].click()
    }

    async readOneFile(aFile) {
        return new Promise((resolve, reject) => {
            try {
                var reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result)
                };
                reader.readAsText(aFile);
            } catch (e) {
                reject(e)
            }
        })
    }

    async readTwinsFilesContentAndImport(files) {
        var importTwins = []
        var importRelations = []
        for (var i = 0; i< files.length; i++) {
            var f=files[i]
            // Only process json files.
            if (f.type != "application/json") continue;
            try {
                var str = await this.readOneFile(f)
                var obj = JSON.parse(str)
                if (obj.twins) importTwins = importTwins.concat(obj.twins)
                if (obj.relations) importRelations = importRelations.concat(obj.relations)
            } catch (err) {
                alert(err)
            }
        }

        var oldTwinID2NewID = {}
        importTwins.forEach(oneTwin => {
            var oldID = oneTwin["$dtId"]
            var newID = globalCache.uuidv4();
            oldTwinID2NewID[oldID] = newID
            oneTwin["$dtId"] = newID
        })

        for (var i = importRelations.length - 1; i >= 0; i--) {
            var oneRel = importRelations[i]
            if (oldTwinID2NewID[oneRel["$srcId"]] == null || oldTwinID2NewID[oneRel["obj"]["$targetId"]] == null) {
                importRelations.splice(i, 1)
            } else {
                oneRel["$srcId"] = oldTwinID2NewID[oneRel["$srcId"]]
                oneRel["obj"]["$targetId"] = oldTwinID2NewID[oneRel["obj"]["$targetId"]]
                oneRel["$relationshipId"] = globalCache.uuidv4();
            }
        }


        try {
            var re = await msalHelper.callAPI("digitaltwin/batchImportTwins", "POST", { "twins": JSON.stringify(importTwins) }, "withProjectID")
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
            return;
        }

        re.DBTwins = JSON.parse(re.DBTwins)
        re.ADTTwins = JSON.parse(re.ADTTwins)
        re.DBTwins.forEach(DBTwin => { globalCache.storeSingleDBTwin(DBTwin) })
        var adtTwins = []
        re.ADTTwins.forEach(ADTTwin => {
            globalCache.storeSingleADTTwin(ADTTwin)
            adtTwins.push(ADTTwin)
        })

        this.broadcastMessage({ "message": "addNewTwins", "twinsInfo": adtTwins })

        //continue to import relations
        try {
            var relationsImported = await msalHelper.callAPI("digitaltwin/createRelations", "POST", { actions: JSON.stringify(importRelations) })
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }
        globalCache.storeTwinRelationships_append(relationsImported)
        this.broadcastMessage({ "message": "drawAllRelations", info: relationsImported })

        var numOfTwins = adtTwins.length
        var numOfRelations = relationsImported.length
        var str = "Add " + numOfTwins + " node" + ((numOfTwins <= 1) ? "" : "s") + ` (from ${importTwins.length})`
        str += " and " + numOfRelations + " relationship" + ((numOfRelations <= 1) ? "" : "s") + ` (from ${importRelations.length})`
        var confirmDialogDiv = new simpleConfirmDialog()
        confirmDialogDiv.show(
            { width: "400px" },
            {
                title: "Import Result"
                , content: str
                , buttons: [
                    {
                        colorClass: "w3-gray", text: "Ok", "clickFunc": () => {
                            confirmDialogDiv.close()
                        }
                    }
                ]
            }
        )

    }

    async refreshInfomation() {
        var twinIDs = []
        this.selectedObjects.forEach(oneItem => { if (oneItem['$dtId']) twinIDs.push(oneItem['$dtId']) })
        try {
            var twinsdata = await msalHelper.callAPI("digitaltwin/listTwinsForIDs", "POST", twinIDs)
            twinsdata.forEach(oneRe => {
                var twinID = oneRe['$dtId']
                if (globalCache.storedTwins[twinID] != null) {
                    globalCache.storeSingleADTTwin(oneRe)
                }
            })
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }

        while (twinIDs.length > 0) {
            var smallArr = twinIDs.splice(0, 100);
            try {
                var data = await msalHelper.callAPI("digitaltwin/getRelationshipsFromTwinIDs", "POST", smallArr)
                if (data == "") continue;
                globalCache.storeTwinRelationships(data) //store them in global available array
                this.broadcastMessage({ "message": "drawAllRelations", info: data })
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
            }
        }
        //redraw infopanel if needed
        if (this.selectedObjects.length == 1) this.rxMessage({ "message": "showInfoSelectedNodes", info: this.selectedObjects })
    }

    drawFormulaSection(formulaTwinID,formulaTwinModelID){
        var formulaSection= new simpleExpandableSection("Live Calculation Section",this.infoContentDiv)
        formulaSection.callBack_change=(status)=>{this.openLiveCalculationSection=status}
        if(this.openLiveCalculationSection) formulaSection.expand()

        //list all incoming twins
        var incomingNeighbourLbl=this.generateSmallKeyDiv("Incoming Twins And Self","2px")
        var lbl1=$('<lbl style="font-size:10px;color:gray">(Click to add twin name to script)</lbl>')
        incomingNeighbourLbl.append(lbl1)
        formulaSection.listDOM.append(incomingNeighbourLbl)
        
        var incomingTwins=globalCache.getStoredAllInboundRelationsSources(formulaTwinID)
        
        var scriptLbl=this.generateSmallKeyDiv("Calculation Script","2px")
        scriptLbl.css("margin-top","10px")

        var lbl2=$('<lbl style="font-size:10px;color:gray">(Build in variables:_self _twinVal)</lbl>')
        scriptLbl.append(lbl2)

        var placeHolderStr='Sample&#160;Script&#58;&#10;&#10;if(_twinVal["intwin1"]["p1"]["childProp"]){&#10;&#9;_self["outProp"]=_twinVal["intwin1"]["p2"]&#10;}else{&#10;&#9;_self["outProp"]=_twinVal["intwin1"]["p2"]&#32;+&#32;&#10;&#9;&#9;_twinVal["intwin2"]["p3"]["p4"]&#10;}'
        var scriptTextArea=$('<textarea class="w3-border" spellcheck="false" style="outline:none;font-size:11px;height:240px;width:100%;font-family:Verdana" placeholder='+placeHolderStr+'></textarea>')
        scriptTextArea.on("keydown", (e) => {
            if (e.keyCode == 9){
                this.insertToTextArea('\t',scriptTextArea)
                return false;
            }
        })
        var DBFormulaTwin=globalCache.DBTwins[formulaTwinID]
        if(DBFormulaTwin && DBFormulaTwin["originalScript"]) scriptTextArea.val(DBFormulaTwin["originalScript"])
        
        var highlightColors=[
            ["Purple","#d0bfff"],["Cyan","#00bcd4"],["Amber","#ffc107"],["Lime","#cddc39"],["Pink","#e91e63"]
        ]
        //["Gray","#9e9e9e"]
        var hasIncomingTwins=false
        var twinNamesForHighlight=[]
        //build in key word
        twinNamesForHighlight.push({ "highlight": "_self", "className": "Gray"})
        twinNamesForHighlight.push({ "highlight": "_twinVal", "className": "keyword"})
        var colorIndex=0;
        for(var twinID in incomingTwins){
            hasIncomingTwins=true
            var twinName=globalCache.twinIDMapToDisplayName[twinID]
            twinNamesForHighlight.push({ "highlight": twinName, "className": highlightColors[colorIndex][0]})

            this.createQuickBtnForTwin(twinName,highlightColors[colorIndex][1],formulaSection.listDOM,scriptTextArea)
            colorIndex++
            if(colorIndex>=highlightColors.length)colorIndex=0
        }

        this.createQuickBtnForTwin("Self","#9e9e9e",formulaSection.listDOM,scriptTextArea,formulaTwinModelID)

        if(!hasIncomingTwins)formulaSection.listDOM.append($('<label>No incoming twins</label>'))
        formulaSection.listDOM.append(scriptLbl)
        formulaSection.listDOM.append(scriptTextArea)
        scriptTextArea.highlightWithinTextarea({highlight: twinNamesForHighlight});

        var testScriptBtn = $('<button class="w3-ripple w3-button w3-light-gray w3-hover-amber">Test</button>')
        var confirmScriptBtn = $('<button class="w3-ripple w3-button w3-green  w3-hover-amber">Confirm</button>')
        formulaSection.listDOM.append(testScriptBtn, confirmScriptBtn)


        scriptTextArea.on("keyup",()=>{
            scriptTestDialog.scriptContent=scriptTextArea.val()
        })

        testScriptBtn.on("click",()=>{
            var valueTemplate={}
            this.getPropertyValueTemplate(modelAnalyzer.DTDLModels[formulaTwinModelID].editableProperties,[],valueTemplate)
            var inputArr = globalCache.findAllInputsInScript(scriptTextArea.val(),DBFormulaTwin["displayName"])
            scriptTestDialog.popup(inputArr,DBFormulaTwin["displayName"],formulaTwinModelID,valueTemplate)
            scriptTestDialog.scriptContent=scriptTextArea.val()
        })
        confirmScriptBtn.on("click",()=>{
            this.confirmScript(scriptTextArea.val(),formulaTwinID,formulaTwinModelID,DBFormulaTwin["displayName"])
        })
    }

    async confirmScript(scriptContent,formulaTwinID,formulaTwinModelID,formulaTwinName){
        //detect if there is prohibitted words, if so, reject the submit request
        scriptContent=scriptContent.replaceAll(`_twinVal["${formulaTwinName}"][`,"_self[")
        scriptContent=scriptContent.replaceAll(`_twinVal['${formulaTwinName}'][`,"_self[")
        //translate script, replace twins name to twins ID
        var translateResult=this.convertToActualScript(scriptContent,formulaTwinID)

        var valueTemplate={}
        this.getPropertyValueTemplate(modelAnalyzer.DTDLModels[formulaTwinModelID].editableProperties
            ,[],valueTemplate)

        var inputValueArr=[]
        var inputAnalysisResult= globalCache.findAllInputsInScript(scriptContent,formulaTwinName)
        inputAnalysisResult.forEach(ele=>{
            inputValueArr.push({
                "twinID":globalCache.twinDisplayNameMapToID[ele.twinName_origin],
                "path":ele.path,
                "value":ele.value
            })
        })
            
        var theBody={
            "twinID": formulaTwinID,
            "originalScript":scriptContent,
            "actualScript":translateResult,
            "baseValueTemplate":valueTemplate,
            "projectID":globalCache.currentProjectID,
            "currentInputValue":inputValueArr
        }

        //console.log({"payload":JSON.stringify(theBody) })
        //by using withProjectID it will ensure it is the authorized person send the command
        try{ 
            await msalHelper.callAPI("digitaltwin/updateFormula", "POST", {"payload":JSON.stringify(theBody) }, "withProjectID")
            globalCache.DBTwins[formulaTwinID]["originalScript"]=scriptContent
        }catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }
    }


    getPropertyValueTemplate(jsonInfo,pathArr,valueTemplateRoot){
        for(var ind in jsonInfo){
            var newPath=pathArr.concat([ind])
            if(!Array.isArray(jsonInfo[ind]) && typeof(jsonInfo[ind])==="object") {
                valueTemplateRoot[ind]={}
                this.getPropertyValueTemplate(jsonInfo[ind],newPath,valueTemplateRoot[ind])
            }
        }
    }

    convertToActualScript(scriptContent,formulaTwinID){
        //change all the twin name to twin ID
        var patt = /(?<=_twinVal\[\").*?(?=\"\])/g;
        var result = scriptContent.replace(patt,(aTwinName)=>{
            var aTwinID=globalCache.twinDisplayNameMapToID[aTwinName]
            return aTwinID
        } );
        return result;
    }


    getTwinPropertyOptionsArr(jsonInfo,pathArr,optionsArr){
        for(var ind in jsonInfo){
            var newPath=pathArr.concat([ind])
            if(!Array.isArray(jsonInfo[ind]) && typeof(jsonInfo[ind])==="object") {
                this.getTwinPropertyOptionsArr(jsonInfo[ind],newPath,optionsArr)
            }else {
                optionsArr.push('["'+newPath.join('"]["')+'"]')
            }
        }
    }
    
    createQuickBtnForTwin(twinName,colorCode,parentDOM,textAreaDom,selfModelID) {
        var aSelectMenu=new simpleSelectMenu(twinName,{"optionListHeight":200,"buttonCSS":{"background-color":colorCode,"padding":"2px 5px","margin-right":"1px"}})

        if(twinName!="Self"){
            var aDBTwin=globalCache.getSingleDBTwinByName(twinName)
            var modelID=aDBTwin["modelID"]
        }else{
            modelID=selfModelID
        }
        
        var properties=modelAnalyzer.DTDLModels[modelID].editableProperties
        var optionsArr=[]
        var pathArr=[]
        this.getTwinPropertyOptionsArr(properties,pathArr,optionsArr)
        optionsArr.forEach((oneOption)=>{
            aSelectMenu.addOption(oneOption)
        })
        parentDOM.append(aSelectMenu.DOM) 
        aSelectMenu.callBack_clickOption=(optionText,optionValue,realMouseClick)=>{
            if(twinName=="Self") var str='_self'+optionText
            else str='_twinVal["'+twinName+'"]'+optionText
            this.insertToTextArea(str,textAreaDom)
            textAreaDom.highlightWithinTextarea('update');
            textAreaDom.focus()
        }
    }

    insertToTextArea(str,textAreaDom){
        textAreaDom.focus();
        var startPos = textAreaDom[0].selectionStart;
        var endPos = textAreaDom[0].selectionEnd;
        //var newContent=textAreaDom.val()
        //newContent=newContent.substring(0, startPos)+ str + newContent.substring(endPos, newContent.length);
        //textAreaDom.val(newContent)
        document.execCommand('insertText', false, str); //this way will allow undo still works
        textAreaDom[0].selectionStart=startPos+str.length;
        textAreaDom[0].selectionEnd=startPos+str.length;
    }

    drawMultipleObj() {
        var numOfEdge = 0;
        var numOfNode = 0;
        var arr = this.selectedObjects;
        if (arr == null) return;
        arr.forEach(element => {
            if (element['$sourceId']) numOfEdge++
            else numOfNode++
        });
        var textDiv = $("<label style='display:block;margin-top:10px;margin-left:16px'></label>")
        textDiv.text(numOfNode + " node" + ((numOfNode <= 1) ? "" : "s") + ", " + numOfEdge + " relationship" + ((numOfEdge <= 1) ? "" : "s"))
        this.infoContentDiv.append(textDiv)
    }
}

module.exports = new infoPanel();
},{"../msalHelper":18,"../sharedSourceFiles/baseInfoPanel":19,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/modelAnalyzer":22,"../sharedSourceFiles/scriptTestDialog":28,"../sharedSourceFiles/simpleConfirmDialog":31,"../sharedSourceFiles/simpleExpandableSection":32,"../sharedSourceFiles/simpleSelectMenu":33,"./infoPanel_liveMonitor":8}],8:[function(require,module,exports){
const simpleChart= require("../sharedSourceFiles/simpleChart")
const globalCache = require("../sharedSourceFiles/globalCache")
function infoPanel_liveMonitor(parentInfoPanel){
    this.liveMonitorCharts={}
    this.liveContentDiv = parentInfoPanel.liveContentDiv
    this.parentInfoPanel=parentInfoPanel
}

infoPanel_liveMonitor.prototype.showBlank=function(){
    if(Object.keys(this.liveMonitorCharts).length==0){
        this.liveContentDiv.append($('<div class="w3-text-gray w3-padding">No twin is monitored.</div>'))
    }
}


infoPanel_liveMonitor.prototype.addChart=function(twinID,propertyPath){
    if(Object.keys(this.liveMonitorCharts).length==0) this.liveContentDiv.empty() //remove the label indicate there is no twin 
    var id=this.getChartID(twinID,propertyPath)
    if(this.liveMonitorCharts[id]!=null) return  //the chart is already there
    var customDrawing=(chartDOM)=>{
        var twinName=globalCache.twinIDMapToDisplayName[twinID]
        var twinLabel=$("<label class='w3-lime' style='display:inline;font-size:9px;padding:2px 4px;font-weight:normal;border-radius: 2px;'>"+twinName+"</label>")
        var propertyLabel=$("<label class='w3-gray' style='display:inline;font-size:9px;padding:2px 4px;font-weight:normal;border-radius: 2px;'>"+propertyPath.join(".")+"</label>")

        var removeButton = $('<button class="w3-bar-item w3-right w3-button w3-text-red w3-hover-amber" style="margin-right:13px;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')

        removeButton.on("click",()=>{
            this.liveMonitorCharts[id].destroy()
            delete this.liveMonitorCharts[id]
            this.parentInfoPanel.broadcastMessage({"message": "removeLiveMonitor","twinID":twinID,"propertyPath":propertyPath})
            this.showBlank()
        })

        chartDOM.append(twinLabel,propertyLabel,removeButton) 
    }
    this.liveMonitorCharts[id]=new simpleChart(this.liveContentDiv,60,{width:"100%",height:"100px"},customDrawing)
}

infoPanel_liveMonitor.prototype.drawNewData=function(twinID,propertyPath,value,time){
    var id=this.getChartID(twinID,propertyPath)
    if(!this.liveMonitorCharts[id]) return;
    var ts=parseInt(Date.parse(time)/1000)
    var theChart=this.liveMonitorCharts[id]
    theChart.addDataValue(ts,value)
}

infoPanel_liveMonitor.prototype.getChartID=function(twinID,propertyPath){
    return twinID+"."+propertyPath.join(".")
}



module.exports = infoPanel_liveMonitor;
},{"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/simpleChart":30}],9:[function(require,module,exports){
const startSelectionDialog = require("../sharedSourceFiles/startSelectionDialog")
const modelManagerDialog = require("../sharedSourceFiles/modelManagerDialog")
const editLayoutDialog= require("./editLayoutDialog")
const simpleSelectMenu= require("../sharedSourceFiles/simpleSelectMenu")
const globalCache = require("../sharedSourceFiles/globalCache")
const moduleSwitchDialog=require("../sharedSourceFiles/moduleSwitchDialog")
const projectSettingDialog=require("../sharedSourceFiles/projectSettingDialog")

function mainToolbar() {
}

mainToolbar.prototype.render = function () {
    $("#mainToolBar").addClass("w3-bar w3-red")
    $("#mainToolBar").css({"z-index":100,"overflow":"visible"})

    this.switchProjectBtn=$('<a class="w3-bar-item w3-button" href="#">Project</a>')
    this.modelIOBtn=$('<a class="w3-bar-item w3-button" href="#">Models</a>')
    //this.showForgeViewBtn=$('<a class="w3-bar-item w3-button w3-hover-none w3-text-light-grey w3-hover-text-light-grey" style="opacity:.35" href="#">ForgeView</a>')
    //this.showGISViewBtn=$('<a class="w3-bar-item w3-button" href="#">GISView</a>')
    this.editLayoutBtn=$('<a class="w3-bar-item w3-button" href="#"><i class="fa fa-edit"></i></a>')
    this.floatInfoBtn=$('<a class="w3-bar-item w3-button w3-amber" style="height:100%;font-size:80%" href="#"><span class="fa-stack fa-xs"><i class="fas fa-circle fa-stack-2x fa-inverse"></i><i class="fas fa-info fa-stack-1x w3-text-amber"></i></span></a>')


    this.testSignalRBtn=$('<a class="w3-bar-item w3-button w3-amber" href="#">Test SignalR</a>')
    this.testSendSignalRBtn=$('<a class="w3-bar-item w3-button w3-amber" href="#">send SignalR message</a>')

    this.settingBtn=$('<button class="w3-bar-item w3-button w3-right"><i class="fa fa-cog fa-lg"></i></button>')

    this.viewTypeSelector=new simpleSelectMenu("")
    this.switchLayoutSelector=new simpleSelectMenu("Layout")

    $("#mainToolBar").empty()
    $("#mainToolBar").append(moduleSwitchDialog.modulesSidebar)
    $("#mainToolBar").append(moduleSwitchDialog.modulesSwitchButton, this.switchProjectBtn,this.modelIOBtn,this.viewTypeSelector.  DOM,this.switchLayoutSelector.DOM,this.editLayoutBtn,this.floatInfoBtn
        //,this.testSignalRBtn,this.testSendSignalRBtn
        ,this.settingBtn
    )

    this.switchProjectBtn.on("click",()=>{ startSelectionDialog.popup() })
    this.modelIOBtn.on("click",()=>{ modelManagerDialog.popup() })
    this.settingBtn.on("click",()=>{ projectSettingDialog.popup() })
    this.editLayoutBtn.on("click",()=>{ editLayoutDialog.popup() })
    this.floatInfoBtn.on("click",()=>{
        if(globalCache.showFloatInfoPanel) globalCache.showFloatInfoPanel=false
        else globalCache.showFloatInfoPanel=true
        if(!globalCache.showFloatInfoPanel){
            this.floatInfoBtn.removeClass("w3-amber")
            this.floatInfoBtn.html('<span class="fa-stack fa-xs"><i class="fas fa-ban fa-stack-2x fa-inverse"></i><i class="fas fa-info fa-stack-1x fa-inverse"></i></span>')
        }else{
            this.floatInfoBtn.addClass("w3-amber")
            this.floatInfoBtn.html('<span class="fa-stack fa-xs"><i class="fas fa-circle fa-stack-2x fa-inverse"></i><i class="fas fa-info fa-stack-1x w3-text-amber"></i></span>')
        }
    })

    this.testSendSignalRBtn.on("click",async ()=>{
        const msalHelper=require("../msalHelper")
        await msalHelper.callAzureFunctionsService("messages","POST",{
            recipient: "5eb81f5f-fd9e-481d-996b-4d0b9536f477",
            text: "how do you do"
          })
    })
    this.testSignalRBtn.on("click",async ()=>{
        const msalHelper=require("../msalHelper")
        var signalRInfo = await msalHelper.callAzureFunctionsService("negotiate?name=ff","GET")
        const connection = new signalR.HubConnectionBuilder()
        .withUrl(signalRInfo.url, {accessTokenFactory: () => signalRInfo.accessToken})
        //.configureLogging(signalR.LogLevel.Information)
        .configureLogging(signalR.LogLevel.Warning)
        .build();
        console.log(signalRInfo.accessToken)

        connection.on('newMessage', (message)=>{
            console.log(message)
        });
        connection.onclose(() => console.log('disconnected'));
        console.log('connecting...');
        connection.start()
          .then(() => console.log('connected!'))
          .catch(console.error);
    })

    this.viewTypeSelector.addOption('Topology')
    this.viewTypeSelector.addOption('GIS')
    this.viewTypeSelector.callBack_clickOption=(optionText,optionValue,realMouseClick)=>{
        this.viewTypeSelector.changeName(optionText)
        if(realMouseClick){
            if(globalCache.currentViewType == optionText) return;
            this.broadcastMessage({ "message": "viewTypeChange","viewType":optionText})
        }
        globalCache.currentViewType=optionText
    }
    this.viewTypeSelector.triggerOptionValue("Topology")

    this.switchLayoutSelector.callBack_clickOption=(optionText,optionValue)=>{
        globalCache.currentLayoutName=optionValue
        this.broadcastMessage({ "message": "layoutChange"})
        if(optionValue=="[NA]") this.switchLayoutSelector.changeName("Layout","")
        else this.switchLayoutSelector.changeName("Layout:",optionText)
    }
}

mainToolbar.prototype.updateLayoutSelector = function (chooseLayoutName) {
    var curSelect=chooseLayoutName||this.switchLayoutSelector.curSelectVal
    this.switchLayoutSelector.clearOptions()
    this.switchLayoutSelector.addOption('[No Layout Specified]','[NA]')

    for (var ind in globalCache.layoutJSON) {
        var oneLayoutObj=globalCache.layoutJSON[ind]
        if(oneLayoutObj.owner==globalCache.accountInfo.id) this.switchLayoutSelector.addOption(ind)
    }

    if(curSelect!=null){
        if(this.switchLayoutSelector.findOption(curSelect)==null) this.switchLayoutSelector.changeName("Layout","")
        else this.switchLayoutSelector.changeName("Layout:",curSelect)
    }
}

mainToolbar.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="layoutsUpdated") {
        this.updateLayoutSelector(msgPayload.selectLayout)
    }else if(msgPayload.message=="popupLayoutEditing"){
        editLayoutDialog.popup()
    }
}

module.exports = new mainToolbar();
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/modelManagerDialog":24,"../sharedSourceFiles/moduleSwitchDialog":25,"../sharedSourceFiles/projectSettingDialog":27,"../sharedSourceFiles/simpleSelectMenu":33,"../sharedSourceFiles/startSelectionDialog":35,"./editLayoutDialog":5}],10:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache")

function mapDOM(containerDOM){
    this.DOM=$("<div style='height:100%;width:100%'></div>")
    containerDOM.append(this.DOM)
    this.DOM.hide()

    this.subscriptionKey="jmQb_cjjgpEXq1wB6eRjsQHojUfI2XxgUpbAhiFqBtc"
    this.dataSetId= "e6fcbf83-ac33-ccab-f277-388a49254e8d"
    this.tileSetId="8a9b02e9-db04-2784-dc38-9b31c52160f2"

    this.map = new atlas.Map(this.DOM[0], {
        center:  [103.8394266, 1.31448053],
        zoom: 15,
        style: 'road_shaded_relief',
        view: 'Auto',
        authOptions: {
            authType: 'subscriptionKey',
            subscriptionKey: this.subscriptionKey
        }
    });

    this.map.events.add('ready', ()=> {this.initMap()})
}

mapDOM.prototype.initMap=function(){
    this.mapDataSource = new atlas.source.DataSource("twinPolygon");

    //Add a map style selection control.
    this.map.controls.add(new atlas.control.StyleControl({ mapStyles: "all" }), { position: "top-right" });
    //Create an indoor maps manager.
    this.indoorManager = new atlas.indoor.IndoorManager(this.map, {tilesetId: this.tileSetId});
    this.indoorManager.setOptions({levelControl: new atlas.control.LevelControl({ position: 'top-right' }) });
    this.indoorManager.setDynamicStyling(false)

    this.map.events.add("click",  (e)=> {
        var features = this.map.layers.getRenderedShapes(e.position, 'unit');
        if(features.length==0) return;
        var resultDBTwin=globalCache.getSingleDBTwinByIndoorFeatureID(features[0].properties.featureId)
        if(resultDBTwin!=null){
            this.highlightTwins([resultDBTwin])
            this.broadcastMessage({ "message": "mapSelectFeature","DBTwin":resultDBTwin})
        } 
    });
}

mapDOM.prototype.completeURL=function(apiPart){
    return 'https://us.atlas.microsoft.com/'+apiPart+'api-version=2.0&subscription-key='+this.subscriptionKey
}

mapDOM.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="viewTypeChange"){
        if(msgPayload.viewType=="GIS") this.showSelf()
        else this.hideSelf()
    }else if(msgPayload.message=="showInfoSelectedNodes"){
        if(globalCache.currentViewType!="GIS") return;
        var selectedTwinsArr=msgPayload.info //the last item is the latest selected item
        
        var selectedDBTwins=[]
        selectedTwinsArr.forEach(aTwin=>{
            var twinID=aTwin['$dtId']
            if(!twinID) return;
            var theDBTwin=globalCache.DBTwins[twinID]
            selectedDBTwins.push(theDBTwin)
        })
        this.highlightTwins(selectedDBTwins)
    }
}

mapDOM.prototype.highlightTwins = function (dbTwins) {
    if(dbTwins.length==0) return;
    var latestDBTwin= dbTwins[dbTwins.length-1]
    
    //hide all twins highlight in GIS
    this.mapDataSource.clear()
    if(!latestDBTwin.GIS) return;
    
    //if there is a facility change, there is an animation to pan map, otherwise, donot pan map
    var info=this.indoorManager.getCurrentFacility()
    var curFacility=info[0]
    var curLevelNumber= info[1]
    var destFacility=latestDBTwin.GIS.indoor.facilityID
    if(curFacility!=destFacility){
        var coordinates= latestDBTwin.GIS.indoor.coordinates
        var destLL=coordinates[0][0]
        this.flyTo(destLL)
    }
    //choose the facility and level number
    if(destFacility!=curFacility || curLevelNumber!=latestDBTwin.GIS.indoor.levelOrdinal){
        this.indoorManager.setFacility(destFacility,latestDBTwin.GIS.indoor.levelOrdinal )
    }
    
    //highlight all selected twins in GIS
    dbTwins.forEach(oneDBTwin=>{
        this.drawOneTwinIndoorPolygon(oneDBTwin.GIS.indoor.coordinates)
    })
}

mapDOM.prototype.drawOneTwinIndoorPolygon = function (coordinates) {
    if(!this.map.sources.getById("twinPolygon")){
        this.map.sources.add(this.mapDataSource);
        this.map.layers.add(new atlas.layer.PolygonLayer(this.mapDataSource, null, {
            fillColor: "red",
            fillOpacity: 0.7
        }))
    } 
    this.mapDataSource.add(new atlas.Shape(new atlas.data.Feature(
        new atlas.data.Polygon(coordinates)
    )));
}

mapDOM.prototype.flyTo = function (destLL) {
    var curLoc=this.map.getCamera().center

    if(destLL[0]<curLoc[0]) var targetBounds=[destLL[0],destLL[1],curLoc[0],curLoc[1]]
    else targetBounds=[curLoc[0],curLoc[1], destLL[0],destLL[1]]

    this.map.setCamera({"bounds":targetBounds,
        "padding":{top: 80, bottom: 80, left: 80, right: 80},
    })
    this.broadcastMessage({ "message": "mapFlyingStart"})

    var marker = new atlas.HtmlMarker({color: 'DodgerBlue',text: '',position:curLoc});
    this.map.markers.add(marker);
    var path = [
        curLoc,destLL
    ];
    setTimeout(()=>{
        atlas.animations.moveAlongPath(path, marker, { duration: 1000, captureMetadata: true, autoPlay: true });
        setTimeout(()=>{
            this.broadcastMessage({ "message": "mapFlyingEnd"})
            this.map.setCamera({
                "center": destLL,
                "zoom": 19,
                "duration": 2000,
                "type": "fly"
            })
            setTimeout(()=>{this.map.markers.clear()},3500)
        },1000)
        
    },1000) 
}

mapDOM.prototype.getDistanceFromLatLonInKm = function (lonlat1, lonlat2) {
    var lon1=lonlat1[0]
    var lat1=lonlat1[1]
    var lon2=lonlat2[0]
    var lat2=lonlat2[1]

    var R = 6371; // Radius of the earth in km
    var dLat = this.deg2rad(lat2 - lat1);  // deg2rad below
    var dLon = this.deg2rad(lon2 - lon1);
    var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2)
        ;
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c; // Distance in km
    return d;
}

mapDOM.prototype.deg2rad = function (deg) {
    return deg * (Math.PI / 180)
}

mapDOM.prototype.showSelf = function () {
    this.DOM.show()
    this.DOM.animate({height: "100%"},()=>{this.map.resize()});
}

mapDOM.prototype.hideSelf = function () {
    this.DOM.animate({height: "0%"},()=>{this.DOM.hide()});
}

module.exports = mapDOM;
},{"../sharedSourceFiles/globalCache":21}],11:[function(require,module,exports){
'use strict';

const modelAnalyzer = require("../sharedSourceFiles/modelAnalyzer");
const simpleSelectMenu = require("../sharedSourceFiles/simpleSelectMenu")
const simpleConfirmDialog = require("../sharedSourceFiles/simpleConfirmDialog")
const globalCache = require("../sharedSourceFiles/globalCache")
const msalHelper=require("../msalHelper")
const topologyDOM_styleManager=require("./topologyDOM_styleManager")
const topologyDOM_menu=require("./topologyDOM_menu")
const topologyDOM_visual=require("./topologyDOM_visual")
const topologyDOM_simDataSource=require("./topologyDOM_simDataSource")

function topologyDOM(containerDOM){
    this.DOM=$("<div style='height:100%;width:100%'></div>")
    containerDOM.append(this.DOM)
    this.defaultNodeSize=30
    
    this.lastCalcInputStyleNodes=[]
    this.lastCalcOutputStyleNodes=[]
}

topologyDOM.prototype.init=function(){
    cytoscape.warnings(false)  
    this.core = cytoscape({
        container:  this.DOM[0], // container to render in

        // initial viewport state:
        zoom: 1,
        pan: { x: 0, y: 0 },

        // interaction options:
        minZoom: 0.1,
        maxZoom: 10,
        zoomingEnabled: true,
        userZoomingEnabled: true,
        panningEnabled: true,
        userPanningEnabled: true,
        boxSelectionEnabled: true,
        selectionType: 'single',
        touchTapThreshold: 8,
        desktopTapThreshold: 4,
        autolock: false,
        autoungrabify: false,
        autounselectify: false,

        // rendering options:
        headless: false,
        styleEnabled: true,
        hideEdgesOnViewport: false,
        textureOnViewport: false,
        motionBlur: false,
        motionBlurOpacity: 0.2,
        wheelSensitivity: 0.3,
        pixelRatio: 'auto',

        elements: [], // list of graph elements to start with

        style: []
    });

    this.styleManager=new topologyDOM_styleManager(this.core,this.defaultNodeSize)
    

    //cytoscape edge editing plug-in
    this.core.edgeEditing({
        undoable: true,
        bendRemovalSensitivity: 16,
        enableMultipleAnchorRemovalOption: true,
        stickyAnchorTolerence: 20,
        anchorShapeSizeFactor: 2,
        enableAnchorSizeNotImpactByZoom: true,
        enableRemoveAnchorMidOfNearLine: false,
        enableCreateAnchorOnDrag: false,
        enableAnchorsAbsolutePosition:true,
        disableReconnect:true
    });

    this.core.boxSelectionEnabled(true)


    this.core.on('tapselect', ()=>{this.selectFunction()});
    this.core.on('tapunselect', ()=>{this.selectFunction()});

    this.core.on('boxend',(e)=>{//put inside boxend event to trigger only one time, and repleatly after each box select
        this.core.one('boxselect',()=>{this.selectFunction()})
    })

    this.core.on('mouseover',e=>{
        this.mouseOverFunction(e)
    })
    this.core.on('mouseout',e=>{
        this.mouseOutFunction(e)
    })
    
    this.core.on("zoom",(e)=>{
        this.styleManager.adjustModelsBaseDimension()
    })
    this.styleManager.adjustModelsBaseDimension()
    
    this.setKeyDownFunc()
    
    var tapdragHandler=(e) => { 
        this.smartPositionNode(e.position) 
    }
    var setOneTimeGrab = () => {
        this.core.once("grab", (e) => {
            if(e.target.isNode && e.target.isNode()){
                this.draggingNode=e.target
            } 
            this.core.on("tapdrag",tapdragHandler )
            setOneTimeFree()
        })
    }
    var setOneTimeFree = () => {
        this.core.once("free", (e) => {
            this.draggingNode=null
            setOneTimeGrab()
            this.core.removeListener("tapdrag",tapdragHandler)
        })
    }
    setOneTimeGrab() 

    this.menuManager=new topologyDOM_menu(this)
    this.core.on('grab', (e)=>{
        this.broadcastMessage({ "message": "hideFloatInfoPanel"})
    }) 
    this.core.on('cxttap', (e)=>{
        //hide the float info window
        this.broadcastMessage({ "message": "hideFloatInfoPanel"})
        this.cancelTargetNodeMode()
        this.menuManager.decideVisibleContextMenu(e.target)
    })

    this.visualManager=new topologyDOM_visual(this.core)
    this.simDataSourceManager= new topologyDOM_simDataSource(this)
}

topologyDOM.prototype.hideCollection = function (collection) { 
    collection.remove()
    var twinIDArr = []
    collection.forEach(oneNode => { twinIDArr.push(oneNode.data("originalInfo")['$dtId']) })
    this.broadcastMessage({ "message": "hideSelectedNodes", "twinIDArr": twinIDArr })
}

topologyDOM.prototype.addSimulatorSource = function (twinName) {
    this.simDataSourceManager.newSimulatorSource(twinName)
}

topologyDOM.prototype.enableLiveDataStream = function (twinName) {
    var twinID=globalCache.twinDisplayNameMapToID[twinName]
    var dbtwin=globalCache.DBTwins[twinID]
    var modelID=dbtwin.modelID
    var propertyPaths=modelAnalyzer.fetchPropertyPathsOfModel(modelID)
    var checkBoxes=[]
    
    var dialog=new simpleConfirmDialog()
    dialog.show({"max-width":"450px","min-width":"300px"},{
        "title":"Choose Live Monitor Properties",
        "customDrawing":(parentDOM)=>{
            propertyPaths.forEach((path) => {
                var isIoTCheck = $('<input class="w3-check" style="width:20px;margin-left:16px;margin-right:5px" type="checkbox">')
                var isIoTText = $('<label style="margin-right:12px">'+path.join(".")+'</label>')
                parentDOM.append($('<div style="float:left"/>').append(isIoTCheck, isIoTText))
                checkBoxes.push(isIoTCheck)
                isIoTCheck.data("path",path)
            })
        },
        "buttons":[
            {
                "text": "Live",
                "colorClass":"w3-lime",
                "clickFunc": () => {
                    for(var i=0;i<checkBoxes.length;i++){
                        var aChkBox=checkBoxes[i]
                        if(!aChkBox.prop('checked')) continue
                        var aPath=aChkBox.data("path")
                        this.broadcastMessage({"message": "addLiveMonitor","twinID":twinID,"propertyPath":aPath})
                    }
                    dialog.close()
                }
            },
            {"text":"Cancel","colorClass":"w3-light-gray","clickFunc":()=>{dialog.close()}}
        ]
    })
}

topologyDOM.prototype.loadOutBound=async function(collection) {
    var twinIDArr = []
    collection.forEach(element => {
        var originalInfo = element.data("originalInfo")
        if (originalInfo['$sourceId']) return;
        twinIDArr.push(originalInfo['$dtId'])
    });

    while (twinIDArr.length > 0) {
        var smallArr = twinIDArr.splice(0, 100);

        var knownTargetTwins = {}
        smallArr.forEach(oneID => {
            knownTargetTwins[oneID] = 1 //itself also is known
            var outBoundRelation = globalCache.storedOutboundRelationships[oneID]
            if (outBoundRelation) {
                outBoundRelation.forEach(oneRelation => {
                    var targetID = oneRelation["$targetId"]
                    if (globalCache.storedTwins[targetID] != null) knownTargetTwins[targetID] = 1
                })
            }
        })

        try {
            var data = await msalHelper.callAPI("digitaltwin/queryOutBound", "POST", { arr: smallArr, "knownTargets": knownTargetTwins })
            //new twin's relationship should be stored as well
            globalCache.storeTwinRelationships(data.newTwinRelations)
            data.childTwinsAndRelations.forEach(oneSet => {
                for (var ind in oneSet.childTwins) {
                    var oneTwin = oneSet.childTwins[ind]
                    globalCache.storeSingleADTTwin(oneTwin)
                }
            })
            this.visualManager.drawTwinsAndRelations(data)
            this.broadcastMessage({ "message": "drawTwinsAndRelations", info: data })
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }
    }
}

topologyDOM.prototype.loadInBound=async function(collection) {
    var twinIDArr = []
    collection.forEach(element => {
        var originalInfo = element.data("originalInfo")
        if (originalInfo['$sourceId']) return;
        twinIDArr.push(originalInfo['$dtId'])
    });

    while (twinIDArr.length > 0) {
        var smallArr = twinIDArr.splice(0, 100);
        var knownSourceTwins = {}
        var IDDict = {}
        smallArr.forEach(oneID => {
            IDDict[oneID] = 1
            knownSourceTwins[oneID] = 1 //itself also is known
        })
        for (var twinID in globalCache.storedOutboundRelationships) {
            var relations = globalCache.storedOutboundRelationships[twinID]
            relations.forEach(oneRelation => {
                var targetID = oneRelation['$targetId']
                var srcID = oneRelation['$sourceId']
                if (IDDict[targetID] != null) {
                    if (globalCache.storedTwins[srcID] != null) knownSourceTwins[srcID] = 1
                }
            })
        }

        try {
            var data = await msalHelper.callAPI("digitaltwin/queryInBound", "POST", { arr: smallArr, "knownSources": knownSourceTwins })
            //new twin's relationship should be stored as well
            globalCache.storeTwinRelationships(data.newTwinRelations)
            data.childTwinsAndRelations.forEach(oneSet => {
                for (var ind in oneSet.childTwins) {
                    var oneTwin = oneSet.childTwins[ind]
                    globalCache.storeSingleADTTwin(oneTwin)
                }
            })
            this.visualManager.drawTwinsAndRelations(data)
            this.broadcastMessage({ "message": "drawTwinsAndRelations", info: data })
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }
    }
}

topologyDOM.prototype.deleteSimNode=function(ele){
    this.simDataSourceManager.deleteSimNode(ele)
}


topologyDOM.prototype.deleteElementsArray=async function(arr) {
    if (arr.length == 0) return;
    //clear simulation node first
    arr.forEach(ele=>{
        var dbTwin=globalCache.getSingleDBTwinByName(ele.id())
        for(var simNodeID in dbTwin.simulate){
            var simNode=this.core.nodes("#"+simNodeID)
            if(simNode) this.simDataSourceManager.deleteSimNode(simNode) 
        }
    })

    //then start deleting the real twins
    var relationsArr = []
    var twinIDArr = []
    var twinIDs = {}
    arr.forEach(element => {
        var originalInfo = element.data("originalInfo")
        if(!originalInfo) return;
        if (originalInfo['$sourceId']) relationsArr.push(originalInfo);
        else {
            twinIDArr.push(originalInfo['$dtId'])
            twinIDs[originalInfo['$dtId']] = 1
        }
    });
    for (var i = relationsArr.length - 1; i >= 0; i--) { //clear those relationships that are going to be deleted after twins deleting
        var srcId = relationsArr[i]['$sourceId']
        var targetId = relationsArr[i]['$targetId']
        if (twinIDs[srcId] != null || twinIDs[targetId] != null) {
            relationsArr.splice(i, 1)
        }
    }
    var confirmDialogDiv = new simpleConfirmDialog()
    var dialogStr = ""
    var twinNumber = twinIDArr.length;
    var relationsNumber = relationsArr.length;
    if (twinNumber > 0) dialogStr = twinNumber + " twin" + ((twinNumber > 1) ? "s" : "") + " (with connected relations)"
    if (twinNumber > 0 && relationsNumber > 0) dialogStr += " and additional "
    if (relationsNumber > 0) dialogStr += relationsNumber + " relation" + ((relationsNumber > 1) ? "s" : "")
    dialogStr += " will be deleted. Please confirm"
    confirmDialogDiv.show(
        { width: "350px" },
        {
            title: "Confirm"
            , content: dialogStr
            , buttons: [
                {
                    colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": async () => {
                        confirmDialogDiv.close()
                        if (relationsArr.length > 0) await this.deleteRelations(relationsArr)
                        if (twinIDArr.length > 0) await this.deleteTwins(twinIDArr)
                    }
                },
                {
                    colorClass: "w3-gray", text: "Cancel", "clickFunc": () => {
                        confirmDialogDiv.close()
                    }
                }
            ]
        }
    )
}

topologyDOM.prototype.deleteTwins=async function(twinIDArr) {
    var ioTDevices = []
    twinIDArr.forEach(oneTwinID => {
        var dbTwinInfo = globalCache.DBTwins[oneTwinID]
        if (dbTwinInfo.IoTDeviceID != null && dbTwinInfo.IoTDeviceID != "") {
            ioTDevices.push(dbTwinInfo.IoTDeviceID)
        }
    })
    if (ioTDevices.length > 0) {
        msalHelper.callAPI("devicemanagement/unregisterIoTDevices", "POST", { arr: ioTDevices })
    }

    while (twinIDArr.length > 0) {
        var smallArr = twinIDArr.splice(0, 100);

        try {
            var result = await msalHelper.callAPI("digitaltwin/deleteTwins", "POST", { arr: smallArr }, "withProjectID")
            result.forEach((oneID) => {
                delete globalCache.storedTwins[oneID]
                delete globalCache.storedOutboundRelationships[oneID]
            });
            var theMessage={ "message": "twinsDeleted", twinIDArr: result }
            result.forEach(twinID=>{
                var twinDisplayName=globalCache.twinIDMapToDisplayName[twinID]
                this.core.$('[id = "'+twinDisplayName+'"]').remove()
            })
            this.broadcastMessage(theMessage)
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }
    }
}

topologyDOM.prototype.deleteRelations=async function(relationsArr) {
    var arr = []
    relationsArr.forEach(oneRelation => {
        arr.push({ srcID: oneRelation['$sourceId'], relID: oneRelation['$relationshipId'] })
    })
    try {
        var data = await msalHelper.callAPI("digitaltwin/deleteRelations", "POST", { "relations": arr })
        globalCache.storeTwinRelationships_remove(data)
        this.rxMessage({ "message": "relationsDeleted", "relations": data })
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
    }
}

topologyDOM.prototype.smartPositionNode = function (mousePosition) {
    if(this.core.nodes(':selected').length>1) return
    var zoomLevel=this.core.zoom()
    if(!this.draggingNode) return
    //consider lock mouse move position for these nodes:
    // - its connectfrom nodes and their connectto nodes
    // - its connectto nodes and their connectfrom nodes
    var incomers=this.draggingNode.incomers()
    var outer=this.draggingNode.outgoers()

    //also find the nearby node within certain x y offset area
    var rpos=this.draggingNode.renderedPosition()
    var nearbyNodes=this.core.collection()
    var threshold=150
    this.core.nodes().forEach(ele=>{
        var eleRPos=ele.renderedPosition()
        if(Math.abs(eleRPos.x-rpos.x)<threshold && Math.abs(eleRPos.y-rpos.y)<threshold) {
            nearbyNodes.merge(ele)
        }
    })
    
    var monitorSet=incomers.union(outer).union(nearbyNodes).filter('node').unmerge(this.draggingNode)

    var returnExpectedPos=(diffArr,posArr)=>{
        var minDistance=Math.min(...diffArr)
        if(minDistance*zoomLevel < 10)  return posArr[diffArr.indexOf(minDistance)]
        else return null;
    }

    var xDiff=[]
    var xPos=[]
    var yDiff=[]
    var yPos=[]
    monitorSet.forEach((ele)=>{
        xDiff.push(Math.abs(ele.position().x-mousePosition.x))
        xPos.push(ele.position().x)
        yDiff.push(Math.abs(ele.position().y-mousePosition.y))
        yPos.push(ele.position().y)
    })
    var prefX=returnExpectedPos(xDiff,xPos)
    var prefY=returnExpectedPos(yDiff,yPos)
    if(prefX!=null) {
        this.draggingNode.position('x', prefX);
    }
    if(prefY!=null) {
        this.draggingNode.position('y', prefY);
    }
    //console.log("----")
    //monitorSet.forEach((ele)=>{console.log(ele.id())})
    //console.log(monitorSet.size())
}

topologyDOM.prototype.mouseOverFunction= function (e) {
    if(!e.target.data) return
    
    var info=e.target.data().originalInfo

    if(info==null) return;

    if(this.lastHoverTarget) this.lastHoverTarget.removeClass("hover")

    this.lastCalcInputStyleNodes.forEach(ele=>{ele.removeClass("calcInput")})
    this.lastCalcInputStyleNodes.length=0
    this.lastCalcOutputStyleNodes.forEach(ele=>{ele.removeClass("calcOutput")})
    this.lastCalcOutputStyleNodes.length=0
    

    this.lastHoverTarget=e.target
    e.target.addClass("hover")

    //digital twins info
    this.broadcastMessage({ "message": "showInfoHoveredEle", "info": [info],"screenXY":this.convertPosition(e.position.x,e.position.y) })

    //if there is calculation script in hovered node, highlight input nodes and the properties
    if(info["$dtId"]){
        var twinID=info["$dtId"]
        var dbtwin=globalCache.DBTwins[twinID]
        var inputArr = dbtwin["inputs"]
        if(inputArr) inputArr.forEach(oneInput=>{this.visualizeSingleInputInTwinCalculation(oneInput,e.target)})

        this.analyseSingleOutput(e.target,info["$dtId"])
    }
}

topologyDOM.prototype.analyseSingleOutput = function (twinTopoNode,twinID) {
    //check if its output is another node's input
    var furtherInputsArr=[]
    for (var aTwinID in globalCache.DBTwins) {
        var checkDBTwin = globalCache.DBTwins[aTwinID]
        var inputArr=checkDBTwin["inputs"]
        if(!inputArr) continue;
        for(var i=0;i<inputArr.length;i++){
            var aFurtherInput=inputArr[i]
            if(aFurtherInput.twinID==twinID){
                furtherInputsArr.push({"path":aFurtherInput.path,"targetTwinName":checkDBTwin.displayName})
                break;
            }
        }
    }
    if(furtherInputsArr) furtherInputsArr.forEach(oneFurtherInput=>{
        this.visualizeSingleInputInTwinCalculation(oneFurtherInput,twinTopoNode)
    })
}

topologyDOM.prototype.visualizeSingleInputInTwinCalculation = function (oneInput,twinTopoNode) {
    var twinName = globalCache.twinIDMapToDisplayName[oneInput.twinID]
    var edges=null;
    if(oneInput.targetTwinName){
        var targetTwinNode =this.core.nodes(`[id="${oneInput.targetTwinName}"]`)
        if (targetTwinNode) {
            targetTwinNode.addClass("calcOutput")
            this.lastCalcOutputStyleNodes.push(targetTwinNode)
            //find the first relationship link from this node to hovered node
            var edges = twinTopoNode.edgesTo(targetTwinNode)
        }
    } else {
        var inputTwinNode =this.core.nodes(`[id="${twinName}"]`)
        if (inputTwinNode) {
            inputTwinNode.addClass("calcInput")
            this.lastCalcInputStyleNodes.push(inputTwinNode)
            //find the first relationship link from this node to hovered node
            var edges = inputTwinNode.edgesTo(twinTopoNode)
        }
    }
    if(edges && edges.length > 0){
        if(oneInput.targetTwinName) {
            edges[0].addClass("calcOutput")
            this.lastCalcOutputStyleNodes.push(edges[0])
        }else{
            edges[0].addClass("calcInput")
            this.lastCalcInputStyleNodes.push(edges[0])
        } 
        var currentPPath = edges[0].data('ppath') || ""
        if (currentPPath != "") currentPPath += ";"
        currentPPath += oneInput.path.join("/")
        edges[0].data('ppath', currentPPath)
        
        var randOffset= parseInt(Math.random()*40)+20
        edges[0].data('ppathOffset', randOffset+"%")
    }
}



topologyDOM.prototype.convertPosition=function(x,y){
    var vpExtent=this.core.extent()
    var screenW=this.DOM.width()
    var screenH=this.DOM.height()
    var screenX = (x-vpExtent.x1)/(vpExtent.w)*screenW + this.DOM.offset().left
    var screenY=(y-vpExtent.y1)/(vpExtent.h)*screenH+ this.DOM.offset().top
    return {x:screenX,y:screenY}
}

topologyDOM.prototype.mouseOutFunction= function (e) {
    if(!globalCache.showFloatInfoPanel){ //since floating window is used for mouse hover element info, so info panel never chagne before, that is why there is no need to restore back the info panel information at mouseout
        if(globalCache.showingCreateTwinModelID){
            this.broadcastMessage({ "message": "showInfoGroupNode", "info": {"@id":globalCache.showingCreateTwinModelID} })
        }else{
            this.selectFunction()
        }
    }
    
    this.broadcastMessage({ "message": "hideFloatInfoPanel"})

    if(this.lastHoverTarget){
        this.lastHoverTarget.removeClass("hover")
        this.lastHoverTarget=null;
    } 
    this.lastCalcInputStyleNodes.forEach(ele=>{
        ele.removeClass("calcInput")
        ele.data('ppath',null)
    })
    this.lastCalcInputStyleNodes.length=0
    this.lastCalcOutputStyleNodes.forEach(ele=>{
        ele.removeClass("calcOutput")
        ele.data('ppath',null)
    })
    this.lastCalcOutputStyleNodes.length=0

}

topologyDOM.prototype.selectFunction = function () {
    var arr = this.core.$(":selected")

    var re = []

    if(arr.length==1){
        var ele=arr[0]
        if(ele.data().modelID=="_fixed_simulationDataSource"){
            this.broadcastMessage({ "message": "showInfoSelectedNodes", info: [ele.data().originalInfo] })
            return;
        }
    }

    arr.forEach((ele) => { 
        //console.log(ele.renderedPosition())
        //remove those special elements
        if(ele.data().notTwin) {
            ele.unselect()
            return;
        }
        re.push(ele.data().originalInfo) 
    })
    this.broadcastMessage({ "message": "showInfoSelectedNodes", info: re })
    //for debugging purpose
    //arr.forEach((ele)=>{
    //  console.log("")
    //})
}





topologyDOM.prototype.applyVisualDefinition=function(){
    var visualJson=globalCache.visualDefinition["default"].detail
    if(visualJson==null) return;
    for(var modelID in visualJson){
        if(visualJson[modelID].color ||visualJson[modelID].secondColor  ) this.styleManager.updateModelTwinColor(modelID,visualJson[modelID].color,visualJson[modelID].secondColor)
        if(visualJson[modelID].shape) this.styleManager.updateModelTwinShape(modelID,visualJson[modelID].shape)
        if(visualJson[modelID].avarta) this.styleManager.updateModelAvarta(modelID,visualJson[modelID].avarta)
        if(visualJson[modelID].dimensionRatio) this.styleManager.updateModelTwinDimension(modelID,visualJson[modelID].dimensionRatio)
        if(visualJson[modelID].labelX || visualJson[modelID].labelY){
            this.styleManager.updateModelTwinLabelOffset(modelID)
        } 
        if(visualJson[modelID].rels){
            for(var relationshipName in visualJson[modelID].rels){
                if(visualJson[modelID]["rels"][relationshipName].color){
                    this.styleManager.updateRelationshipColor(modelID,relationshipName,visualJson[modelID]["rels"][relationshipName].color)
                }
                if(visualJson[modelID]["rels"][relationshipName].shape){
                    this.styleManager.updateRelationshipShape(modelID,relationshipName,visualJson[modelID]["rels"][relationshipName].shape)
                }
                if(visualJson[modelID]["rels"][relationshipName].edgeWidth){
                    this.styleManager.updateRelationshipWidth(modelID,relationshipName,visualJson[modelID]["rels"][relationshipName].edgeWidth)
                }
            }
        }
    }
}

topologyDOM.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="startSelection_replace"){
        this.core.nodes().remove()
    }else if(msgPayload.message=="replaceAllTwins") {
        this.core.nodes().remove()
        var eles= this.visualManager.drawTwins(msgPayload.info)
        this.visualManager.applyCurrentLayoutWithNoAnimtaion()
    }else if(msgPayload.message=="projectIsChanged") {
        this.applyVisualDefinition()
    }else if(msgPayload.message=="appendAllTwins") {
        var eles= this.visualManager.drawTwins(msgPayload.info,"animate")
        this.visualManager.reviewStoredRelationshipsToDraw()
        this.visualManager.applyCurrentLayoutWithNoAnimtaion()
    }else if(msgPayload.message=="drawAllRelations"){
        var edges= this.visualManager.drawRelations(msgPayload.info)
        if(edges!=null) {
            var layoutDetail=null
            if(globalCache.currentLayoutName!=null) layoutDetail = globalCache.layoutJSON[globalCache.currentLayoutName].detail
            if(layoutDetail==null)  this.visualManager.noPosition_cose()
            else this.visualManager.applyCurrentLayoutWithNoAnimtaion()
        }
    }else if(msgPayload.message=="addNewTwin") {
        this.core.nodes().unselect()
        this.core.edges().unselect()
        this.visualManager.drawTwins([msgPayload.twinInfo],"animation")
        var nodeInfo= msgPayload.twinInfo;
        var nodeName= globalCache.twinIDMapToDisplayName[nodeInfo["$dtId"]]
        var topoNode= this.core.nodes(`[id="${nodeName}"]`)
        if(topoNode){
            var w=this.core.width()
            var h= this.core.height()

            var targetNodeRenderPosX= w/11
            var targetNodeRenderPosY=h/2+((Math.random()-0.5)*h/4)
            topoNode.renderedPosition({x:targetNodeRenderPosX,y:targetNodeRenderPosY})
            topoNode.select()
            this.selectFunction()
        }
    }else if(msgPayload.message=="addNewTwins") {
        this.visualManager.drawTwins(msgPayload.twinsInfo,"animation")
    }else if(msgPayload.message=="showInfoSelectedNodes"){ //from selecting twins in the twintree
        this.core.nodes().unselect()
        this.core.edges().unselect()
        var arr=msgPayload.info;
        var mouseClickDetail=msgPayload.mouseClickDetail;
        arr.forEach(element => {
            var aTwin=this.core.nodes(`[id="${element['displayName']}"]`)
            aTwin.select()
            if(mouseClickDetail!=2) this.visualManager.animateANode(aTwin) //ignore double click second click
        });
    }else if(msgPayload.message=="PanToNode"){
        var nodeInfo= msgPayload.info;
        var nodeName= globalCache.twinIDMapToDisplayName[nodeInfo["$dtId"]]
        var topoNode= this.core.nodes(`[id="${nodeName}"]`)
        if(topoNode){
            this.core.center(topoNode)
        }
    }else if(msgPayload.message=="visualDefinitionChange"){
        if(msgPayload.srcModelID){
            if(msgPayload.color) this.styleManager.updateRelationshipColor(msgPayload.srcModelID,msgPayload.relationshipName,msgPayload.color)
            else if(msgPayload.shape) this.styleManager.updateRelationshipShape(msgPayload.srcModelID,msgPayload.relationshipName,msgPayload.shape)
            else if(msgPayload.edgeWidth) this.styleManager.updateRelationshipWidth(msgPayload.srcModelID,msgPayload.relationshipName,msgPayload.edgeWidth)
        } 
        else{
            if(msgPayload.color) this.styleManager.updateModelTwinColor(msgPayload.modelID,msgPayload.color,msgPayload.secondColor)
            else if(msgPayload.shape) {
                this.styleManager.updateModelTwinShape(msgPayload.modelID,msgPayload.shape)
                this.styleManager.adjustModelsBaseDimension(msgPayload.modelID)
            }else if(msgPayload.avarta){
                this.styleManager.adjustModelsBaseDimension(msgPayload.modelID)
                this.styleManager.updateModelAvarta(msgPayload.modelID,msgPayload.avarta)
            } 
            else if(msgPayload.noAvarta)  {
                this.styleManager.adjustModelsBaseDimension(msgPayload.modelID)
                this.styleManager.updateModelAvarta(msgPayload.modelID,null)
            }else if(msgPayload.dimensionRatio)  this.styleManager.updateModelTwinDimension(msgPayload.modelID,msgPayload.dimensionRatio)
            else if(msgPayload.labelPosition) this.styleManager.updateModelTwinLabelOffset(msgPayload.modelID)
        } 
    }else if(msgPayload.message=="relationsDeleted") this.visualManager.hideRelations(msgPayload.relations)
    else if(msgPayload.message=="saveLayout"){ this.saveLayout(msgPayload.layoutName)   }
    else if (msgPayload.message == "layoutChange") {
        this.visualManager.chooseLayout(globalCache.currentLayoutName)
    }else if(msgPayload.message=="alignSelectedNode") this.visualManager.alignSelectedNodes(msgPayload.direction)
    else if(msgPayload.message=="distributeSelectedNode") this.visualManager.distributeSelectedNode(msgPayload.direction)
    else if(msgPayload.message=="rotateSelectedNode") this.visualManager.rotateSelectedNode(msgPayload.direction)
    else if(msgPayload.message=="mirrorSelectedNode") this.visualManager.mirrorSelectedNode(msgPayload.direction)
    else if(msgPayload.message=="dimensionSelectedNode") this.visualManager.dimensionSelectedNode(msgPayload.direction)
    else if(msgPayload.message=="viewTypeChange"){
        if(msgPayload.viewType=="Topology") this.showSelf()
        else this.hideSelf()
    }
}


topologyDOM.prototype.showSelf = function () {
    this.DOM.show()
    this.DOM.animate({height: "100%"});
}

topologyDOM.prototype.hideSelf = function () {
    this.DOM.animate({height: "0%"},()=>{this.DOM.hide()});
}

topologyDOM.prototype.coseSelected=function(){
    this.visualManager.noPosition_cose(this.core.$(':selected'))
}



topologyDOM.prototype.saveLayout = async function (layoutName) {
    if(!globalCache.layoutJSON[layoutName]){
        var layoutDict={}
        globalCache.recordSingleLayout(layoutDict,globalCache.accountInfo.id,layoutName,false)
    }else layoutDict=globalCache.layoutJSON[layoutName].detail
    
    if(layoutDict["edges"]==null) layoutDict["edges"]={}
    
    var showingLayout=this.visualManager.getCurrentLayoutDetail()
    var showingEdgesLayout= showingLayout["edges"]
    delete showingLayout["edges"]
    for(var ind in showingLayout) layoutDict[ind]=showingLayout[ind]
    for(var ind in showingEdgesLayout) layoutDict["edges"][ind]=showingEdgesLayout[ind]

    var saveLayoutObj={"layouts":{}}
    saveLayoutObj["layouts"][layoutName]=JSON.stringify(layoutDict)  
    try{
        await msalHelper.callAPI("digitaltwin/saveLayout", "POST", saveLayoutObj,"withProjectID")
        this.broadcastMessage({ "message": "layoutsUpdated","layoutName":layoutName})
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }
}



topologyDOM.prototype.selectInboundNodes = function (selectedNodes) {
    var eles=this.core.nodes().edgesTo(selectedNodes).sources()
    eles.forEach((ele)=>{ this.visualManager.animateANode(ele) })
    eles.select()
    this.selectFunction()
}

topologyDOM.prototype.selectOutboundNodes = function (selectedNodes) {
    var eles=selectedNodes.edgesTo(this.core.nodes()).targets()
    eles.forEach((ele)=>{ this.visualManager.animateANode(ele) })
    eles.select()
    this.selectFunction()
}

topologyDOM.prototype.addConnections = function (targetNode,srcNodeArr) {
    var theConnectMode=this.targetNodeMode
    var preparationInfo=[]

    srcNodeArr.forEach(theNode=>{
        var connectionTypes
        if(theConnectMode=="connectTo") {
            connectionTypes=this.checkAvailableConnectionType(theNode.data("modelID"),targetNode.data("modelID"))
            preparationInfo.push({from:theNode,to:targetNode,connect:connectionTypes})
        }else if(theConnectMode=="connectFrom") {
            connectionTypes=this.checkAvailableConnectionType(targetNode.data("modelID"),theNode.data("modelID"))
            preparationInfo.push({to:theNode,from:targetNode,connect:connectionTypes})
        }
    })
    //TODO: check if it is needed to popup dialog, if all connection is doable and only one type to use, no need to show dialog
    this.showConnectionDialog(preparationInfo)
}

topologyDOM.prototype.showConnectionDialog = function (preparationInfo) {
    var confirmDialogDiv = new simpleConfirmDialog()
    var resultActions=[]
    confirmDialogDiv.show(
        { width: "450px" },
        {
            title: "Add connections"
            , content: ""
            , buttons: [
                {
                    colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": () => {
                        confirmDialogDiv.close();
                        this.createConnections(resultActions)
                    }
                },
                {
                    colorClass: "w3-gray", text: "Cancel", "clickFunc": () => {
                        confirmDialogDiv.close()
                    }
                }
            ]
        }
    )
    confirmDialogDiv.dialogDiv.empty()
    preparationInfo.forEach((oneRow,index)=>{
        resultActions.push(this.createOneConnectionAdjustRow(oneRow,confirmDialogDiv))
    })
}

topologyDOM.prototype.createOneConnectionAdjustRow = function (oneRow,confirmDialogDiv) {
    var returnObj={}
    var fromNode=oneRow.from
    var toNode=oneRow.to
    var connectionTypes=oneRow.connect
    var label=$('<label style="display:block;margin-bottom:2px"></label>')
    if(connectionTypes.length==0){
        label.css("color","red")
        label.html("No usable connection type from <b>"+fromNode.id()+"</b> to <b>"+toNode.id()+"</b>")
    }else if(connectionTypes.length>1){ 
        label.html("From <b>"+fromNode.id()+"</b> to <b>"+toNode.id()+"</b>") 
        var switchTypeSelector=new simpleSelectMenu(" ")
        label.prepend(switchTypeSelector.DOM)
        connectionTypes.forEach(oneType=>{
            switchTypeSelector.addOption(oneType)
        })
        returnObj["from"]=fromNode.data().originalInfo["$dtId"]
        returnObj["to"]=toNode.data().originalInfo["$dtId"]
        returnObj["connect"]=connectionTypes[0]
        switchTypeSelector.callBack_clickOption=(optionText,optionValue)=>{
            returnObj["connect"]=optionText
            switchTypeSelector.changeName(optionText)
        }
        switchTypeSelector.triggerOptionIndex(0)
    }else if(connectionTypes.length==1){
        returnObj["from"]=fromNode.data().originalInfo["$dtId"]
        returnObj["to"]=toNode.data().originalInfo["$dtId"]
        returnObj["connect"]=connectionTypes[0]
        label.css("color","green")
        label.html("Add <b>"+connectionTypes[0]+"</b> connection from <b>"+fromNode.id()+"</b> to <b>"+toNode.id()+"</b>") 
    }
    confirmDialogDiv.dialogDiv.append(label)
    return returnObj;
}

topologyDOM.prototype.createConnections = async function (resultActions) {
    var finalActions=[]
    resultActions.forEach(oneAction=>{
        var oneFinalAction={}
        oneFinalAction["$srcId"]=oneAction["from"]
        oneFinalAction["$relationshipId"]=globalCache.uuidv4();
        oneFinalAction["obj"]={
            "$targetId": oneAction["to"],
            "$relationshipName": oneAction["connect"]
        }
        finalActions.push(oneFinalAction)
    })
    try{
        var data = await msalHelper.callAPI("digitaltwin/createRelations", "POST",  {actions:JSON.stringify(finalActions)})
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }
    globalCache.storeTwinRelationships_append(data)
    this.visualManager.drawRelations(data)
}



topologyDOM.prototype.checkAvailableConnectionType = function (fromNodeModel,toNodeModel) {
    var re=[]
    var validRelationships=modelAnalyzer.DTDLModels[fromNodeModel].validRelationships
    var toNodeBaseClasses=modelAnalyzer.DTDLModels[toNodeModel].allBaseClasses
    if(validRelationships){
        for(var relationName in validRelationships){
            var theRelationType=validRelationships[relationName]
            if(theRelationType.target==null
                 || theRelationType.target==toNodeModel
                 ||toNodeBaseClasses[theRelationType.target]!=null) re.push(relationName)
        }
    }
    return re
}


topologyDOM.prototype.setKeyDownFunc=function(includeCancelConnectOperation){
    $(document).on("keydown",  (e)=>{
        if (e.ctrlKey && e.target.nodeName === 'BODY'){
            if (e.which === 90)   this.visualManager.ur.undo();
            else if (e.which === 89)    this.visualManager.ur.redo();
            else if(e.which===83){
                this.broadcastMessage({"message":"popupLayoutEditing"})
                return false
            }
        }
        if(includeCancelConnectOperation){
            if (e.keyCode == 27) this.cancelTargetNodeMode()    
        }
    });
}

topologyDOM.prototype.startTargetNodeMode = function (mode,selectedNodes) {
    this.core.autounselectify( true );
    this.core.container().style.cursor = 'crosshair';
    this.targetNodeMode=mode;
    this.setKeyDownFunc("includeCancelConnectOperation")

    this.core.nodes().on('click', (e)=>{
        var clickedNode = e.target;
        this.addConnections(clickedNode,selectedNodes)
        //delay a short while so node selection will not be changed to the clicked target node
        setTimeout(()=>{this.cancelTargetNodeMode()},50)

    });
}

topologyDOM.prototype.cancelTargetNodeMode=function(){
    this.targetNodeMode=null;
    this.core.container().style.cursor = 'default';
    $(document).off('keydown');
    this.setKeyDownFunc()
    this.core.nodes().off("click")
    this.core.autounselectify( false );
}


module.exports = topologyDOM;
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/modelAnalyzer":22,"../sharedSourceFiles/simpleConfirmDialog":31,"../sharedSourceFiles/simpleSelectMenu":33,"./topologyDOM_menu":12,"./topologyDOM_simDataSource":13,"./topologyDOM_styleManager":14,"./topologyDOM_visual":15}],12:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache")
const newTwinDialog=require("../sharedSourceFiles/newTwinDialog");
const simpleConfirmDialog=require("../sharedSourceFiles/simpleConfirmDialog")
const simpleSelectMenu=require("../sharedSourceFiles/simpleSelectMenu")
const msalHelper=require("../msalHelper")

function topologyDOM_menu(parentTopologyDOM){
    this.parentTopologyDOM=parentTopologyDOM
    this.core=parentTopologyDOM.core
    this.contenxtMenuInstance = this.core.contextMenus('get')
    this.addMenuItemsForEditing()
    this.addMenuItemsForOthers()
    this.addMenuItemsForLiveData()
}

topologyDOM_menu.prototype.decideVisibleContextMenu=function(clickEle){
    //hide all menu items
    var allItems=['ConnectTo','ConnectFrom','QueryOutbound','QueryInbound','SelectOutbound','SelectInbound','enableLiveDataStream','COSE','addSimulatingDataSource','liveData','Hide','Others','Simulation', 'startSimulatingDataSource', 'stopSimulatingDataSource', 'editing','DeleteAll']
    allItems.forEach(ele=>{this.contenxtMenuInstance.hideMenuItem(ele)})
    
    var selectedNodes=this.core.$('node:selected')
    var selected=this.core.$(':selected')
    var isClickingNode=(clickEle.isNode && clickEle.isNode() )
    var hasNode=isClickingNode || (selectedNodes.length>0)
    if(clickEle.isNode && clickEle.data("originalInfo") && clickEle.data("originalInfo").simNodeName) var clickSimNode=true
    
    var showMenuArr=(arr)=>{
        arr.forEach(ele=>{this.contenxtMenuInstance.showMenuItem(ele)})
    }

    if(clickSimNode) {
        var simNodeName=clickEle.data('originalInfo').simNodeName
        showMenuArr(['editing','DeleteAll','Simulation'])
        if(this.parentTopologyDOM.simDataSourceManager.runningSimDataSource[simNodeName]){
            showMenuArr(['stopSimulatingDataSource'])
        }else showMenuArr(['startSimulatingDataSource'])
    }else{
        if(hasNode){
            showMenuArr(['editing','ConnectTo','ConnectFrom','Others','QueryOutbound','QueryInbound','SelectOutbound','SelectInbound','Hide','DeleteAll'])
            if(isClickingNode) showMenuArr(['liveData','enableLiveDataStream','addSimulatingDataSource'])
            if(selected.length>1) showMenuArr(['COSE'])
        }
        if(!hasNode && !clickEle.data().notTwin) showMenuArr(['editing','DeleteAll'])
    }
}

topologyDOM_menu.prototype.addMenuItemsForLiveData = function () {
    this.contenxtMenuInstance.appendMenuItems([
        {
            id: 'liveData',
            content: 'Live Data',
            selector: 'node',
            disabled:true,
            onClickFunction: ()=>{}//empty func, it is only a menu title item
        },
        {
            id: 'Simulation',
            content: 'Simulation',
            selector: 'node[modelID = "_fixed_simulationDataSource"]',
            disabled:true,
            onClickFunction: ()=>{}//empty func, it is only a menu title item
        },
        {
            id: 'startSimulatingDataSource',
            content: 'Start',
            selector: 'node[modelID = "_fixed_simulationDataSource"]',
            onClickFunction: (e) => {
                this.selectClickedEle(e.target)
                var target = e.target || e.cyTarget;
                this.parentTopologyDOM.simDataSourceManager.startSimNode(e.target)
            }
        },
        {
            id: 'stopSimulatingDataSource',
            content: 'Stop',
            selector: 'node[modelID = "_fixed_simulationDataSource"]',
            onClickFunction: (e) => {
                this.selectClickedEle(e.target)
                var target = e.target || e.cyTarget;
                this.parentTopologyDOM.simDataSourceManager.stopSimNode(e.target)
            }
        },
        {
            id: 'addSimulatingDataSource',
            content: 'Add Simulator Source',
            selector: 'node',
            onClickFunction: (e) => {
                this.selectClickedEle(e.target)
                var target = e.target || e.cyTarget;
                this.parentTopologyDOM.addSimulatorSource(target.id())
            }
        },
        {
            id: 'enableLiveDataStream',
            content: 'Monitor Live Data',
            selector: 'node', 
            onClickFunction: (e) => {
                this.selectClickedEle(e.target)
                var target = e.target || e.cyTarget;
                this.parentTopologyDOM.enableLiveDataStream(target.id())
            }
        }
    ])
}

topologyDOM_menu.prototype.addMenuItemsForEditing = function () {
    this.contenxtMenuInstance.appendMenuItems([
        {
            id: 'editing',
            content: 'Edit',
            selector: 'node,edge',
            disabled:true,
            onClickFunction: ()=>{}//empty func, it is only a menu title item
        },
        {
            id: 'ConnectTo',
            content: 'Connect To',
            selector: 'node,edge',
            onClickFunction: (e) => {
                this.parentTopologyDOM.startTargetNodeMode("connectTo",this.node_changeSelectionWhenClickElement(e.target))
            }
        },
        {
            id: 'ConnectFrom',
            content: 'Connect From',
            selector: 'node,edge',
            onClickFunction: (e) => {
                this.parentTopologyDOM.startTargetNodeMode("connectFrom",this.node_changeSelectionWhenClickElement(e.target))
            }
        },
        {
            id: 'DeleteAll',
            content: 'Delete',
            selector: 'node,edge',
            onClickFunction: (e) => {
                var collection=this.nodeoredge_changeSelectionWhenClickElement(e.target)
                collection.unselect()
                this.parentTopologyDOM.selectFunction()
                if(collection.length==1){
                    var ele=collection[0]
                    if(ele.data && ele.data("originalInfo").simNodeName){
                        this.parentTopologyDOM.deleteSimNode(ele)
                        return
                    }
                }
                this.parentTopologyDOM.deleteElementsArray(collection)
            }
        }
    ])
}

topologyDOM_menu.prototype.addMenuItemsForOthers = function () {
    this.contenxtMenuInstance.appendMenuItems([
        {
            id: 'Others',
            content: 'Others', 
            selector: 'node,edge',
            disabled:true,
            onClickFunction: ()=>{} //empty func, it is only a menu title item
        },
        {
            id: 'QueryOutbound',
            content: 'Load Outbound',
            selector: 'node,edge',
            onClickFunction: (e) => {
                this.parentTopologyDOM.loadOutBound(this.node_changeSelectionWhenClickElement(e.target))
            }
        },
        {
            id: 'QueryInbound',
            content: 'Load Inbound', 
            selector: 'node,edge',
            onClickFunction: (e) => {
                this.parentTopologyDOM.loadInBound(this.node_changeSelectionWhenClickElement(e.target))
            }
        },{
            id: 'SelectOutbound',
            content: '+Select Outbound',
            selector: 'node,edge',
            onClickFunction: (e) => {
                this.parentTopologyDOM.selectOutboundNodes(this.node_changeSelectionWhenClickElement(e.target))
            }
        },
        {
            id: 'SelectInbound',
            content: '+Select Inbound',
            selector: 'node,edge',
            onClickFunction: (e) => {
                this.parentTopologyDOM.selectInboundNodes(this.node_changeSelectionWhenClickElement(e.target))
            }
        },
        {
            id: 'COSE',
            content: 'COSE Layout',
            selector: 'node,edge',
            onClickFunction: (e) => {
                this.parentTopologyDOM.coseSelected()
            }
        },
        {
            id: 'duplicate',
            content: 'Duplicate',
            selector: 'node',
            onClickFunction: (e) => {
                var collection=this.selectClickedEle(e.target)
                var oInfo=JSON.parse(JSON.stringify(e.target.data("originalInfo")))
                delete oInfo["$metadata"];delete oInfo["$dtId"];delete oInfo["$etag"];delete oInfo["displayName"]
                oInfo["$metadata"]={"$model": e.target.data("modelID")}
                newTwinDialog.popup(oInfo,(twinInfo)=>{
                    var twinName=twinInfo.displayName
                    //copy this node's scale and rotate to the new node
                    this.parentTopologyDOM.visualManager.applyNodeScaleRotate(twinName,e.target.data("scaleFactor"),e.target.data("rotateAngle"))
                })
            }
        },
        {
            id: 'Hide',
            content: 'Hide',
            selector: 'node,edge',
            onClickFunction: (e) => {
                var collection=this.node_changeSelectionWhenClickElement(e.target)
                this.parentTopologyDOM.hideCollection(collection)
            }
        },
        {
            id: 'addGroupTag',
            content: 'Add Group Tag',
            selector: 'node',
            onClickFunction: (e) => {
                var collection=this.node_changeSelectionWhenClickElement(e.target).filter('node')
                var nodesID=[]
                collection.forEach(ele=>{
                    nodesID.push(ele.data("originalInfo")["$dtId"])
                })
                this.setGroupTag(nodesID)
            }
        },
        {
            id: 'copyScaleRotate',
            content: 'Copy Style',
            selector: 'node.edgebendediting_scaleRotate',
            onClickFunction: (e) => {
                var collection=this.node_changeSelectionWhenClickElement(e.target)
                var n=collection[0]
                globalCache.clipboardNodeStyle={"scaleFactor":n.data("scaleFactor")||1,"rotateAngle":n.data("rotateAngle")||0}
            }
        },
        {
            id: 'pasteScaleRotate',
            content: 'Paste Style',
            selector: 'node',
            onClickFunction: (e) => {
                var collection=this.node_changeSelectionWhenClickElement(e.target)
                var n=collection[0]
                if(globalCache.clipboardNodeStyle){
                    this.parentTopologyDOM.visualManager.applyNodeScaleRotate(n.id(),globalCache.clipboardNodeStyle.scaleFactor,globalCache.clipboardNodeStyle.rotateAngle)
                }
                
            }
        }
    ])
}

topologyDOM_menu.prototype.getAllTags = function(){
    var tags={}
    for(var twinID in globalCache.DBTwins){
        var aDBTwin=globalCache.DBTwins[twinID]
        var tag=aDBTwin.groupTag
        if(tag!=null) tags[tag]=1
    }
    return tags
}

topologyDOM_menu.prototype.setGroupTag=function(nodesIDArr){
    var dialog=new simpleConfirmDialog()
    var sendTagReqest=(tagStr)=>{
        msalHelper.callAPI("digitaltwin/setTwinsGroupTag", "POST", {"twinsIDArr":nodesIDArr,"groupTag":tagStr},"withProjectID")
        dialog.close() 
    }
    dialog.show({"width":"320px"},{
        "title":"Assign Group Tag",
        "customDrawing":(parentDOM)=>{
            var currentTags=new simpleSelectMenu("Use a existing group tag or fill a new one below")
            parentDOM.append(currentTags.DOM)
            var tags=this.getAllTags()
            for(var atag in tags) currentTags.addOption(atag)
            dialog.tagInput=$('<input type="text" style="margin:8px 0;padding:2px;width:290px;outline:none;display:inline" placeholder="Tag"/>').addClass("w3-input w3-border");
            parentDOM.append(dialog.tagInput)
            dialog.tagInput.on('keyup', function (e) {
                if (e.key === 'Enter' || e.keyCode === 13) {
                    sendTagReqest(dialog.tagInput.val())
                }
            });
            currentTags.callBack_clickOption=(optionText,optionValue)=>{
                dialog.tagInput.val(optionText)
            }
        },
        "buttons":[
            {
                "text": "OK",
                "colorClass":"w3-lime",
                "clickFunc": () => {
                    sendTagReqest(dialog.tagInput.val())
                }
            },
            {"text":"Cancel","colorClass":"w3-light-gray","clickFunc":()=>{dialog.close()}}
        ]
    })
}

topologyDOM_menu.prototype.selectElement=function(element){
    element.select()
    this.parentTopologyDOM.selectFunction()
}

topologyDOM_menu.prototype.selectIfClickEleIsNotSelected=function(clickEle){
    if(!clickEle.selected()){
        this.core.$(':selected').unselect()
        this.selectElement(clickEle)
    }
}

topologyDOM_menu.prototype.selectClickedEle=function(clickEle){
    this.core.$(':selected').unselect()
    this.selectElement(clickEle)
}

topologyDOM_menu.prototype.node_changeSelectionWhenClickElement=function(clickEle){
    if(clickEle.isNode && clickEle.isNode()){
        this.selectIfClickEleIsNotSelected(clickEle)
    }
    var arr=this.core.$(':selected')
    return arr
}
topologyDOM_menu.prototype.nodeoredge_changeSelectionWhenClickElement=function(clickEle){
    if(clickEle.isNode){ //at least having isnode function means it is node or edge
        this.selectIfClickEleIsNotSelected(clickEle)
    }
    var arr=this.core.$(':selected')
    return arr
}



module.exports = topologyDOM_menu;
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/newTwinDialog":26,"../sharedSourceFiles/simpleConfirmDialog":31,"../sharedSourceFiles/simpleSelectMenu":33}],13:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache")
const msalHelper=require("../msalHelper")

function topologyDOM_simDataSource(parentTopologyDOM){
    this.parentTopologyDOM=parentTopologyDOM
    this.core=this.parentTopologyDOM.core
    this.runningSimDataSource={}

}

topologyDOM_simDataSource.prototype.startSimNode=async function(ele){
    var simNodeInfo=ele.data("originalInfo")
    this.refreshRealSimNodeInfoFromDBTwin(simNodeInfo)
    
    //check if anyone else is using the simulation datasource
    if(simNodeInfo.detail.propertyPath=="" || simNodeInfo.detail.propertyPath==null ){
        alert("There is no definition of simulating property")
        return;
    }

    var _T = parseFloat(simNodeInfo.detail["cycleLength"])
    var sampling = parseFloat(simNodeInfo.detail["sampleInterval"])
    var formula = simNodeInfo.detail["formula"]
    if(_T==0 || sampling==0 || formula=="" || _T==null || sampling==null || formula==null || _T<0 || sampling<0){
        alert("Incorrect simulation setting")
        return;
    }

    var _t=0;
    var dataArr=[]
    var _output=null;
    while(_t<_T){
        var evalStr=formula+"\n_output"
        try{
            _output=eval(evalStr) // jshint ignore:line
        }catch(e){}
        dataArr.push(_output)
        _t+=sampling
    }
    if(dataArr.length==0){
        alert("There is no output from the simulation formula.")
        return;
    }

    var payload={
        "propertyPathStr": simNodeInfo.detail.propertyPath.join("."), 
        "twinID":simNodeInfo.twinID
    }
    try {
        
        var checkResult = await msalHelper.callAPI("digitaltwin/checkSimulationDataSource", "POST", payload)
        if(checkResult.account){
            alert("Can not start simulation as "+checkResult.account+" is simulating this node. Please try again later...")
        }else{
            var dblockTimer=setInterval(()=>{
                msalHelper.callAPI("digitaltwin/updateSimulationDataSource", "POST", payload)
            },40000) //every 40 second, update the record in simulation container again, it serves as a lock so other ppl will not start the simulation repeatly
            var numberIndex=0;
            var simTimer=setInterval(()=>{
                if(numberIndex>=dataArr.length) numberIndex=0
                this.editDTProperty(globalCache.storedTwins[simNodeInfo.twinID],simNodeInfo.detail.propertyPath,dataArr[numberIndex])
                numberIndex++
            },parseInt(sampling*1000))

            this.runningSimDataSource[simNodeInfo.simNodeName]={
                "dblockTimer":dblockTimer,
                "simTimer":simTimer
            }
            ele.addClass("running")
        }
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
    }
}

topologyDOM_simDataSource.prototype.editDTProperty=function(dtTwinInfo, path, newVal) {
    //{ "op": "add", "path": "/x", "value": 30 }
    var str = ""
    path.forEach(segment => { str += "/" + segment })
    var jsonPatch = [{ "op": "add", "path": str, "value": newVal }]

    var twinID = dtTwinInfo["$dtId"]
    var payLoad = { "jsonPatch": JSON.stringify(jsonPatch), "twinID": twinID }

    //console.log(payLoad)
    msalHelper.callAPI("digitaltwin/changeAttribute", "POST", payLoad)
}

topologyDOM_simDataSource.prototype.updateOriginObjectValue=function(nodeInfo, pathArr, newVal) {
    if (pathArr.length == 0) return;
    var theJson = nodeInfo
    for (var i = 0; i < pathArr.length; i++) {
        var key = pathArr[i]

        if (i == pathArr.length - 1) {
            theJson[key] = newVal
            break
        }
        if (theJson[key] == null) theJson[key] = {}
        theJson = theJson[key]
    }
}



topologyDOM_simDataSource.prototype.stopSimNode=function(ele){
    var simNodeInfo=ele.data("originalInfo")
    this.refreshRealSimNodeInfoFromDBTwin(simNodeInfo)
    if(!this.runningSimDataSource[simNodeInfo.simNodeName]) return;
    var simTimer=this.runningSimDataSource[simNodeInfo.simNodeName].simTimer
    if(simTimer) clearInterval(simTimer)
    var dblockTimer=this.runningSimDataSource[simNodeInfo.simNodeName].dblockTimer
    if(dblockTimer) clearInterval(dblockTimer)

    var payload={
        "propertyPathStr": simNodeInfo.detail.propertyPath.join("."), 
        "twinID":simNodeInfo.twinID
    }
    msalHelper.callAPI("digitaltwin/deleteSimulationDataSourceLock", "POST", payload)

    delete this.runningSimDataSource[simNodeInfo.simNodeName]
    ele.removeClass("running")
}

topologyDOM_simDataSource.prototype.refreshRealSimNodeInfoFromDBTwin = function (simNodeInfo) {
    var attachTwinID = simNodeInfo["twinID"]
    var dbtwin = globalCache.DBTwins[attachTwinID]
    var simNodeName = simNodeInfo["simNodeName"]
    simNodeInfo.detail = dbtwin.simulate[simNodeName]
}

topologyDOM_simDataSource.prototype.newSimulatorSource = function (twinName) {
    //add a simulator data source node beside the clicked twin
    var simNodeName= globalCache.uuidv4()
    var twinID=globalCache.twinDisplayNameMapToID[twinName]
    var newSim={
        "propertyPath":null
    }
    this.parentTopologyDOM.visualManager.showSimulatorSource(twinID,simNodeName,newSim)

    //write the simulate node infomation to database
    try {
        var dbtwin=globalCache.DBTwins[twinID]
        var allSims= dbtwin.simulate||{}
        allSims[simNodeName]=newSim
        dbtwin.simulate=allSims
        msalHelper.callAPI("digitaltwin/updateTwin", "POST"
            , {"twinID":twinID,"updateInfo":JSON.stringify({"simulate":allSims})}
            , "withProjectID")
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
    }
}

topologyDOM_simDataSource.prototype.deleteSimNode=function(ele){
    this.stopSimNode(ele)
    var simNodeInfo=ele.data("originalInfo")
    var twinID=simNodeInfo.twinID
    var simNodeName=simNodeInfo.simNodeName
    var dbTwin= globalCache.DBTwins[twinID]
    if(dbTwin && dbTwin.simulate){
        delete dbTwin.simulate[simNodeName]
        try {
            msalHelper.callAPI("digitaltwin/updateTwin", "POST"
                , {"twinID":twinID,"updateInfo":JSON.stringify({"simulate":dbTwin.simulate})}
                , "withProjectID")
            this.core.$('[id = "'+simNodeName+'"]').remove() 
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }
    }
}


module.exports = topologyDOM_simDataSource;
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21}],14:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache");

function topologyDOM_styleManager(topologyCore,defaultNodeSize){
    this.core=topologyCore;
    this.defaultNodeSize=defaultNodeSize||30
    this.baseNodeSize=this.defaultNodeSize;
    this.baseSquareShapeSize=this.defaultNodeSize;
    this.nodeModelVisualAdjustment={}
    this.defineHighPriorityStyles()
    this.initStyle()
}

topologyDOM_styleManager.prototype.initStyle=function(){
    var initStyleArr=[ // the stylesheet for the graph
        {
            selector: 'node',
            style: {
                "width":this.defaultNodeSize,"height":this.defaultNodeSize,
                'label': 'data(id)',
                'opacity':0.9,
                'font-size':"12px",
                'font-family':'Geneva, Arial, Helvetica, sans-serif'
                //,'background-image': function(ele){ return "images/cat.png"; }
                //,'background-fit':'contain' //cover
                //'background-color': function( ele ){ return ele.data('bg') }
                ,'background-width':'75%'
                ,'background-height':'75%'
            }
        },
        {
            selector: 'edge',
            style: {
                'width':2,
                'line-color': '#888',
                'target-arrow-color': '#555',
                'target-arrow-shape': 'triangle',
                'source-arrow-color': '#999',
                'source-arrow-shape': 'circle',
                'source-arrow-fill':'hollow',
                'curve-style': 'bezier',
                'arrow-scale':0.6
            }
        },
        {selector: 'node.hover',
        style: {
            'background-blacken':0.5
        }},
        {selector: 'edge.hover',
        style: {
            'width':10
        }},
        {selector: 'node[modelID = "_fixed_simulationDataSource"]',
        style: {
            'shape':'rectangle'
            ,'background-fill': 'solid'
            ,'background-color': 'white' 
            ,'background-image':this.dataSourceSVG()
            ,'border-opacity':1
            ,'text-opacity': 0
            ,'border-width':1
            ,'border-color':'darkGray'
        }},
        {selector: 'edge[sourceModel = "_fixed_simulationDataSource"]',
        style: {
            'width':2,
            'source-arrow-shape': 'circle',
            'target-arrow-shape': 'circle',
            'line-color':'gray',
            'line-style': 'dashed'
            ,'line-dash-pattern':[8,8]
        }}
    ]
    this.updateStyleSheet(initStyleArr)
}

topologyDOM_styleManager.prototype.defineHighPriorityStyles=function(){
    this.highestStyleArr= [
        {selector:'node.calcInput' , style: {
            'border-color': "red",
            'border-width': 1,
            'background-fill': 'linear-gradient',
            'background-gradient-stop-colors': ['red', 'red', 'white', "white", "red"],
            'background-gradient-stop-positions': ['0%', '50%', '51%', "90%", "91%"]
        }},
        {selector:'node.calcOutput' , style: {
            'border-color': "blue",
            'border-width': 1,
            'background-fill': 'linear-gradient',
            'background-gradient-stop-colors': ['blue', 'blue', 'white', "white", "blue"],
            'background-gradient-stop-positions': ['0%', '50%', '51%', "90%", "91%"]
        }},
        {selector:'edge.calcInput' , style:{
            'width': '5',
            'line-color': 'red',
            'target-label': 'data(ppath)',
            'font-size': '11px',
            'target-text-offset': 'data(ppathOffset)',
            'text-background-color': 'white',
            'text-background-opacity': 1,
            'text-border-opacity': 1,
            'text-border-width': 1,
            'text-background-padding': '2px',
            'color': 'gray',
            'text-border-color': 'gray'
        } },
        {selector:'edge.calcOutput' , style: {
            'width': '5',
            'line-color': 'blue',
            'source-label': 'data(ppath)',
            'font-size': '11px',
            'source-text-offset': 'data(ppathOffset)',
            'text-background-color': 'white',
            'text-background-opacity': 1,
            'text-border-opacity': 1,
            'text-border-width': 1,
            'text-background-padding': '2px',
            'color': 'gray',
            'text-border-color': 'gray'
        }},
        {selector:'edge:selected' , style:{
            'width': 8,
            'line-color': 'red',
            'target-arrow-color': 'red',
            'source-arrow-color': 'red',
            'line-fill': "linear-gradient",
            'line-gradient-stop-colors': ['cyan', 'magenta', 'yellow'],
            'line-gradient-stop-positions': ['0%', '70%', '100%']
        } },
        {selector:'node:selected' , style: {
            'border-color': "red",
            'border-width': 2,
            'background-fill': 'radial-gradient',
            'background-gradient-stop-colors': ['cyan', 'magenta', 'yellow'],
            'background-gradient-stop-positions': ['0%', '50%', '60%']
        }},
        {selector: 'node[modelID = "_fixed_simulationDataSource"].running',
        style:{
            'border-width':3
            ,'border-color':'#cddc39'
        }}
    ]
    this.highestStyleSelectors={}
    this.highestStyleArr.forEach((oneStyle)=>{this.highestStyleSelectors[oneStyle.selector]=1})
}

topologyDOM_styleManager.prototype.updateModelTwinColor=function(modelID,colorCode,secondColorCode){
    var styleJson = this.core.style().json();
    var arr=[]
    for(var ind in styleJson){
        arr.push(styleJson[ind].selector)
    }

    var styleSelector='node[modelID = "' + modelID + '"]'
    var styleObj=null
    if (secondColorCode == null) {
        if(colorCode=="none"){
            styleObj={ 'background-fill': 'solid','background-color': 'darkGray','background-opacity':0 }
        }else{
            styleObj={ 'background-fill': 'solid','background-color': colorCode ,'background-opacity':1}
        }
    } else {
        colorCode=colorCode||"darkGray"
        if(colorCode=="none") colorCode="darkGray"
        styleObj={
                'background-fill': 'linear-gradient',
                'background-gradient-stop-colors': [colorCode, colorCode, secondColorCode],
                'background-gradient-stop-positions': ['0%', '50%', '51%']
            }
    }
    if(styleObj) this.updateStyleSheet([{selector:styleSelector,style:styleObj}]) 
}

topologyDOM_styleManager.prototype.updateStyleSheet=function(styleArr){
    //reserve the two styles of edgeediting plugin first, right now there is no better way to reserve them
    var allStyle=this.core.style()
    var edgeBendStyle=null
    var edgeControlStyle=null
    for(var ind in allStyle){
        if(typeof(allStyle[ind])!="object") continue
        if(!allStyle[ind].selector) continue
        var str=allStyle[ind].selector.inputText
        if(str==".edgebendediting-hasbendpoints"){
            edgeBendStyle=allStyle[ind]
        }
        if(str==".edgecontrolediting-hascontrolpoints"){
            edgeControlStyle=allStyle[ind]
        }
    }

    //do style merging
    var mergeSelector={}
    styleArr.forEach(ele=>{
        mergeSelector[ele.selector]=ele.style
    })

    var styleJson = this.core.style().json();
    var arr=[]
    for(var ind in styleJson){
        if(mergeSelector[styleJson[ind].selector]) {
            var olds= styleJson[ind].style
            var news=mergeSelector[styleJson[ind].selector] 
            for(var ind in olds){
                if(news[ind]!=null) continue
                news[ind]=olds[ind]
            }
            if(news["background-image"] && news["background-image"]=="NONE") delete news["background-image"]
            continue
        }else if(styleJson[ind].selector==".edgebendediting-hasbendpoints" ||styleJson[ind].selector==".edgecontrolediting-hascontrolpoints" || styleJson[ind].selector=="node.edgebendediting_scaleRotate" ) continue
        else if(this.highestStyleSelectors[styleJson[ind].selector]) continue
        
        arr.push(styleJson[ind])
    }
    
    arr=arr.concat(styleArr)
    arr=arr.concat(this.highestStyleArr)
    this.core.style().fromJson(arr).update()
    if(edgeBendStyle){
        allStyle=this.core.style()
        var curLen=allStyle.length;
        allStyle.length=curLen+2
        allStyle[curLen]=edgeBendStyle
        allStyle[curLen+1]=edgeControlStyle
    }

    //node scale rotate style
    this.core.style()
        .selector('node.edgebendediting_scaleRotate')
        .style({
            'width':  (ele)=> {
                var scaleF=ele.data('scaleFactor')||1
                if(!ele.data("originalWidth")){
                    ele.data("originalWidth",ele.width())
                }
                var theW=ele.data("originalWidth")
                return parseFloat(theW)*scaleF
            },
            'height':  (ele)=> {
                var scaleF=ele.data('scaleFactor')||1
                if(!ele.data("originalHeight")){
                    ele.data("originalHeight",ele.height())
                }
                var theH=ele.data("originalHeight")
                return parseFloat(theH)*scaleF
            },'shape-rotation': ( ele )=>{
                return parseFloat(ele.data("rotateAngle")||0)
            },'text-margin-x':(ele)=>{
                var modelID=ele.data("modelID")
                var lblOffset=this.calculateLblOffset(modelID,ele.data('scaleFactor')||1)
                return lblOffset[0]
            },'text-margin-y':(ele)=>{
                var modelID=ele.data("modelID")
                var lblOffset=this.calculateLblOffset(modelID,ele.data('scaleFactor')||1)
                return lblOffset[1]
            }
        }).update()
}

topologyDOM_styleManager.prototype.adjustModelsBaseDimension=function(specifyModelID){
    var fs=this.getFontSizeInCurrentZoom();
    this.baseSquareShapeSize=this.getNodeSizeInCurrentZoom();

    if(!specifyModelID){
        var arr=[
            {selector:'node',style:{ 'font-size': fs, width: this.baseSquareShapeSize, height: this.baseSquareShapeSize }}, //normal node is a circle, width=height
            {selector:'node:selected',style:{ 'border-width': Math.ceil(this.baseSquareShapeSize / 15) }},
        ]
    }else{
        arr=[]
    }
    for (var modelID in this.nodeModelVisualAdjustment) {
        if(specifyModelID!=null && modelID!=specifyModelID) continue
        var sizeAdjustRatio=this.nodeModelVisualAdjustment[modelID].dimensionRatio||1
        //if its shape is round-rectangle (actually it is polygon rectangle) and it does have a svg or image avarta, then it is possible that this type of nodes have width different from height. It will follow the width-height-ratio of the image or svg
        var theShape=this.nodeModelVisualAdjustment[modelID].shape||"ellipse"
        if(theShape=="ellipse" ||theShape=="hexagon"){
            var baseSize=this.baseSquareShapeSize
        }else baseSize=this.baseNodeSize
        var newW=Math.ceil(sizeAdjustRatio * baseSize)
        var newH=newW
        var bgRatioW=75
        var bgRatioH=75
        var visualJson=globalCache.visualDefinition["default"].detail[modelID]
        var currentShape=this.nodeModelVisualAdjustment[modelID].shape
        if(currentShape=="rectangle" && visualJson.avarta){
            var visualJson=globalCache.visualDefinition["default"].detail[modelID]
            if(visualJson.avartaHeight && visualJson.avartaHeight!=0){
                var whRatio=visualJson.avartaWidth/visualJson.avartaHeight
                if(whRatio>1) newW=newH*whRatio
                else newH=newW/whRatio
                bgRatioW=bgRatioH='100'
            }
        }else if(visualJson.avarta && visualJson.avartaHeight && visualJson.avartaHeight!=0){
            var whRatio=visualJson.avartaWidth/visualJson.avartaHeight
            if(whRatio>1) bgRatioH=bgRatioW/whRatio
            else bgRatioW = bgRatioH * whRatio
        }
        //console.log(newW,newH,modelID)
        //for any node that already has edgebendediting_scaleRotate, also modify its originalWidth and originalHeight
        this.core.nodes(`[modelID = "${modelID}"]`).forEach(ele => {
            if (ele.data("originalWidth") != null) {
                ele.data("originalWidth", newW)
                ele.data("originalHeight", newH)
            }
        })
        
        var lblOffset=this.calculateLblOffset(modelID)
        arr.push({
            selector: 'node[modelID = "' + modelID + '"]', style: {
                width: newW, height: newH, 'background-width': bgRatioW + "%", 'background-height': bgRatioH + "%"
                ,"text-margin-x":lblOffset[0],'text-margin-y':lblOffset[1] 
            }
        })
    }
    this.updateStyleSheet(arr)
}

topologyDOM_styleManager.prototype.calculateLblOffset=function(modelID,scaleF){
    var visualJson=globalCache.visualDefinition["default"].detail[modelID]
    if(!visualJson) return [0,0]
    var xoff=visualJson.labelX||0
    var yoff=visualJson.labelY||0
    var dimensionRatio= visualJson.dimensionRatio||1 
    var theShape = visualJson.shape || "ellipse"
    if (theShape == "ellipse" || theShape == "hexagon") {
        var baseSize = this.baseSquareShapeSize
    } else baseSize = this.baseNodeSize
    var baseNodeAdjustR= baseSize/30
    var scaleF=scaleF||1
    return [xoff*dimensionRatio*baseNodeAdjustR*scaleF,yoff*dimensionRatio*baseNodeAdjustR*scaleF ] 
}

topologyDOM_styleManager.prototype.updateModelAvarta=function(modelID,dataUrl){
    if(!this.nodeModelVisualAdjustment[modelID])this.nodeModelVisualAdjustment[modelID]={}
    this.nodeModelVisualAdjustment[modelID].avarta=dataUrl

    try{
        if(dataUrl==null) dataUrl="NONE"
        this.updateStyleSheet([{selector:'node[modelID = "'+modelID+'"]',style:{'background-image': dataUrl}} ])
    }catch(e){
        
    }
}

topologyDOM_styleManager.prototype.updateModelTwinShape=function(modelID,shape){
    var newStyle
    if(!this.nodeModelVisualAdjustment[modelID])this.nodeModelVisualAdjustment[modelID]={}
    this.nodeModelVisualAdjustment[modelID].shape=shape
    if(shape=="hexagon"){
        var polygon=[0,-1,0.866,-0.5,0.866,0.5,0,1,-0.866,0.5,-0.866,-0.5]
        newStyle={selector:'node[modelID = "'+modelID+'"]',style:{'shape': 'polygon','shape-polygon-points':polygon}}
    }else if(shape=="rectangle"){
        newStyle={selector:'node[modelID = "'+modelID+'"]',style:{'shape': 'rectangle'}}
    }else{
        newStyle={selector:'node[modelID = "'+modelID+'"]',style:{'shape': shape}}
    }
    this.updateStyleSheet([newStyle])
}

topologyDOM_styleManager.prototype.updateModelTwinDimension=function(modelID,dimensionRatio){
    if(!this.nodeModelVisualAdjustment[modelID])this.nodeModelVisualAdjustment[modelID]={}
    this.nodeModelVisualAdjustment[modelID].dimensionRatio=parseFloat(dimensionRatio)
    this.adjustModelsBaseDimension(modelID)
}

topologyDOM_styleManager.prototype.updateModelTwinLabelOffset = function (modelID) {
    this.adjustModelsBaseDimension(modelID)
}

topologyDOM_styleManager.prototype.updateRelationshipColor=function(srcModelID,relationshipName,colorCode){
    this.updateStyleSheet([
        {selector:'edge[sourceModel = "'+srcModelID+'"][relationshipName = "'+relationshipName+'"]', style:{'line-color': colorCode}}
    ])
}

topologyDOM_styleManager.prototype.updateRelationshipShape=function(srcModelID,relationshipName,shape){
    var newStyle
    if(shape=="solid"){
        newStyle={selector:'edge[sourceModel = "'+srcModelID+'"][relationshipName = "'+relationshipName+'"]', style:{'line-style': shape}}
    }else if(shape=="dotted"){
        newStyle={selector:'edge[sourceModel = "'+srcModelID+'"][relationshipName = "'+relationshipName+'"]', style:{'line-style': 'dashed','line-dash-pattern':[8,8]}}
    }
    this.updateStyleSheet([newStyle])    
}
topologyDOM_styleManager.prototype.updateRelationshipWidth=function(srcModelID,relationshipName,edgeWidth){
    var arr=[
        {selector:'edge[sourceModel = "'+srcModelID+'"][relationshipName = "'+relationshipName+'"]',style:{'width':parseFloat(edgeWidth)}},
        {selector:'edge.hover[sourceModel = "'+srcModelID+'"][relationshipName = "'+relationshipName+'"]',style:{'width':parseFloat(edgeWidth)+10}},
    ]
    this.updateStyleSheet(arr)
}

topologyDOM_styleManager.prototype.getFontSizeInCurrentZoom=function(){
    var curZoom=this.core.zoom()
    if(curZoom>1){
        var maxFS=12
        var minFS=5
        var ratio= (maxFS/minFS-1)/9*(curZoom-1)+1
        var fs=Math.ceil(maxFS/ratio)
    }else{
        var maxFS=120
        var minFS=12
        var ratio= (maxFS/minFS-1)/9*(1/curZoom-1)+1
        var fs=Math.ceil(minFS*ratio)
    }
    return fs;
}

topologyDOM_styleManager.prototype.getNodeSizeInCurrentZoom=function(){
    var curZoom=this.core.zoom()
    //console.log(curZoom)
    //bigger zoom means zoom in more to the detail
    if(curZoom>1){//scale up but not too much
        var ratio= (curZoom-1)*(2-1)/4+1
        return Math.ceil(this.defaultNodeSize/ratio)
    }else{
        var ratio= (1/curZoom-1)*(2-1)/4+1
        return Math.ceil(this.defaultNodeSize*ratio)
    }
}

topologyDOM_styleManager.prototype.dataSourceSVG=function(){
    var svgStr= '<svg enable-background="0 0 512 512" height="512" viewBox="0 0 512 512" width="512" xmlns="http://www.w3.org/2000/svg"><path d="m282.931 468c-23.131 0-41.5-15.897-44.804-38.897l-48.772-341.226c-.179-1.248-.557-3.875-4.485-3.877-.002 0-.005 0-.007 0-3.923 0-4.303 2.624-4.486 3.885l-34.736 243.531c-3.158 21.743-20.653 37.57-42.551 38.539-21.901.967-40.722-13.252-45.776-34.581-.019-.077-.036-.153-.053-.23l-11.214-49.947c-3.047-12.662-14.228-22.197-26.047-22.197-11.046 0-20-8.954-20-20s8.954-20 20-20c30.372 0 57.705 22.321 64.993 53.074.019.077.036.153.053.23l11.216 49.955c.282 1.172 1.064 3.904 5.06 3.734 4.133-.183 4.564-3.157 4.727-4.277l34.736-243.531c3.27-22.508 21.391-38.185 44.078-38.185h.039c22.707.018 40.82 15.728 44.049 38.204l48.771 341.225c.181 1.259.708 4.666 5.369 4.57 4.702-.071 5.086-3.465 5.231-4.743l6.803-60.491c1.234-10.977 11.134-18.877 22.11-17.639 10.977 1.234 18.874 11.133 17.639 22.11l-6.805 60.504c-2.642 23.354-20.89 39.902-44.377 40.255-.254.003-.508.005-.761.005zm169.253-147.633c.02-.079.039-.158.058-.237l7.062-29.967c3.901-15.493 17.939-27.163 32.696-27.163 11.046 0 20-8.954 20-20s-8.954-20-20-20c-33.154 0-63.242 24.231-71.542 57.617-.02.079-.039.159-.058.238l-7.063 29.974c-.238.942-.662 2.253-3.008 2.167-2.445-.096-2.687-1.549-2.839-2.458l-15.696-95.746c-3.408-20.444-20.25-34.354-40.978-33.799-20.719.544-36.817 15.308-39.147 35.903l-8.469 74.855c-1.242 10.976 6.649 20.88 17.625 22.122 10.979 1.243 20.88-6.649 22.122-17.625l8.469-74.855c.018-.152.038-.274.058-.369.237-.053.552-.062.79-.021.022.083.046.187.067.312l15.696 95.746c3.388 20.331 20.139 35.095 40.734 35.904.591.023 1.178.035 1.764.035 19.843 0 36.829-13.204 41.659-32.633z"/></svg>'
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svgStr)
}

module.exports = topologyDOM_styleManager;
},{"../sharedSourceFiles/globalCache":21}],15:[function(require,module,exports){
const globalCache = require("../sharedSourceFiles/globalCache")

function topologyDOM_visual(topologyCore){
    this.core=topologyCore

    var ur = this.core.undoRedo({isDebug: false});
    this.ur=ur
}

topologyDOM_visual.prototype.chooseLayout = function (layoutName) {
    if (layoutName == "[NA]") {
        this.noPosition_cose(null)
    } else if (layoutName != null) {
        var layoutDetail = globalCache.layoutJSON[layoutName].detail
        if (layoutDetail) {
            this.applyNewLayoutWithUndo(layoutDetail, this.getCurrentLayoutDetail(),null,"centerNodes")
            this.core.fit(this.core.nodes()) 
        }
    }
}

topologyDOM_visual.prototype.dimensionSelectedNode = function (direction) {
    var ratio=1.2
    var selectedNodes=this.core.nodes(':selected')
    if(selectedNodes.size()<2) return;
    var boundary= selectedNodes.boundingBox({includeLabels :false,includeOverlays :false })
    var centerX=boundary["x1"]+boundary["w"]/2
    var centerY=boundary["y1"]+boundary["h"]/2
    
    var oldLayout={}
    var newLayout={}
    selectedNodes.forEach(oneNode=>{
        var curPos=oneNode.position()
        var nodeID=oneNode.id()
        oldLayout[nodeID]=[curPos['x'],curPos['y']]
        var xoffcenter=curPos["x"]-centerX
        var yoffcenter=curPos["y"]-centerY
        if(direction=="expand") newLayout[nodeID]=[centerX+xoffcenter*ratio,centerY+yoffcenter*ratio]
        else if(direction=="compress") newLayout[nodeID]=[centerX+xoffcenter/ratio,centerY+yoffcenter/ratio]
    })
    this.applyNewLayoutWithUndo(newLayout,oldLayout,"onlyAdjustNodePosition")
}

topologyDOM_visual.prototype.mirrorSelectedNode = function (direction) {
    var selectedNodes=this.core.nodes(':selected')
    if(selectedNodes.size()<2) return;
    var boundary= selectedNodes.boundingBox({includeLabels :false,includeOverlays :false })
    var centerX=boundary["x1"]+boundary["w"]/2
    var centerY=boundary["y1"]+boundary["h"]/2
    
    var oldLayout={}
    var newLayout={}
    selectedNodes.forEach(oneNode=>{
        var curPos=oneNode.position()
        var nodeID=oneNode.id()
        oldLayout[nodeID]=[curPos['x'],curPos['y']]
        var xoffcenter=curPos["x"]-centerX
        var yoffcenter=curPos["y"]-centerY
        if(direction=="horizontal") newLayout[nodeID]=[centerX-xoffcenter,curPos['y']]
        else if(direction=="vertical") newLayout[nodeID]=[curPos['x'],centerY-yoffcenter]
    })
    this.applyNewLayoutWithUndo(newLayout,oldLayout,"onlyAdjustNodePosition")
}

topologyDOM_visual.prototype.rotateSelectedNode = function (direction) {
    var selectedNodes=this.core.nodes(':selected')
    if(selectedNodes.size()<2) return;
    var boundary= selectedNodes.boundingBox({includeLabels :false,includeOverlays :false })
    var centerX=boundary["x1"]+boundary["w"]/2
    var centerY=boundary["y1"]+boundary["h"]/2
    
    var oldLayout={}
    var newLayout={}
    selectedNodes.forEach(oneNode=>{
        var curPos=oneNode.position()
        var nodeID=oneNode.id()
        oldLayout[nodeID]=[curPos['x'],curPos['y']]
        var xoffcenter=curPos["x"]-centerX
        var yoffcenter=curPos["y"]-centerY
        if(direction=="left") newLayout[nodeID]=[centerX+yoffcenter,centerY-xoffcenter]
        else if(direction=="right") newLayout[nodeID]=[centerX-yoffcenter,centerY+xoffcenter]
    })
    this.applyNewLayoutWithUndo(newLayout,oldLayout,"onlyAdjustNodePosition")
}

topologyDOM_visual.prototype.distributeSelectedNode = function (direction) {
    var selectedNodes=this.core.nodes(':selected')
    if(selectedNodes.size()<3) return;
    var numArr=[]
    var oldLayout={}
    var layoutForSort=[]
    selectedNodes.forEach(oneNode=>{
        var position=oneNode.position()
        if(direction=="vertical") numArr.push(position['y'])
        else if(direction=="horizontal") numArr.push(position['x'])
        var curPos=oneNode.position()
        var nodeID=oneNode.id()
        oldLayout[nodeID]=[curPos['x'],curPos['y']]
        layoutForSort.push({id:nodeID,x:curPos['x'],y:curPos['y']})
    })

    if(direction=="vertical") layoutForSort.sort(function (a, b) {return a["y"]-b["y"] })
    else if(direction=="horizontal") layoutForSort.sort(function (a, b) {return a["x"]-b["x"] })
    
    var minV=Math.min(...numArr)
    var maxV=Math.max(...numArr)
    if(minV==maxV) return;
    var gap=(maxV-minV)/(selectedNodes.size()-1)
    var newLayout={}
    if(direction=="vertical") var curV=layoutForSort[0]["y"]
    else if(direction=="horizontal") curV=layoutForSort[0]["x"]
    for(var i=0;i<layoutForSort.length;i++){
        var oneNodeInfo=layoutForSort[i]
        if(i==0|| i==layoutForSort.length-1){
            newLayout[oneNodeInfo.id]=[oneNodeInfo['x'],oneNodeInfo['y']]
            continue
        }
        curV+=gap;
        if(direction=="vertical") newLayout[oneNodeInfo.id]=[oneNodeInfo['x'],curV]
        else if(direction=="horizontal") newLayout[oneNodeInfo.id]=[curV,oneNodeInfo['y']]
    }
    this.applyNewLayoutWithUndo(newLayout,oldLayout,"onlyAdjustNodePosition")
}

topologyDOM_visual.prototype.alignSelectedNodes = function (direction) {
    var selectedNodes=this.core.nodes(':selected')
    if(selectedNodes.size()<2) return;
    var numArr=[]
    selectedNodes.forEach(oneNode=>{
        var position=oneNode.position()
        if(direction=="top"|| direction=="bottom") numArr.push(position['y'])
        else if(direction=="left"|| direction=="right") numArr.push(position['x'])
    })
    var targetX=null
    var targetY=null
    if(direction=="top") var targetY= Math.min(...numArr)
    else if(direction=="bottom") var targetY= Math.max(...numArr)
    if(direction=="left") var targetX= Math.min(...numArr)
    else if(direction=="right") var targetX= Math.max(...numArr)
    
    var oldLayout={}
    var newLayout={}
    selectedNodes.forEach(oneNode=>{
        var curPos=oneNode.position()
        var nodeID=oneNode.id()
        oldLayout[nodeID]=[curPos['x'],curPos['y']]
        newLayout[nodeID]=[curPos['x'],curPos['y']]
        if(targetX!=null) newLayout[nodeID][0]=targetX
        if(targetY!=null) newLayout[nodeID][1]=targetY
    })
    this.applyNewLayoutWithUndo(newLayout,oldLayout,"onlyAdjustNodePosition")
}

topologyDOM_visual.prototype.numberPrecision = function (number) {
    if(Array.isArray(number)){
        for(var i=0;i<number.length;i++) number[i] = this.numberPrecision(number[i])
        return number
    }else{
        if(number == null) return null
        else number=parseFloat(number)
        return parseFloat(number.toFixed(3))
    }  
}

topologyDOM_visual.prototype.drawTwins=function(twinsData,animation){
    var arr=[]
    for(var i=0;i<twinsData.length;i++){
        var originalInfo=twinsData[i];
        var newNode={data:{},group:"nodes"}
        newNode.data["originalInfo"]= originalInfo;
        newNode.data["id"]=originalInfo['displayName']
        var modelID=originalInfo['$metadata']['$model']
        newNode.data["modelID"]=modelID
        arr.push(newNode)
    }

    var eles = this.core.add(arr)
    if(eles.size()==0) return eles
    this.noPosition_grid(eles)
    if(animation){
        eles.forEach((ele)=>{ this.animateANode(ele) })
    }
    
    //draw simulating data source
    eles.forEach(ele=>{
        var twinID=ele.data().originalInfo['$dtId']
        var dbtwin=globalCache.DBTwins[twinID]
        if(dbtwin && dbtwin.simulate){
            for(var simNodeName in dbtwin.simulate) this.showSimulatorSource(twinID,simNodeName,dbtwin.simulate[simNodeName])
        }
    })

    return eles
}

topologyDOM_visual.prototype.hideRelations=function(relations){
    relations.forEach(oneRelation=>{
        var srcID=oneRelation["srcID"]
        var relationID=oneRelation["relID"]
        var theNodeName=globalCache.twinIDMapToDisplayName[srcID]
        var theNode=this.core.filter('[id = "'+theNodeName+'"]');
        var edges=theNode.connectedEdges().toArray()
        for(var i=0;i<edges.length;i++){
            var anEdge=edges[i]
            if(anEdge.data("originalInfo")["$relationshipId"]==relationID){
                anEdge.remove()
                break
            }
        }
    })   
}

topologyDOM_visual.prototype.noPosition_grid=function(eles){
    var newLayout = eles.layout({
        name: 'grid',
        animate: false,
        fit:false
    }) 
    newLayout.run() 
}



topologyDOM_visual.prototype.noPosition_concentric=function(eles,box){
    if(eles==null) eles=this.core.elements()
    var newLayout =eles.layout({
        name: 'concentric',
        animate: false,
        fit:false,
        minNodeSpacing:60,
        gravity:1,
        boundingBox:box
    }) 
    newLayout.run()
}

topologyDOM_visual.prototype.drawTwinsAndRelations=function(data){
    var twinsAndRelations=data.childTwinsAndRelations

    //draw those new twins first
    twinsAndRelations.forEach(oneSet=>{
        var twinInfoArr=[]
        for(var ind in oneSet.childTwins) twinInfoArr.push(oneSet.childTwins[ind])
        var eles=this.drawTwins(twinInfoArr,"animation")
    })

    //draw those known twins from the relationships
    var twinsInfo={}
    twinsAndRelations.forEach(oneSet=>{
        var relationsInfo=oneSet["relationships"]
        relationsInfo.forEach((oneRelation)=>{
            var srcID=oneRelation['$sourceId']
            var targetID=oneRelation['$targetId']
            if(globalCache.storedTwins[srcID])
                twinsInfo[srcID] = globalCache.storedTwins[srcID]
            if(globalCache.storedTwins[targetID])
                twinsInfo[targetID] = globalCache.storedTwins[targetID]    
        })
    })
    var tmpArr=[]
    for(var twinID in twinsInfo) tmpArr.push(twinsInfo[twinID])
    this.drawTwins(tmpArr)

    //then check all stored relationships and draw if it can be drawn
    this.reviewStoredRelationshipsToDraw()
}

topologyDOM_visual.prototype.reviewStoredRelationshipsToDraw=function(){
    //check the storedOutboundRelationships again and maybe some of them can be drawn now since targetNode is available
    var storedRelationArr=[]
    for(var twinID in globalCache.storedOutboundRelationships){
        storedRelationArr=storedRelationArr.concat(globalCache.storedOutboundRelationships[twinID])
    }
    this.drawRelations(storedRelationArr)
}

topologyDOM_visual.prototype.drawRelations=function(relationsData){
    var relationInfoArr=[]
    for(var i=0;i<relationsData.length;i++){
        var originalInfo=relationsData[i];
        
        var theID=originalInfo['$relationshipName']+"_"+originalInfo['$relationshipId']
        var aRelation={data:{},group:"edges"}
        aRelation.data["originalInfo"]=originalInfo
        aRelation.data["id"]=theID
        aRelation.data["source"]=globalCache.twinIDMapToDisplayName[originalInfo['$sourceId']]
        aRelation.data["target"]=globalCache.twinIDMapToDisplayName[originalInfo['$targetId']]

        if(this.core.$(`[id="${aRelation.data["source"]}"]`).length==0 
            || this.core.$(`[id="${aRelation.data["target"]}"]`).length==0) continue
        var sourceNode=this.core.$(`[id="${aRelation.data["source"]}"]`)
        var sourceModel=sourceNode[0].data("originalInfo")['$metadata']['$model']
        
        //add additional source node information to the original relationship information
        originalInfo['sourceModel']=sourceModel
        aRelation.data["sourceModel"]=sourceModel
        aRelation.data["relationshipName"]=originalInfo['$relationshipName']

        var existEdge=this.core.$('edge[id = "'+theID+'"]')
        if(existEdge.size()>0) {
            existEdge.data("originalInfo",originalInfo)
            continue;  //no need to draw it
        }

        relationInfoArr.push(aRelation)
    }
    if(relationInfoArr.length==0) return null;

    var edges=this.core.add(relationInfoArr)
    return edges
}

topologyDOM_visual.prototype.animateANode=function(twin){
    var curDimension= twin.width()
    twin.animate({
        style: { 'height': curDimension*2,'width': curDimension*2 },
        duration: 200
    });

    setTimeout(()=>{
        twin.animate({
            style: { 'height': curDimension,'width': curDimension },
            duration: 200
            ,complete:()=>{
                twin.removeStyle() //must remove the style after animation, otherwise they will have their own style
            }
        });
    },200)
}

topologyDOM_visual.prototype.showSimulatorSource = function (twinID,simNodeName,simSourceObj) {
    var twinName=globalCache.twinIDMapToDisplayName[twinID]
    this.core.add([{
        data:{
            "id":simNodeName,
            "modelID":"_fixed_simulationDataSource",
            "notTwin":true,
            "originalInfo":{
                "simNodeName":simNodeName,
                "twinID":twinID,
                "detail":simSourceObj
            }
        }
        ,group:"nodes"
    }])
    var topoNode= this.core.nodes(`[id="${simNodeName}"]`)
    var sourceNode=this.core.nodes(`[id="${twinName}"]`)
    if(topoNode){
        var position=sourceNode.renderedPosition()
        topoNode.renderedPosition( {x:position.x-60,y:position.y-parseInt((Math.random()-0.5)*120)} )
        this.core.add([{
            data:{
                "id":globalCache.uuidv4(),
                "sourceModel":"_fixed_simulationDataSource",
                "source":simNodeName,
                "target":twinName,
                "notTwin":true
            }
            ,group:"edges"
        }])
    }
}

topologyDOM_visual.prototype.getCurrentLayoutDetail = function () {
    var layoutDict={"edges":{}}
    if(this.core.nodes().size()==0) return layoutDict;
    //store nodes position
    this.core.nodes().forEach(oneNode=>{
        var position=oneNode.position()
        var theArr=[position['x'],position['y']]
        //also store node rotate and scale information
        if(oneNode.data("scaleFactor") || oneNode.data("rotateAngle")){
            theArr.push(oneNode.data("scaleFactor"),oneNode.data("rotateAngle"))
        }

        this.numberPrecision(theArr)
        layoutDict[oneNode.id()]=theArr
    })

    //store any edge bending points or controling points, which is elements data cyedgebendeditingWeights,cyedgebendeditingDistances cyedgecontroleditingWeights  cyedgecontroleditingDistances
    this.core.edges().forEach(oneEdge=>{
        if(oneEdge.data().notTwin) return;
        var srcID=oneEdge.data("originalInfo")["$sourceId"]
        var relationshipID=oneEdge.data("originalInfo")["$relationshipId"]
        var cyedgebendeditingWeights=oneEdge.data('cyedgebendeditingWeights')
        var cyedgebendeditingDistances=oneEdge.data('cyedgebendeditingDistances')
        var cyedgecontroleditingWeights=oneEdge.data('cyedgecontroleditingWeights')
        var cyedgecontroleditingDistances=oneEdge.data('cyedgecontroleditingDistances')
        if(!cyedgebendeditingWeights && !cyedgecontroleditingWeights) return;

        if(layoutDict.edges[srcID]==null)layoutDict.edges[srcID]={}
        layoutDict.edges[srcID][relationshipID]={}
        if(cyedgebendeditingWeights && cyedgebendeditingWeights.length>0) {
            layoutDict.edges[srcID][relationshipID]["cyedgebendeditingWeights"]=this.numberPrecision(cyedgebendeditingWeights)
            layoutDict.edges[srcID][relationshipID]["cyedgebendeditingDistances"]=this.numberPrecision(cyedgebendeditingDistances)
        }
        if(cyedgecontroleditingWeights && cyedgecontroleditingWeights.length>0) {
            layoutDict.edges[srcID][relationshipID]["cyedgecontroleditingWeights"]=this.numberPrecision(cyedgecontroleditingWeights)
            layoutDict.edges[srcID][relationshipID]["cyedgecontroleditingDistances"]=this.numberPrecision(cyedgecontroleditingDistances)
        }
    })
    return layoutDict;
}

topologyDOM_visual.prototype.noPosition_cose=function(eles){
    if(eles==null) eles=this.core.elements()
    var undoLayoutDetail= this.getCurrentLayoutDetail()

    //remove all bending point and scale rotate
    this.resetAllBendingEdge()
    this.resetAllNodeScaleRotate()
    var newLayout =eles.layout({
        name: 'cose',
        gravity:1,
        animate: false
        ,fit:false
    }) 
    newLayout.run()
    if(undoLayoutDetail){
        var newLayoutDetail=this.getCurrentLayoutDetail()
        this.applyNewLayoutWithUndo(newLayoutDetail, undoLayoutDetail)
    }
    
    this.core.center(eles)
}

topologyDOM_visual.prototype.resetAllBendingEdge=function(){
    this.core.edges().forEach(oneEdge=>{
        oneEdge.removeClass('edgebendediting-hasbendpoints')
        oneEdge.removeClass('edgecontrolediting-hascontrolpoints')
        oneEdge.data("cyedgebendeditingWeights",[])
        oneEdge.data("cyedgebendeditingDistances",[])
        oneEdge.data("cyedgecontroleditingWeights",[])
        oneEdge.data("cyedgecontroleditingDistances",[])
    })
}

topologyDOM_visual.prototype.resetAllNodeScaleRotate=function(){
    this.core.nodes().forEach(oneNode=>{
        oneNode.removeClass('edgebendediting_scaleRotate')
        oneNode.removeData("scaleFactor")
        oneNode.removeData("rotateAngle")
    })
}

topologyDOM_visual.prototype.redrawBasedOnLayoutDetail = function (layoutDetail,onlyAdjustNodePosition,noAnimation,centerNodes) {
    //remove all bending edge 
    if(!onlyAdjustNodePosition) this.resetAllBendingEdge()    
    if(layoutDetail==null) return;
    
    var storedPositions={}
    for(var ind in layoutDetail){
        if(ind == "edges") continue
        //ind is the node name, check if there is attached simulation data source, if have, adjust its position as well
        storedPositions[ind]={
            x:layoutDetail[ind][0]
            ,y:layoutDetail[ind][1]
        }
        if (!onlyAdjustNodePosition) {
            //apply scale or rotate if the twin node has
            this.applyNodeScaleRotate(ind, layoutDetail[ind][2], layoutDetail[ind][3])
        }
        
        var dbTwin=globalCache.getSingleDBTwinByName(ind)
        if (!dbTwin || !dbTwin.simulate) continue
        //redraw the attached simulation data sources of twin
        for (var simNodeName in dbTwin.simulate) {
            storedPositions[simNodeName] = {
                x: layoutDetail[ind][0] - 60
                , y: layoutDetail[ind][1] - parseInt((Math.random() - 0.5) * 120)
            }
        }
    }
    var newLayout=this.core.layout({
        name: 'preset',
        positions:storedPositions,
        fit:false,
        animate: ((noAnimation)?false:true),
        animationDuration: 300,
    })
    newLayout.run()
    if(centerNodes){
        newLayout.on("layoutstop",()=>{
            this.core.animate({"fit":{"eles":this.core.nodes(),"padding":"100"}})
        })
    }
    
    //restore edges bending or control points
    var edgePointsDict=layoutDetail["edges"]
    if(edgePointsDict==null)return;
    for(var srcID in edgePointsDict){
        for(var relationshipID in edgePointsDict[srcID]){
            var obj=edgePointsDict[srcID][relationshipID]
            this.applyEdgeBendcontrolPoints(srcID,relationshipID,obj["cyedgebendeditingWeights"]
            ,obj["cyedgebendeditingDistances"],obj["cyedgecontroleditingWeights"],obj["cyedgecontroleditingDistances"])
        }
    }
}

topologyDOM_visual.prototype.applyNodeScaleRotate=function(twinName,scaleF,rotateF){
    var theNode=this.core.filter('[id = "'+twinName+'"]');
    if(theNode.length==0) return;
    theNode=theNode[0]
    if(scaleF || rotateF){
        if(scaleF) theNode.data("scaleFactor",scaleF)
        else theNode.removeData("scaleFactor")
        if(rotateF) theNode.data("rotateAngle",rotateF)
        else theNode.removeData("rotateAngle")
        theNode.addClass('edgebendediting_scaleRotate');
    }else theNode.removeClass('edgebendediting_scaleRotate');
}

topologyDOM_visual.prototype.applyEdgeBendcontrolPoints = function (srcID,relationshipID
    ,cyedgebendeditingWeights,cyedgebendeditingDistances,cyedgecontroleditingWeights,cyedgecontroleditingDistances) {
        var nodeName=globalCache.twinIDMapToDisplayName[srcID]
        var theNode=this.core.filter('[id = "'+nodeName+'"]');
        if(theNode.length==0) return;
        var edges=theNode.connectedEdges().toArray()
        for(var i=0;i<edges.length;i++){
            var anEdge=edges[i]
            if(anEdge.data().notTwin) continue
            if(anEdge.data("originalInfo")["$relationshipId"]==relationshipID){
                if(cyedgebendeditingWeights){
                    anEdge.data("cyedgebendeditingWeights",cyedgebendeditingWeights)
                    anEdge.data("cyedgebendeditingDistances",cyedgebendeditingDistances)
                    anEdge.addClass('edgebendediting-hasbendpoints');
                }
                if(cyedgecontroleditingWeights){
                    anEdge.data("cyedgecontroleditingWeights",cyedgecontroleditingWeights)
                    anEdge.data("cyedgecontroleditingDistances",cyedgecontroleditingDistances)
                    anEdge.addClass('edgecontrolediting-hascontrolpoints');
                }
                
                break
            }
        }
}

topologyDOM_visual.prototype.applyCurrentLayoutWithNoAnimtaion = function () {
    var layoutName = globalCache.currentLayoutName
    if (layoutName != null) {
        var layoutDetail = globalCache.layoutJSON[layoutName].detail
        if (layoutDetail) {
            this.redrawBasedOnLayoutDetail(layoutDetail, null, "noAnimation")
        }
    }
    this.core.fit(this.core.nodes())
}

topologyDOM_visual.prototype.applyNewLayoutWithUndo = function (newLayoutDetail,oldLayoutDetail,onlyAdjustNodePosition,centerNodes) {
    //store current layout for undo operation
    this.ur.action( "changeLayout"
        , (arg)=>{
            this.redrawBasedOnLayoutDetail(arg.newLayoutDetail,arg.onlyAdjustNodePosition,null,centerNodes)        
            return arg
        }
        , (arg)=>{
            this.redrawBasedOnLayoutDetail(arg.oldLayoutDetail,arg.onlyAdjustNodePosition,null,centerNodes)
            return arg
        }
    )
    this.ur.do("changeLayout"
        , { firstTime: true, "newLayoutDetail": newLayoutDetail, "oldLayoutDetail": oldLayoutDetail,"onlyAdjustNodePosition":onlyAdjustNodePosition}
    )
}

module.exports = topologyDOM_visual;
},{"../sharedSourceFiles/globalCache":21}],16:[function(require,module,exports){
const simpleTree=require("../sharedSourceFiles/simpleTree")
const modelAnalyzer=require("../sharedSourceFiles/modelAnalyzer")
const msalHelper = require("../msalHelper")
const globalCache = require("../sharedSourceFiles/globalCache")
const newTwinDialog=require("../sharedSourceFiles/newTwinDialog");

function twinsTree(DOM, searchDOM) {
    this.tree=new simpleTree(DOM,{"leafNameProperty":"displayName"})

    this.tree.options.groupNodeIconFunc=(gn)=>{
        return globalCache.generateModelIcon(gn.info["@id"])
    }

    this.tree.options.groupNodeTailButtonFunc = (gn) => {
        var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="font-size:1.2em;padding:4px 8px;position:absolute;top:50%;height:27px; right:10px;transform:translateY(-50%)">+</button>')
        addButton.on("click", (e) => {
            gn.expand()
            newTwinDialog.popup({
                "$metadata": {
                    "$model": gn.info["@id"]
                }
            })
            return false
        })
        return addButton;
    }

    this.tree.callback_afterSelectNodes=(nodesArr,mouseClickDetail)=>{
        var infoArr=[]
        nodesArr.forEach((item, index) =>{
            infoArr.push(item.leafInfo)
        });
        this.broadcastMessage({ "message": "showInfoSelectedNodes", info:infoArr, "mouseClickDetail":mouseClickDetail})
    }

    this.tree.callback_afterDblclickNode=(theNode)=>{
        this.broadcastMessage({ "message": "PanToNode", info:theNode.leafInfo})
    }

    this.searchBox=$('<input type="text"  placeholder="search..."/>').addClass("w3-input");
    this.searchBox.css({"outline":"none","height":"100%","width":"100%"}) 
    searchDOM.append(this.searchBox)
    var hideOrShowEmptyGroup=$('<button style="height:20px;border:none;padding-left:2px" class="w3-ripple w3-block w3-tiny w3-hover-red w3-amber">Hide Empty Models</button>')
    searchDOM.append(hideOrShowEmptyGroup)
    DOM.css("top","50px")
    hideOrShowEmptyGroup.attr("status","show")
    hideOrShowEmptyGroup.on("click",()=>{
        if(hideOrShowEmptyGroup.attr("status")=="show"){
            hideOrShowEmptyGroup.attr("status","hide")
            hideOrShowEmptyGroup.text("Show Empty Models")
            this.tree.options.hideEmptyGroup=true
        }else{
            hideOrShowEmptyGroup.attr("status","show")
            hideOrShowEmptyGroup.text("Hide Empty Models")
            delete this.tree.options.hideEmptyGroup
        }
        this.tree.groupNodes.forEach(oneGroupNode=>{oneGroupNode.checkOptionHideEmptyGroup()})
    })
    this.searchBox.keyup((e)=>{
        if(e.keyCode == 13)
        {
            var aNode = this.tree.searchText($(e.target).val())
            if(aNode!=null){
                aNode.parentGroupNode.expand()
                this.tree.selectLeafNode(aNode)
                this.tree.scrollToLeafNode(aNode)
            }
        }
    });
}

twinsTree.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="startSelection_replace") this.loadStartSelection(msgPayload.twinIDs,msgPayload.modelIDs,"replace")
    else if(msgPayload.message=="startSelection_append") this.loadStartSelection(msgPayload.twinIDs,msgPayload.modelIDs,"append")
    else if(msgPayload.message=="drawTwinsAndRelations") this.drawTwinsAndRelations(msgPayload.info)
    else if(msgPayload.message=="ADTModelsChange") this.refreshModels()
    else if(msgPayload.message=="addNewTwin") this.drawOneTwin(msgPayload.twinInfo)
    else if(msgPayload.message=="addNewTwins") msgPayload.twinsInfo.forEach(oneTwinInfo=>{this.drawOneTwin(oneTwinInfo)})
    else if(msgPayload.message=="twinsDeleted") this.hideTwins(msgPayload.twinIDArr)
    else if(msgPayload.message=="hideSelectedNodes") this.hideTwins(msgPayload.twinIDArr)
    else if(msgPayload.message=="visualDefinitionChange"){
        if(!msgPayload.srcModelID){ // change model class visualization
            this.tree.groupNodes.forEach(gn=>{gn.refreshName()})
        } 
    }
}

twinsTree.prototype.hideTwins=function(twinIDArr){
    twinIDArr.forEach(twinID=>{
        var twinDisplayName=globalCache.twinIDMapToDisplayName[twinID]
        this.tree.deleteLeafNode(twinDisplayName)
    })
}

twinsTree.prototype.refreshModels=function(){
    var modelsData={}
    for(var modelID in modelAnalyzer.DTDLModels){
        var oneModel=modelAnalyzer.DTDLModels[modelID]
        modelsData[oneModel["displayName"]] = oneModel
    }
    //delete all group nodes of deleted models
    var arr=[].concat(this.tree.groupNodes)
    arr.forEach((gnode)=>{
        if(modelsData[gnode.name]==null){
            //delete this group node
            gnode.deleteSelf()
        }
    })

    //then add all group nodes that to be added
    var currentModelNameArr=[]
    this.tree.groupNodes.forEach((gnode)=>{currentModelNameArr.push(gnode.name)})

    var actualModelNameArr=[]
    for(var ind in modelsData) actualModelNameArr.push(ind)
    actualModelNameArr.sort(function (a, b) { return a.toLowerCase().localeCompare(b.toLowerCase()) });

    for(var i=0;i<actualModelNameArr.length;i++){
        if(i<currentModelNameArr.length && currentModelNameArr[i]==actualModelNameArr[i]) continue
        //otherwise add this group to the tree
        var newGroup=this.tree.insertGroupNode(modelsData[actualModelNameArr[i]],i)
        newGroup.shrink()
        currentModelNameArr.splice(i, 0, actualModelNameArr[i]);
    }
}


twinsTree.prototype.loadStartSelection=async function(twinIDs,modelIDs,replaceOrAppend){
    if(replaceOrAppend=="replace") this.tree.clearAllLeafNodes()

    
    this.refreshModels()
    
    //add new twins under the model group node
    try{
        var twinsdata = await msalHelper.callAPI("digitaltwin/listTwinsForIDs", "POST", twinIDs)
        var twinIDArr = []
        //check if any current leaf node does not have stored outbound relationship data yet
        this.tree.groupNodes.forEach((gNode) => {
            gNode.childLeafNodes.forEach(leafNode => {
                var nodeId = leafNode.leafInfo["$dtId"]
                if (globalCache.storedOutboundRelationships[nodeId] == null) twinIDArr.push(nodeId)
            })
        })

        globalCache.storeADTTwins(twinsdata)
        for (var i = 0; i < twinsdata.length; i++) {
            var groupName = globalCache.modelIDMapToName[twinsdata[i]["$metadata"]["$model"]]
            this.tree.addLeafnodeToGroup(groupName, twinsdata[i], "skipRepeat")
            twinIDArr.push(twinsdata[i]["$dtId"])
        }
        if(replaceOrAppend=="replace") this.broadcastMessage({ "message": "replaceAllTwins", info: twinsdata })
        else this.broadcastMessage({ "message": "appendAllTwins", info: twinsdata })
        

        this.fetchAllRelationships(twinIDArr)
    } catch (e) {
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }
}

twinsTree.prototype.drawTwinsAndRelations= function(data){
    data.childTwinsAndRelations.forEach(oneSet=>{
        for(var ind in oneSet.childTwins){
            var oneTwin=oneSet.childTwins[ind]
            this.drawOneTwin(oneTwin)
        }
    })
    
    //draw those known twins from the relationships
    var twinsInfo={}
    data.childTwinsAndRelations.forEach(oneSet=>{
        var relationsInfo=oneSet["relationships"]
        relationsInfo.forEach((oneRelation)=>{
            var srcID=oneRelation['$sourceId']
            var targetID=oneRelation['$targetId']
            if(globalCache.storedTwins[srcID])
                twinsInfo[srcID] = globalCache.storedTwins[srcID]
            if(globalCache.storedTwins[targetID])
                twinsInfo[targetID] = globalCache.storedTwins[targetID]    
        })
    })
    var tmpArr=[]
    for(var twinID in twinsInfo) tmpArr.push(twinsInfo[twinID])
    tmpArr.forEach(oneTwin=>{this.drawOneTwin(oneTwin)})
}

twinsTree.prototype.drawOneTwin= function(twinInfo){
    var groupName=globalCache.modelIDMapToName[twinInfo["$metadata"]["$model"]]
    this.tree.addLeafnodeToGroup(groupName,twinInfo,"skipRepeat")
}

twinsTree.prototype.fetchAllRelationships= async function(twinIDArr){
    while(twinIDArr.length>0){
        var smallArr= twinIDArr.splice(0, 100);
        try{
            var data = await msalHelper.callAPI("digitaltwin/getRelationshipsFromTwinIDs", "POST", smallArr)
            if (data == "") continue;
            globalCache.storeTwinRelationships(data) //store them in global available array
            this.broadcastMessage({ "message": "drawAllRelations", info: data })
        } catch (e) {
            console.log(e)
            if(e.responseText) alert(e.responseText)
        }
    }
}

module.exports = twinsTree;
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/modelAnalyzer":22,"../sharedSourceFiles/newTwinDialog":26,"../sharedSourceFiles/simpleTree":34}],17:[function(require,module,exports){
const signupsigninname="B2C_1_singupsignin_spaapp1"
const b2cTenantName="azureiotb2c"

const url = new URL(window.location.href);

var strArr=window.location.href.split("?")
var isLocalTest=(strArr.indexOf("test=1")!=-1)

const globalAppSettings={
    "b2cSignUpSignInName": signupsigninname,
    "b2cScope_taskmaster":"https://"+b2cTenantName+".onmicrosoft.com/taskmastermodule/operation",
    "b2cScope_functions":"https://"+b2cTenantName+".onmicrosoft.com/azureiotrocksfunctions/basic",
    "logoutRedirectUri": url.origin+"/spaindex.html",
    "msalConfig":{
        auth: {
            clientId: "f4693be5-601b-4d0e-9208-c35d9ad62387",
            authority: "https://"+b2cTenantName+".b2clogin.com/"+b2cTenantName+".onmicrosoft.com/"+signupsigninname,
            knownAuthorities: [b2cTenantName+".b2clogin.com"],
            redirectUri: window.location.href
        },
        cache: {
            cacheLocation: "sessionStorage", 
            storeAuthStateInCookie: false
        },
        system: {
            loggerOptions: {
                loggerCallback: (level, message, containsPii) => {}
            }
        }
    },
    "isLocalTest":isLocalTest,
    "taskMasterAPIURI":((isLocalTest)?"http://localhost:5002/":"https://azureiotrockstaskmastermodule.azurewebsites.net/"),
    "functionsAPIURI":"https://azureiotrocksfunctions.azurewebsites.net/api/"
}

module.exports = globalAppSettings;
},{}],18:[function(require,module,exports){
(function (Buffer){(function (){
const globalAppSettings=require("./globalAppSettings")
const globalCache=require("./sharedSourceFiles/globalCache")


function msalHelper(){
    this.myMSALObj = new msal.PublicClientApplication(globalAppSettings.msalConfig);
}

msalHelper.prototype.signIn=async function(){
    try{
        var response= await this.myMSALObj.loginPopup({ scopes:[]  }) //globalAppSettings.b2cScopes
        if (response != null){
            this.setAccount(response.account)
            return response.account
        } 
        else  return this.fetchAccount()
    }catch(e){
        if(e.errorCode!="user_cancelled") console.log(e)
    }
}

msalHelper.prototype.setAccount=function(theAccount){
    if(theAccount==null)return;
    this.accountId = theAccount.homeAccountId;
    this.accountName = theAccount.username;
    this.userName=theAccount.name;
}

msalHelper.prototype.fetchAccount=function(){
    const currentAccounts = this.myMSALObj.getAllAccounts();
    if (currentAccounts.length < 1) return;
    var foundAccount=null;
    for(var i=0;i<currentAccounts.length;i++){
        var anAccount= currentAccounts[i]
        if(anAccount.homeAccountId.toUpperCase().includes(globalAppSettings.b2cSignUpSignInName.toUpperCase())
            && anAccount.idTokenClaims.iss.toUpperCase().includes(globalAppSettings.msalConfig.auth.knownAuthorities[0].toUpperCase())
            && anAccount.idTokenClaims.aud === globalAppSettings.msalConfig.auth.clientId
        ){
            foundAccount= anAccount;
        }
    }
    this.setAccount(foundAccount)
    return foundAccount;
}


msalHelper.prototype.callAzureFunctionsService=async function(APIString,RESTMethod,payload){
    var headersObj={}
    var token=await this.getToken(globalAppSettings.b2cScope_functions)
    headersObj["Authorization"]=`Bearer ${token}`
    return new Promise((resolve, reject) => {
        var ajaxContent={
            type: RESTMethod || 'GET',
            "headers":headersObj,
            url: globalAppSettings.functionsAPIURI+APIString,
            contentType: "application/json; charset=utf-8",
            crossDomain: true,
            success: function (responseData, textStatus, jqXHR) {
                resolve(responseData)
            },
            error: function (responseData, textStatus, errorThrown) {
                reject(responseData)
            }
        }
        if(RESTMethod=="POST") ajaxContent.data= JSON.stringify(payload)
        $.ajax(ajaxContent);
    })
}

msalHelper.prototype.parseJWT=function(token){
    var base64Url = token.split('.')[1];
    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    base64= Buffer.from(base64, 'base64').toString();
    var jsonPayload = decodeURIComponent(base64.split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));

    return JSON.parse(jsonPayload);
}

msalHelper.prototype.reloadUserAccountData=async function(){
    try{
        var res=await this.callAPI("accountManagement/fetchUserData")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
        return

    }
    globalCache.storeUserData(res)
}

msalHelper.prototype.callAPI=async function(APIString,RESTMethod,payload,withProjectID){
    var headersObj={}
    if(withProjectID){
        payload=payload||{}
        payload["projectID"]=globalCache.currentProjectID
    } 
    if(!globalAppSettings.isLocalTest){
        try{
            var token=await this.getToken(globalAppSettings.b2cScope_taskmaster)
        }catch(e){
            window.open(globalAppSettings.logoutRedirectUri,"_self")
        }
        
        headersObj["Authorization"]=`Bearer ${token}`

        //in case joined projects JWT is going to expire, renew another one
        if(globalCache.joinedProjectsToken) {
            var expTS=this.parseJWT(globalCache.joinedProjectsToken).exp
            var currTime=parseInt(new Date().getTime()/1000)
            if(expTS-currTime<60){ //fetch a new projects JWT token 
                await this.reloadUserAccountData()
            }
        }

        //if the API need to use project ID, must add a header "projects" jwt token so server side will verify
        if(payload && payload.projectID && globalCache.joinedProjectsToken){
            headersObj["projects"]=globalCache.joinedProjectsToken
        }

    }
    return new Promise((resolve, reject) => {
        var ajaxContent={
            type: RESTMethod || 'GET',
            "headers":headersObj,
            url: globalAppSettings.taskMasterAPIURI+APIString,
            contentType: "application/json; charset=utf-8",
            crossDomain: true,
            success: function (responseData, textStatus, jqXHR) {
                resolve(responseData)
            },
            error: function (responseData, textStatus, errorThrown) {
                reject(responseData)
            }
        }
        if(RESTMethod=="POST") ajaxContent.data= JSON.stringify(payload)
        $.ajax(ajaxContent);
    })
}

msalHelper.prototype.getToken=async function(b2cScope){
    try{
        if(this.storedToken==null) this.storedToken={}
        if(this.storedToken[b2cScope]!=null){
            var currTime=parseInt(new Date().getTime()/1000)
            if(currTime+60 < this.storedToken[b2cScope].expire) return this.storedToken[b2cScope].accessToken
        }
        var tokenRequest={
            scopes: [b2cScope],
            forceRefresh: false, // Set this to "true" to skip a cached token and go to the server to get a new token
            account: this.myMSALObj.getAccountByHomeId(this.accountId)
        }
    
        console.log("try to silently get token")
        var response = await this.myMSALObj.acquireTokenSilent(tokenRequest)
        console.log("get token successfully")
        if (!response.accessToken || response.accessToken === "") {
            throw new msal.InteractionRequiredAuthError();
        }
        this.storedToken[b2cScope]={"accessToken":response.accessToken,"expire":response.idTokenClaims.exp}
    }catch(error){
        if (error instanceof msal.InteractionRequiredAuthError) {
            // fallback to interaction when silent call fails
            var response=await this.myMSALObj.acquireTokenPopup(tokenRequest)
        } else {
            throw error;
        }
    }

    return response.accessToken;
}

module.exports = new msalHelper();
}).call(this)}).call(this,require("buffer").Buffer)

},{"./globalAppSettings":17,"./sharedSourceFiles/globalCache":21,"buffer":2}],19:[function(require,module,exports){
const simpleSelectMenu= require("./simpleSelectMenu")
const globalCache = require("../sharedSourceFiles/globalCache")
const modelAnalyzer = require("../sharedSourceFiles/modelAnalyzer");
const msalHelper = require("../msalHelper")
const simpleChart=require("./simpleChart")

class baseInfoPanel {
    drawEditable(parent,jsonInfo,originElementInfo,pathArr,funcGetKeyLblColorClass){
        if(jsonInfo==null) return;
        for(var ind in jsonInfo){
            var keyDiv= $("<label style='display:block'><div style='display:inline;padding:.1em .3em .1em .3em; margin-right:5px'>"+ind+"</div></label>")
            parent.append(keyDiv)
            
            keyDiv.css("padding-top",".3em") 
    
            var contentDOM=$("<label style='padding-top:.2em'></label>")
            var newPath=pathArr.concat([ind])
            var keyLabelColorClass="w3-dark-gray"
            if(funcGetKeyLblColorClass) keyLabelColorClass=funcGetKeyLblColorClass(newPath)
            if(Array.isArray(jsonInfo[ind])){
                keyDiv.children(":first").addClass(keyLabelColorClass)
                if (this.readOnly) {
                    var val = globalCache.searchValue(originElementInfo, newPath)
                    if (val == null) {
                        contentDOM.css({ "color": "gray", "font-size": "9px" })
                        contentDOM.text("[empty]")
                    } else contentDOM.text(val)
                }else{
                    this.drawDropdownOption(contentDOM,newPath,jsonInfo[ind],originElementInfo)
                }
            }else if(typeof(jsonInfo[ind])==="object") {
                keyDiv.children(":first").css("font-weight","bold")
                contentDOM.css("display","block")
                contentDOM.css("padding-left","1em")
                this.drawEditable(contentDOM,jsonInfo[ind],originElementInfo,newPath,funcGetKeyLblColorClass)
            }else {
                keyDiv.children(":first").addClass(keyLabelColorClass)
                var val = globalCache.searchValue(originElementInfo, newPath)
                if (this.readOnly) {
                    if (val == null) {
                        contentDOM.css({ "color": "gray", "font-size": "9px" })
                        contentDOM.text("[empty]")
                    } else contentDOM.text(val)
                } else {
                    var aInput = $('<input type="text" style="padding:2px;width:50%;outline:none;display:inline" placeholder="type: ' + jsonInfo[ind] + '"/>').addClass("w3-input w3-border");
                    contentDOM.append(aInput)
                    if (val != null) aInput.val(val)
                    aInput.data("path", newPath)
                    aInput.data("dataType", jsonInfo[ind])
                    aInput.change((e) => {
                        this.editDTProperty(originElementInfo, $(e.target).data("path"), $(e.target).val(), $(e.target).data("dataType"))
                    })
                }
            }
            keyDiv.append(contentDOM)
        }
    }

    drawDropdownOption(contentDOM,newPath,valueArr,originElementInfo){
        var aSelectMenu=new simpleSelectMenu("",{buttonCSS:{"padding":"4px 16px"}})
        contentDOM.append(aSelectMenu.DOM)
        aSelectMenu.DOM.data("path", newPath)
        valueArr.forEach((oneOption)=>{
            var str =oneOption["displayName"]  || oneOption["enumValue"] 
            aSelectMenu.addOption(str)
        })
        aSelectMenu.callBack_clickOption=(optionText,optionValue,realMouseClick)=>{
            aSelectMenu.changeName(optionText)
            if(realMouseClick) this.editDTProperty(originElementInfo,aSelectMenu.DOM.data("path"),optionValue,"string")
        }
        var val=globalCache.searchValue(originElementInfo,newPath)
        if(val!=null){
            aSelectMenu.triggerOptionValue(val)
        }    
    }

    generateSmallKeyDiv(str,paddingTop){
        var keyDiv = $("<label style='display:block'><div class='w3-border' style='background-color:#f6f6f6;display:inline;padding:.1em .3em .1em .3em;margin-right:.3em;font-size:10px'>"+str+"</div></label>")
        keyDiv.css("padding-top",paddingTop)
        return keyDiv
    }

    drawConnectionStatus(status,parentDom) {
        parentDom=parentDom||this.DOM
        var keyDiv=this.generateSmallKeyDiv("Connection",".5em")
        parentDom.append(keyDiv)
        var contentDOM = $('<span class="fa-stack" style="font-size:.5em;padding-left:5px"></span>')
        if(status) {
            contentDOM.addClass("w3-text-lime")
            contentDOM.html('<i class="fas fa-signal fa-stack-2x"></i>')
        }else{
            contentDOM.addClass("w3-text-red")
            contentDOM.html('<i class="fas fa-signal fa-stack-2x"></i><i class="fas fa-slash fa-stack-2x"></i>')
        }
        keyDiv.append(contentDOM)
    }

    drawStaticInfo(parent,jsonInfo,paddingTop,fontSize,fontColor){
        fontColor=fontColor||"black"
        for(var ind in jsonInfo){
            var keyDiv=this.generateSmallKeyDiv(ind,paddingTop)
            parent.append(keyDiv)
    
            var contentDOM=$("<label></label>")
            contentDOM.css({"fontSize":fontSize,"color":fontColor})
            if(jsonInfo[ind]==null){
                contentDOM.css({ "color": "gray", "font-size": "9px" })
                contentDOM.text("[empty]")
            }else if(typeof(jsonInfo[ind])==="object") {
                contentDOM.css("display","block")
                contentDOM.css("padding-left","1em")
                this.drawStaticInfo(contentDOM,jsonInfo[ind],".5em",fontSize)
            }else {
                contentDOM.css("padding-top",".2em")
                contentDOM.text(jsonInfo[ind])
            }
            
            keyDiv.append(contentDOM)
        }
    }

    fetchRealElementInfo(singleElementInfo){ //the input is possibly from topology view which might not be precise about property value
        var returnElementInfo={}
        if(singleElementInfo==null) return;
        if (singleElementInfo["$dtId"]) {
            returnElementInfo=globalCache.storedTwins[singleElementInfo["$dtId"]] //note that dynamical property value is not stored in topology node, so always get refresh data from globalcache
        }else if (singleElementInfo["$sourceId"]) {
            var arr=globalCache.storedOutboundRelationships[singleElementInfo["$sourceId"]]
            for(var i=0;i<arr.length;i++){
                if(arr[i]['$relationshipId']==singleElementInfo["$relationshipId"]){
                    returnElementInfo=arr[i]
                    break;
                }
            }
        }else if(singleElementInfo["simNodeName"]){
            var attachTwinID=singleElementInfo["twinID"]
            var dbtwin=globalCache.DBTwins[attachTwinID]
            var simNodeName=singleElementInfo["simNodeName"]
            singleElementInfo.detail=dbtwin.simulate[simNodeName]
            returnElementInfo=singleElementInfo
        }
        return returnElementInfo
    }

    drawSingleRelationProperties(singleRelationInfo,parentDom) {
        parentDom=parentDom||this.DOM
        this.drawStaticInfo(parentDom, {
            "sourceI":globalCache.twinIDMapToDisplayName[singleRelationInfo["$sourceId"]],
            "target": globalCache.twinIDMapToDisplayName[singleRelationInfo["$targetId"]],
            "$relationshipName": singleRelationInfo["$relationshipName"]
        }, "1em", "13px")
        this.drawStaticInfo(parentDom, {
            "$relationshipId": singleRelationInfo["$relationshipId"]
        }, "1em", "10px")
        var relationshipName = singleRelationInfo["$relationshipName"]
        var sourceModel = singleRelationInfo["sourceModel"]

        this.drawEditable(parentDom, this.getRelationShipEditableProperties(relationshipName, sourceModel), singleRelationInfo, [])
        for (var ind in singleRelationInfo["$metadata"]) {
            var tmpObj = {}
            tmpObj[ind] = singleRelationInfo["$metadata"][ind]
            this.drawStaticInfo(parentDom, tmpObj, "1em", "10px")
        }
        //this.drawStaticInfo(parentDom,{"$etag":singleRelationInfo["$etag"]},"1em","10px","DarkGray")
    }

    getRelationShipEditableProperties(relationshipName, sourceModel) {
        if (!modelAnalyzer.DTDLModels[sourceModel] || !modelAnalyzer.DTDLModels[sourceModel].validRelationships[relationshipName]) return
        return modelAnalyzer.DTDLModels[sourceModel].validRelationships[relationshipName].editableRelationshipProperties
    }


    drawSimDatasourceInfo(simNodeInfo,parentDom){
        parentDom=parentDom||this.DOM
        var dbTwin=globalCache.DBTwins[simNodeInfo.twinID]
        var twinName=globalCache.twinIDMapToDisplayName[simNodeInfo.twinID]
        if(!this.readOnly) {
            var containerDiv=$("<div class='w3-container'/>")
            parentDom.append(containerDiv)
            parentDom=containerDiv 
        }
        this.drawStaticInfo(parentDom, { "name": twinName }, ".5em", "13px")
        this.drawStaticInfo(parentDom, { "Model": dbTwin.modelID }, ".5em", "13px")
        if (this.readOnly) {//in float info panel
            this.drawStaticInfo(parentDom, { "Simulate Property": simNodeInfo.propertyPath }, ".5em", "13px")
            this.drawStaticInfo(parentDom, { "Cycle Length": simNodeInfo.cycleLength }, ".5em", "13px")
            this.drawStaticInfo(parentDom, { "Sampling": simNodeInfo.sampleInterval }, ".5em", "13px")
            this.drawStaticInfo(parentDom, { "Formula": simNodeInfo.formula }, ".5em", "13px")
        }else{ // in right side info panel
            this.drawSimDatasourceInfo_propertyPath(parentDom,simNodeInfo,dbTwin)
            //draw cycleLength,sampleInterval and formula
            var demoChart=this.drawSimDatasourceInfo_chart(simNodeInfo,parentDom)
            this.drawSimDatasourceInfo_input("Cycle Length(_T)","cycleLength","Cycle time length in seconds",parentDom,simNodeInfo,dbTwin,demoChart)
            this.drawSimDatasourceInfo_input("Sampling","sampleInterval","Sampling time in seconds",parentDom,simNodeInfo,dbTwin,demoChart) 
            this.drawSimDatasourceInfo_formula(parentDom,simNodeInfo,dbTwin,demoChart)
            parentDom.append(demoChart.canvas) //move chart to the end
            this.drawSimDatasourceInfo_refreshChart(simNodeInfo,demoChart)
        }
    }

    drawSimDatasourceInfo_refreshChart(simNodeInfo,theChart){
        var _T=parseFloat(simNodeInfo.detail["cycleLength"])
        var sampling=parseFloat(simNodeInfo.detail["sampleInterval"])
        var formula=simNodeInfo.detail["formula"]
        var numOfPoints=parseInt(2*_T/sampling)+1
        theChart.setXLength(numOfPoints)

        if(_T==0 || sampling==0 || formula=="" || _T==null || sampling==null || formula==null || _T<0 || sampling<0) return;

        var _t=0;
        var dataArr=[]
        var _output=null;
        for(var i=0;i<numOfPoints;i++){
            var evalStr=formula+"\n_output"
            try{
                _output=eval(evalStr) // jshint ignore:line
            }catch(e){
                return e
            }
            dataArr.push(_output)
            _t+=sampling
            if(_t>=_T)_t=_t-_T
        }
        theChart.setDataArr(dataArr)
    }

    drawSimDatasourceInfo_chart(simNodeInfo,parentDom){
        var cycleL= simNodeInfo.detail["cycleLength"]
        var sampling=simNodeInfo.detail["sampleInterval"]
        var numOfPoints=100
        var demoChart=new simpleChart(parentDom,numOfPoints,{width:"100%","height":"130px"}) 
        return demoChart
    }
    drawSimDatasourceInfo_formula(parentDom,simNodeInfo,dbTwin,demoChart){
        var scriptLbl=this.generateSmallKeyDiv("Calculation Script","2px")
        scriptLbl.css("margin-top","10px")

        var lbl2=$('<lbl style="font-size:10px;color:gray">(Build in variables:_t _T _output)</lbl>')
        scriptLbl.append(lbl2)

        var placeHolderStr='Sample&#160;Script&#58;&#10;&#10;SIN&#160;Wave&#10;_output=Math.sin(_t/_T*2*3.14)&#10;&#10;Value&#160;List&#10;var&#160;valueList=[2,3.5,-1,10.3,9.1]&#10;var&#160;index=(_t/_T*valueList.length).toFixed(0)&#10;_output=valueList[index]&#10;&#10;Square&#160;Wave&#10;_output=1-_output' 
        var scriptTextArea=$('<textarea class="w3-border" spellcheck="false" style="outline:none;font-size:11px;height:140px;width:100%;font-family:Verdana" placeholder='+placeHolderStr+'></textarea>')
        parentDom.append(scriptLbl,scriptTextArea)
        scriptTextArea.on("keydown", (e) => {
            if (e.keyCode == 9){
                this.insertToTextArea('\t',scriptTextArea)
                return false;
            }
        })
        scriptTextArea.highlightWithinTextarea({highlight: [
            { "highlight": "_t", "className": "Purple"},
            { "highlight": "_T", "className": "Cyan"},
            { "highlight": "_output", "className": "Amber"},
        ]});
        var confirmBtn=$('<button class="w3-button w3-amber w3-ripple" style="padding:2px 10px;display:block">Commit Script</button>')
        parentDom.append(confirmBtn)
        var originalV=simNodeInfo.detail["formula"]
        if (originalV != null) {
            scriptTextArea.val(originalV)
            scriptTextArea.highlightWithinTextarea('update');
        }
        confirmBtn.on("click",()=>{
            simNodeInfo.detail["formula"] = scriptTextArea.val()
            try {
                var error=this.drawSimDatasourceInfo_refreshChart(simNodeInfo,demoChart)
                if(error){
                    alert(error)
                    return;
                }
                msalHelper.callAPI("digitaltwin/updateTwin", "POST"
                    , { "twinID": simNodeInfo.twinID, "updateInfo": JSON.stringify({ "simulate": dbTwin.simulate }) }
                    , "withProjectID")
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
            }
        })
    }

    drawSimDatasourceInfo_input(lblText, keyStr,placeHolderStr, parentDom, simNodeInfo, dbTwin,demoChart) {
        var keyDiv = $("<div style='display:block;margin-top:.5em'><div style='display:inline;padding:.1em .3em .1em .3em; margin-right:5px'>"+lblText+"</div></div>")
        parentDom.append(keyDiv)
        var contentDOM = $("<label style='padding-top:.2em'></label>")
        keyDiv.append(contentDOM)
        var aInput = $('<input type="text" style="padding:2px;width:40%;outline:none;display:inline" placeholder="' + placeHolderStr + '"/>').addClass("w3-input w3-border");
        contentDOM.append(aInput)
        contentDOM.append($('<label>sec</label>')) 
        var originalV=simNodeInfo.detail[keyStr] 
        if (originalV != null) aInput.val(originalV)
        aInput.change((e) => {
            simNodeInfo.detail[keyStr] = $(e.target).val()
            try {
                this.drawSimDatasourceInfo_refreshChart(simNodeInfo,demoChart)
                msalHelper.callAPI("digitaltwin/updateTwin", "POST"
                    , { "twinID": simNodeInfo.twinID, "updateInfo": JSON.stringify({ "simulate": dbTwin.simulate }) }
                    , "withProjectID")
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
            }
        })
    }


    drawSimDatasourceInfo_propertyPath(parentDom,simNodeInfo,dbTwin){
        var keyDiv= $("<label style='display:block;padding-top:.3em'><div style='display:inline;padding:.1em .3em .1em .3em; margin-right:5px'>Simulate Property</div></label>")
        parentDom.append(keyDiv)    
        var contentDOM=$("<label style='padding-top:.2em'></label>")
        keyDiv.append(contentDOM)
        var aSelectMenu = new simpleSelectMenu("", { buttonCSS: { "padding": "4px 16px" } })
        contentDOM.append(aSelectMenu.DOM)
        var propertiesArr=modelAnalyzer.fetchPropertyPathsOfModel(dbTwin.modelID)
        propertiesArr.forEach((oneProperty) => {
            aSelectMenu.addOption(oneProperty.join("."),oneProperty)
        })
        var originalPath=simNodeInfo.detail.propertyPath
        aSelectMenu.callBack_clickOption = (optionText, optionValue, realMouseClick) => {
            aSelectMenu.changeName(optionText)
            if(!realMouseClick) return;
            if(originalPath==null || originalPath.join()!=optionValue.join){
                simNodeInfo.detail.propertyPath=optionValue
                try {
                    msalHelper.callAPI("digitaltwin/updateTwin", "POST"
                        , {"twinID":simNodeInfo.twinID,"updateInfo":JSON.stringify({"simulate":dbTwin.simulate})}
                        , "withProjectID")
                } catch (e) {
                    console.log(e)
                    if (e.responseText) alert(e.responseText)
                }
            }
        }
        if (originalPath != null) aSelectMenu.triggerOptionText(originalPath.join("."))
    }


    drawSingleNodeProperties(singleDBTwinInfo,singleADTTwinInfo,parentDom,notEmbedMetadata) {
        //instead of draw the $dtId, draw display name instead
        //this.drawStaticInfo(this.DOM,{"$dtId":singleElementInfo["$dtId"]},"1em","13px")
        parentDom=parentDom||this.DOM
        const constDesiredColor="w3-amber"
        const constReportColor="w3-blue"
        const constTelemetryColor="w3-lime"
        const constCommonColor="w3-dark-gray"

        var modelID = singleDBTwinInfo.modelID
        this.drawStaticInfo(parentDom, { "name": singleDBTwinInfo["displayName"] }, ".5em", "13px")
        var theDBModel = globalCache.getSingleDBModelByID(modelID)
        if (theDBModel.isIoTDeviceModel) {
            this.drawConnectionStatus(singleDBTwinInfo["connectState"],parentDom)
            this.drawStaticInfo(parentDom, { "Connection State Time": singleDBTwinInfo["connectStateUpdateTime"] }, ".5em", "10px")
            parentDom.append($('<table style="font-size:smaller;margin:3px 0px"><tr><td class="'+constTelemetryColor+'">&nbsp;&nbsp;</td><td>telemetry</td><td class="'+constReportColor+'">&nbsp;&nbsp;</td><td>report</td><td class="'+constDesiredColor+'">&nbsp;&nbsp;</td><td>desired</td><td class="'+constCommonColor+'">&nbsp;&nbsp;</td><td>common</td></tr></table>'))
        }

        if (modelAnalyzer.DTDLModels[modelID]) {
            if (theDBModel.isIoTDeviceModel) {
                var funcGetKeyLblColorClass = (propertyPath) => {
                    var colorCodeMapping = {}
                    theDBModel.desiredProperties.forEach(desiredP => {
                        colorCodeMapping[JSON.stringify(desiredP.path)] = constDesiredColor
                    })
                    theDBModel.reportProperties.forEach(reportP => {
                        colorCodeMapping[JSON.stringify(reportP.path)] = constReportColor
                    })
                    theDBModel.telemetryProperties.forEach(telemetryP => {
                        colorCodeMapping[JSON.stringify(telemetryP.path)] = constTelemetryColor
                    })
                    var pathStr = JSON.stringify(propertyPath)
                    if (colorCodeMapping[pathStr]) return colorCodeMapping[pathStr]
                    else return constCommonColor
                }
            }
            this.drawEditable(parentDom, modelAnalyzer.DTDLModels[modelID].editableProperties, singleADTTwinInfo, [], funcGetKeyLblColorClass)
        }

        var metadataContent = $("<label style='display:block'></label>")
        var expandMetaBtn=$("<div class='w3-border w3-button w3-light-gray' style='padding:.1em .5em;margin-right:1em;font-size:10px'>...</div>")
        parentDom.append(metadataContent)
        var metaDataDiv=$('<div/>')
        metadataContent.append(expandMetaBtn,metaDataDiv)
        metaDataDiv.hide()
        expandMetaBtn.on("click",()=>{expandMetaBtn.hide();metaDataDiv.show()})
        if(notEmbedMetadata) expandMetaBtn.trigger("click")


        this.drawStaticInfo(metaDataDiv, { "Model": modelID }, "1em", "10px")
        for (var ind in singleADTTwinInfo["$metadata"]) {
            if (ind == "$model") continue;
            var tmpObj = {}
            tmpObj[ind] = singleADTTwinInfo["$metadata"][ind]
            this.drawStaticInfo(metaDataDiv, tmpObj, ".5em", "10px")
        }
    }

    async editDTProperty(originElementInfo, path, newVal, dataType) {
        if (["double", "float", "integer", "long"].includes(dataType)) newVal = Number(newVal)
        if(dataType=="boolean"){
            if(newVal=="true") newVal=true
            else newVal=false
        }

        //{ "op": "add", "path": "/x", "value": 30 }
        if (path.length == 1) {
            var str = ""
            path.forEach(segment => { str += "/" + segment })
            var jsonPatch = [{ "op": "add", "path": str, "value": newVal }]
        } else {
            //it is a property inside a object type of root property,update the whole root property
            var rootProperty = path[0]
            var patchValue = originElementInfo[rootProperty]
            if (patchValue == null) patchValue = {}
            else patchValue = JSON.parse(JSON.stringify(patchValue)) //make a copy
            this.updateOriginObjectValue(patchValue, path.slice(1), newVal)

            var jsonPatch = [{ "op": "add", "path": "/" + rootProperty, "value": patchValue }]
        }

        if (originElementInfo["$dtId"]) { //edit a node property
            var twinID = originElementInfo["$dtId"]
            var payLoad = { "jsonPatch": JSON.stringify(jsonPatch), "twinID": twinID }
        } else if (originElementInfo["$relationshipId"]) { //edit a relationship property
            var twinID = originElementInfo["$sourceId"]
            var relationshipID = originElementInfo["$relationshipId"]
            var payLoad = { "jsonPatch": JSON.stringify(jsonPatch), "twinID": twinID, "relationshipID": relationshipID }
        }


        try {
            await msalHelper.callAPI("digitaltwin/changeAttribute", "POST", payLoad)
            this.updateOriginObjectValue(originElementInfo, path, newVal)
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }

    }

    updateOriginObjectValue(nodeInfo, pathArr, newVal) {
        if (pathArr.length == 0) return;
        var theJson = nodeInfo
        for (var i = 0; i < pathArr.length; i++) {
            var key = pathArr[i]

            if (i == pathArr.length - 1) {
                theJson[key] = newVal
                break
            }
            if (theJson[key] == null) theJson[key] = {}
            theJson = theJson[key]
        }
    }

}

module.exports = baseInfoPanel;
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21,"../sharedSourceFiles/modelAnalyzer":22,"./simpleChart":30,"./simpleSelectMenu":33}],20:[function(require,module,exports){
const msalHelper=require("../msalHelper")
const globalCache=require("./globalCache")

function editProjectDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:101" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

editProjectDialog.prototype.popup = function (projectInfo) {
    this.DOM.show()
    this.DOM.empty()
    this.projectInfo=projectInfo

    this.DOM.css({"width":"420px","padding-bottom":"3px"})
    this.DOM.append($('<div style="height:40px;margin-bottom:2px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.2em">Project Setting</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.DOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var row1=$('<div class="w3-bar" style="padding:2px"></div>')
    this.DOM.append(row1)
    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">Name </div>')
    row1.append(lable)
    var nameInput=$('<input type="text" style="outline:none; width:70%; display:inline;margin-left:2px;margin-right:2px"  placeholder="Project Name..."/>').addClass("w3-input w3-border");   
    row1.append(nameInput)
    nameInput.val(projectInfo.name)
    nameInput.on("change",async ()=>{
        var nameStr=nameInput.val()
        if(nameStr=="") {
            alert("Name can not be empty!")
            return;
        }
        var requestBody={"projectID":projectInfo.id,"accounts":[],"newProjectName":nameStr}
        requestBody.accounts=requestBody.accounts.concat(projectInfo.shareWith)
        try {
            await msalHelper.callAPI("accountManagement/changeOwnProjectName", "POST", requestBody)
            nameInput.blur()
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
            return
        }
    })



    var row2=$('<div class="w3-bar" style="padding:2px"></div>')
    this.DOM.append(row2)
    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">Share With </div>')
    row2.append(lable)
    var shareAccountInput=$('<input type="text" style="outline:none; width:60%; display:inline;margin-left:2px;margin-right:2px"  placeholder="Invitee Email..."/>').addClass("w3-input w3-border");   
    row2.append(shareAccountInput)
    var inviteBtn=$('<a class="w3-button w3-border w3-red w3-hover-amber" href="#">Invite</a>') 
    row2.append(inviteBtn) 

    var shareAccountsList=$("<div class='w3-border w3-padding' style='margin:1px 1px; height:200px;overflow-x:hidden;overflow-y:auto'><div>")
    this.DOM.append(shareAccountsList)
    this.shareAccountsList=shareAccountsList;
    this.drawSharedAccounts()

    shareAccountInput.on("keydown",(event) =>{
        if (event.keyCode == 13) this.shareWithAccount(shareAccountInput)
    });
    inviteBtn.on("click",()=>{ this.shareWithAccount(shareAccountInput)})
}

editProjectDialog.prototype.shareWithAccount=async function(accountInput){
    var shareToAccount=accountInput.val()
    if(shareToAccount=="") return;
    var theIndex= this.projectInfo.shareWith.indexOf(shareToAccount)
    if(theIndex!=-1) return;
    var requestBody={"projectID":this.projectInfo.id,"shareToAccount":shareToAccount}
    try {
        await msalHelper.callAPI("accountManagement/shareProjectTo", "POST", requestBody)
        this.addAccountToShareWith(shareToAccount)
        this.drawSharedAccounts()
        accountInput.val("")
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
        return
    }
}

editProjectDialog.prototype.addAccountToShareWith=function(shareToAccountID){
    var theIndex= this.projectInfo.shareWith.indexOf(shareToAccountID)
    if(theIndex==-1) this.projectInfo.shareWith.push(shareToAccountID)
}

editProjectDialog.prototype.drawSharedAccounts=function(){
    this.shareAccountsList.empty()
    var sharedAccount=this.projectInfo.shareWith
    sharedAccount.forEach(oneEmail => {
        var arow = $('<div class="w3-bar" style="padding:2px"></div>')
        this.shareAccountsList.append(arow)
        var lable = $('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">'+oneEmail+' </div>')
        arow.append(lable)
        var removeBtn=$('<a class="w3-button w3-border w3-red w3-hover-amber" style="margin-left:10pxyy" href="#">Remove</a>')
        arow.append(removeBtn)
        removeBtn.on("click",async ()=>{
            var requestBody={"projectID":this.projectInfo.id,"notShareToAccount":oneEmail}
            try {
                await msalHelper.callAPI("accountManagement/notShareProjectTo", "POST", requestBody)
                var theIndex = this.projectInfo.shareWith.indexOf(oneEmail)
                if (theIndex != -1) this.projectInfo.shareWith.splice(theIndex, 1)
                this.drawSharedAccounts()
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
                return
            }
        })
    })
}

module.exports = new editProjectDialog();
},{"../msalHelper":18,"./globalCache":21}],21:[function(require,module,exports){
(function (global){(function (){
function globalCache(){
    this.accountInfo=null;
    this.joinedProjectsToken=null;
    this.showFloatInfoPanel=true
    this.DBModelsArr = []
    this.DBTwins = {}
    this.modelIDMapToName={}
    this.modelNameMapToID={}
    this.twinIDMapToDisplayName={}
    this.twinDisplayNameMapToID={}
    this.storedTwins = {}
    this.layoutJSON={}
    this.visualDefinition={"default":{"detail":{}}}
    this.symbolLibs={}

    this.clipboardNodeStyle=null

    this.initStoredInformtion()
}

globalCache.prototype.checkTooLongIdle = function () {
    var previousTime=new Date().getTime()
    var maxDiff=10*60*1000

    var previousMouseDown=new Date().getTime()
    $(document).ready( ()=> {
        $(document).mousedown( (e)=> {
            previousMouseDown=new Date().getTime()
        });
    })

    setInterval(()=>{
        var currentTime=new Date().getTime()
        var diff1=currentTime-previousTime
        var diff2=currentTime-previousMouseDown
        if(diff1>maxDiff || diff2>maxDiff){
            //log out as it means the page just resumed from long time computer sleep
            this.stallPage()
        }
        previousTime=currentTime
    },60000)
}

globalCache.prototype.stallPage=function(){
    $('body').empty()
    for(var ind in global){
        if(ind=="location") continue
        try{
            global[ind]=null
        }catch(e){
            console.log(e)
        }
    } 

    const url = new URL(window.location.href);
    var destURL= url.origin+"/spaindex.html"
    window.location.replace(destURL);
}

globalCache.prototype.initStoredInformtion = function () {
    this.storedOutboundRelationships = {} 
    //stored data, seperately from ADT service and from cosmosDB service
    this.currentLayoutName=null   
}

globalCache.prototype.findProjectInfo=function(projectID){
    var joinedProjects=this.accountInfo.joinedProjects
    for(var i=0;i<joinedProjects.length;i++){
        var oneProject=joinedProjects[i]
        if(oneProject.id==projectID) return oneProject
    }
}


globalCache.prototype.storeADTTwins=function(twinsData){
    twinsData.forEach((oneNode)=>{this.storeSingleADTTwin(oneNode)});
}

globalCache.prototype.storeSingleADTTwin=function(oneNode){
    this.storedTwins[oneNode["$dtId"]] = oneNode
    oneNode["displayName"]= this.twinIDMapToDisplayName[oneNode["$dtId"]]
    //this.broadcastMessage({ "message": "ADTTwinInfoUpdate","twinID":oneNode["$dtId"]})
}


globalCache.prototype.storeSingleDBTwin=function(DBTwin){
    this.DBTwins[DBTwin["id"]]=DBTwin
    this.twinIDMapToDisplayName[DBTwin["id"]]=DBTwin["displayName"]
    this.twinDisplayNameMapToID[DBTwin["displayName"]]=DBTwin["id"]
}

globalCache.prototype.storeDBTwinsArr=function(DBTwinsArr){
    for(var ind in this.DBTwins) delete this.DBTwins[ind]
    for(var ind in this.twinIDMapToDisplayName) delete this.twinIDMapToDisplayName[ind]
    for(var ind in this.twinDisplayNameMapToID) delete this.twinDisplayNameMapToID[ind]

    this.mergeDBTwinsArr(DBTwinsArr)
}

globalCache.prototype.mergeDBTwinsArr=function(DBTwinsArr){
    DBTwinsArr.forEach(oneDBTwin=>{
        this.DBTwins[oneDBTwin["id"]]=oneDBTwin
        this.twinIDMapToDisplayName[oneDBTwin["id"]]=oneDBTwin["displayName"]
        this.twinDisplayNameMapToID[oneDBTwin["displayName"]]=oneDBTwin["id"]
    })
}

globalCache.prototype.storeUserData=function(res){
    res.forEach(oneResponse=>{
        if(oneResponse.type=="joinedProjectsToken") this.joinedProjectsToken=oneResponse.jwt;
        else if(oneResponse.type=="user") this.accountInfo=oneResponse
    })
}

globalCache.prototype.storeProjectModelsData=function(DBModels,adtModels){
    this.storeDBModelsArr(DBModels)

    for(var ind in this.modelIDMapToName) delete this.modelIDMapToName[ind]
    for(var ind in this.modelNameMapToID) delete this.modelNameMapToID[ind]

    var tmpNameToObj = {}
    for (var i = 0; i < adtModels.length; i++) {
        if (adtModels[i]["displayName"] == null) adtModels[i]["displayName"] = adtModels[i]["@id"]
        if ($.isPlainObject(adtModels[i]["displayName"])) {
            if (adtModels[i]["displayName"]["en"]) adtModels[i]["displayName"] = adtModels[i]["displayName"]["en"]
            else adtModels[i]["displayName"] = JSON.stringify(adtModels[i]["displayName"])
        }
        if (tmpNameToObj[adtModels[i]["displayName"]] != null) {
            //repeated model display name
            adtModels[i]["displayName"] = adtModels[i]["@id"]
        }
        tmpNameToObj[adtModels[i]["displayName"]] = 1

        this.modelIDMapToName[adtModels[i]["@id"]] = adtModels[i]["displayName"]
        this.modelNameMapToID[adtModels[i]["displayName"]] = adtModels[i]["@id"]
    }
}

globalCache.prototype.storeProjectTwinsAndVisualData=function(resArr){
    var dbtwins=[]
    for(var ind in this.visualDefinition) delete this.visualDefinition[ind]
    for(var ind in this.layoutJSON) delete this.layoutJSON[ind]
    this.visualDefinition["default"]={"detail":{}}

    resArr.forEach(element => {
        if(element.type=="visualSchema") {
            //TODO: now there is only one "default" schema to use,consider allow creating more user define visual schema
            //TODO: only choose the schema belongs to self
            this.recordSingleVisualSchema(element.detail,element.accountID,element.name,element.isShared)
        }else if(element.type=="Topology") {
            this.recordSingleLayout(element.detail,element.accountID,element.name,element.isShared)
        }else if(element.type=="DTTwin") dbtwins.push(element)
        else if(element.type=="symbols"){
            this.symbolLibs[element.displayName]=element.detail
        }
    });
    this.storeDBTwinsArr(dbtwins)

    resArr.forEach(element => {
        if(element.originalScript!=null) { 
            var twinID=element.twinID
            var oneDBTwin=this.DBTwins[twinID]
            if(oneDBTwin){
                oneDBTwin["originalScript"]=element["originalScript"]
                oneDBTwin["lastExecutionTime"]=element["lastExecutionTime"]
                oneDBTwin["author"]=element["author"]
                oneDBTwin["invalidFlag"]=element["invalidFlag"]
                oneDBTwin["inputs"]=element["inputs"]
                oneDBTwin["outputs"]=element["outputs"]

            }
        }
    });
}

globalCache.prototype.recordSingleVisualSchema=function(detail,accountID,oname,isShared){
    if (accountID == this.accountInfo.id) var vsName = oname
    else vsName = oname + `(from ${accountID})`
    var dict = { "detail": detail, "isShared": isShared, "owner": accountID, "oname": oname}
    this.visualDefinition[vsName]=dict
}

globalCache.prototype.recordSingleLayout=function(detail,accountID,oname,isShared){
    if (accountID == this.accountInfo.id) var layoutName = oname
    else layoutName = oname + `(from ${accountID})`
    var dict = { "detail": detail, "isShared": isShared, "owner": accountID, "name": layoutName, "oname":oname }
    this.layoutJSON[layoutName] = dict
}

globalCache.prototype.getDBTwinsByModelID=function(modelID){
    var resultArr=[]
    for(var ind in this.DBTwins){
        var ele=this.DBTwins[ind]
        if(ele.modelID==modelID){
            resultArr.push(ele)
        }
    }
    return resultArr;
}

globalCache.prototype.getSingleDBTwinByName=function(twinName){
    var twinID=this.twinDisplayNameMapToID[twinName]
    return this.DBTwins[twinID]
}

globalCache.prototype.getSingleDBTwinByIndoorFeatureID=function(featureID){
    for(var ind in this.DBTwins){
        var ele=this.DBTwins[ind]
        if(ele.GIS && ele.GIS.indoor){
            if(ele.GIS.indoor.IndoorFeatureID==featureID) return ele
        }
    }
    return null;
}

globalCache.prototype.getSingleDBModelByID=function(modelID){
    for(var i=0;i<this.DBModelsArr.length;i++){
        var ele = this.DBModelsArr[i]
        if(ele.id==modelID){
            return ele
        }
    }
    return null;
}

globalCache.prototype.storeSingleDBModel=function(singleDBModelInfo){
    var modelID = singleDBModelInfo.id
    for(var i=0;i<this.DBModelsArr.length;i++){
        var ele = this.DBModelsArr[i]
        if(ele.id==modelID){
            for(var ind in ele) delete ele[ind]
            for(var ind in singleDBModelInfo) ele[ind]=singleDBModelInfo[ind]
            return;
        }
    }
    //it is a new single model if code reaches here
    this.DBModelsArr.push(singleDBModelInfo)
    this.sortDBModelsArr()
}

globalCache.prototype.storeDBModelsArr=function(DBModelsArr){
    this.DBModelsArr.length=0
    this.DBModelsArr=this.DBModelsArr.concat(DBModelsArr)
    this.sortDBModelsArr()
    
}
globalCache.prototype.sortDBModelsArr=function(){
    this.DBModelsArr.sort(function (a, b) { 
        var aName=a.displayName.toLowerCase()
        var bName=b.displayName.toLowerCase()
        return aName.localeCompare(bName) 
    });
}


globalCache.prototype.getStoredAllInboundRelationsSources=function(twinID){
    var srcTwins={}
    for(var srcTwin in this.storedOutboundRelationships){
        var arr=this.storedOutboundRelationships[srcTwin]
        arr.forEach(oneRelation=>{
            if(oneRelation["$targetId"]==twinID) srcTwins[oneRelation["$sourceId"]]=1
        })
    }
    return srcTwins;
}

globalCache.prototype.storeTwinRelationships=function(relationsData){
    relationsData.forEach((oneRelationship)=>{
        var twinID=oneRelationship['$sourceId']
        this.storedOutboundRelationships[twinID]=[]
    })

    relationsData.forEach((oneRelationship)=>{
        this.storedOutboundRelationships[oneRelationship['$sourceId']].push(oneRelationship)
    })
}

globalCache.prototype.storeTwinRelationships_append=function(relationsData){
    relationsData.forEach((oneRelationship)=>{
        if(!this.storedOutboundRelationships[oneRelationship['$sourceId']])
            this.storedOutboundRelationships[oneRelationship['$sourceId']]=[]
        this.storedOutboundRelationships[oneRelationship['$sourceId']].push(oneRelationship)
    })
}

globalCache.prototype.storeTwinRelationships_remove=function(relationsData){
    relationsData.forEach((oneRelationship)=>{
        var srcID=oneRelationship["srcID"]
        if(this.storedOutboundRelationships[srcID]){
            var arr=this.storedOutboundRelationships[srcID]
            for(var i=0;i<arr.length;i++){
                if(arr[i]['$relationshipId']==oneRelationship["relID"]){
                    arr.splice(i,1)
                    break;
                }
            }
        }
    })
}

globalCache.prototype.findAllInputsInScript=function(calcScript,formulaTwinName){
    //find all properties in the script
    calcScript+="\n" //make sure the below patterns using "[^. ] not fail because of it is the end of string "
    var patt = /_self(?<=_self)\[\".*?(?=\"\][^\[])\"\]/g; 
    var allSelfProperties=calcScript.match(patt)||[];
    var countAllSelfTimes={}
    allSelfProperties.forEach(oneSelf=>{
        if(countAllSelfTimes[oneSelf]) countAllSelfTimes[oneSelf]+=1
        else countAllSelfTimes[oneSelf]=1
    })

    var patt = /_twinVal(?<=_twinVal)\[\".*?(?=\"\][^\[])\"\]/g; 
    var allOtherTwinProperties=calcScript.match(patt)||[];
    var listAllOthers={}
    allOtherTwinProperties.forEach(oneOther=>{listAllOthers[oneOther]=1 })

    //analyze all variables that can not be as input as they are changed during calcuation
    //they disqualify as input as they will trigger infinite calculation, all these belongs to _self
    var outputpatt = /_self(?<=_self)\[\"[^;{]*?[^\=](?=\=[^\=])/g;
    var outputProperties=calcScript.match(outputpatt)||[];
    var countOutputTimes={}
    outputProperties.forEach(oneOutput=>{
        if(countOutputTimes[oneOutput]) countOutputTimes[oneOutput]+=1
        else countOutputTimes[oneOutput]=1
    })
    

    var inputPropertiesArr=[]
    for(var ind in listAllOthers) inputPropertiesArr.push(ind)
    for(var ind in countAllSelfTimes){
        if(countAllSelfTimes[ind]!=countOutputTimes[ind]) inputPropertiesArr.push(ind)
    }

    var returnArr=[]
    inputPropertiesArr.forEach(oneProperty=>{
        var oneInputObj={} //twinID, path, value
        var fetchpropertypatt = /(?<=\[\").*?(?=\"\])/g;
        if(oneProperty.startsWith("_self")){
            oneInputObj.path=oneProperty.match(fetchpropertypatt);
            oneInputObj.twinName=formulaTwinName+"(self)"
            oneInputObj.twinName_origin=formulaTwinName
            var twinID=this.twinDisplayNameMapToID[formulaTwinName]
            oneInputObj.value=this.searchValue(this.storedTwins[twinID],oneInputObj.path)
        }else if(oneProperty.startsWith("_twinVal")){
            var arr=oneProperty.match(fetchpropertypatt);
            var firstEle=arr[0]
            arr.shift()
            oneInputObj.path=arr
            var twinID=this.twinDisplayNameMapToID[firstEle]
            oneInputObj.value=this.searchValue(this.storedTwins[twinID],oneInputObj.path)
            oneInputObj.twinName=oneInputObj.twinName_origin=firstEle
        }
        returnArr.push(oneInputObj)
    })
    return returnArr
}

globalCache.prototype.searchValue=function(originElementInfo,pathArr){
    if(pathArr.length==0) return null;
    var theJson=originElementInfo
    for(var i=0;i<pathArr.length;i++){
        var key=pathArr[i]
        theJson=theJson[key]
        if(theJson==null) return null;
    }
    return theJson //it should be the final value
}

globalCache.prototype.shapeSvg=function(shape,color,secondColor){
    var svgStart='<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="none" version="1.1" >'
    if(secondColor){
        if(color=="none") color="darkGray" 
        var gradientDefinition='<defs>'+
            '<linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">'+
            '<stop offset="0%" style="stop-color:'+color+';stop-opacity:1" />'+
            '<stop offset="50%" style="stop-color:'+color+';stop-opacity:1" />'+
            '<stop offset="51%" style="stop-color:'+secondColor+';stop-opacity:1" />'+
            '</linearGradient></defs>'
        svgStart+=gradientDefinition
    }
    var colorStr=(secondColor)?"url(#grad1)":color
    if(shape=="ellipse"){
        return svgStart+'<circle cx="50" cy="50" r="50"  fill="'+colorStr+'"/></svg>'
    }else if(shape=="hexagon"){
        return svgStart+'<polygon points="50 0, 93.3 25, 93.3 75, 50 100, 6.7 75, 6.7 25"  fill="'+colorStr+'" /></svg>'
    }else if(shape=="rectangle"){
        return svgStart+'<rect x="10" y="10" rx="10" ry="10" width="80" height="80" fill="'+colorStr+'" /></svg>'
    }
}

globalCache.prototype.makeDOMDraggable=function(dom,ignoreChildDomType){
    ignoreChildDomType=ignoreChildDomType||["LABEL","TD","B","A","INPUT","PRE"]
    dom.on('mousedown',(e)=>{
        if(ignoreChildDomType.indexOf(e.target.tagName)!=-1) return;
        var domOffset=dom.offset()
        dom.mouseStartDragOffset=[domOffset.left-e.clientX, domOffset.top-e.clientY]
        $('body').on('mouseup',()=>{
            dom.mouseStartDragOffset=null
            $('body').off('mousemove')
            $('body').off('mouseup')
        })
        $('body').on('mousemove',(e)=>{
            e.preventDefault()
            if(dom.mouseStartDragOffset){
                var newLeft= e.clientX+dom.mouseStartDragOffset[0]
                var newTop=e.clientY+dom.mouseStartDragOffset[1]
                dom.css({"left":newLeft+"px","top":newTop+"px","transform":"none"})
            }
        })
    })
}

globalCache.prototype.generateModelIcon = function (modelID,dimension,isFixSize) {
    var dbModelInfo = this.getSingleDBModelByID(modelID)
    var colorCode = "darkGray"
    var shape = "ellipse"
    var avarta = null
    dimension = dimension||20;
    if (this.visualDefinition["default"].detail[modelID]) {
        var visualJson = this.visualDefinition["default"].detail[modelID]
        var colorCode = visualJson.color || "darkGray"
        var secondColorCode = visualJson.secondColor
        var shape = visualJson.shape || "ellipse"
        var avarta = visualJson.avarta
        if(!isFixSize){
            if (visualJson.dimensionRatio) dimension *= parseFloat(visualJson.dimensionRatio)
            if (dimension > 60) dimension = 60    
        }
    }
    var iconDOMDimension = Math.max(dimension, 20) //other wise it is too small to be in vertical middle of parent div
    var iconDOM = $("<div style='width:" + iconDOMDimension + "px;height:" + iconDOMDimension + "px;float:left;position:relative'></div>")
    if (dbModelInfo && dbModelInfo.isIoTDeviceModel) {
        var iotDiv = $("<div class='w3-border' style='position:absolute;right:-5px;padding:0px 2px;top:-7px;border-radius: 3px;font-size:7px'>IoT</div>")
        iconDOM.append(iotDiv)
    }

    var imgSrc = encodeURIComponent(this.shapeSvg(shape, colorCode, secondColorCode))
    var shapeImg = $("<img src='data:image/svg+xml;utf8," + imgSrc + "'></img>")
    shapeImg.css({ "width": dimension + "px", "height": dimension + "px" })
    if (dimension < iconDOMDimension) {
        shapeImg.css({ "position": "absolute", "top": (iconDOMDimension - dimension) / 2 + "px", "left": (iconDOMDimension - dimension) / 2 + "px" })
    }
    iconDOM.append(shapeImg)
    if (avarta) {
        var avartaimg = $(`<img style='max-width:${dimension * 0.75}px;max-height:${dimension * 0.75}px;position:absolute;left:50%;top:50%;transform:translateX(-50%) translateY(-50%)' src='${avarta}'></img>`)
        iconDOM.append(avartaimg)
    }
    return iconDOM
}

globalCache.prototype.uuidv4=function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

module.exports = new globalCache();
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],22:[function(require,module,exports){
const msalHelper=require("../msalHelper")
//This is a singleton class

function modelAnalyzer(){
    this.DTDLModels={}
    this.relationshipTypes={}
}

modelAnalyzer.prototype.clearAllModels=function(){
    //console.log("clear all model info")
    for(var id in this.DTDLModels) delete this.DTDLModels[id]
}

modelAnalyzer.prototype.resetAllModels=function(){
    for(var modelID in this.DTDLModels){
        var jsonStr=this.DTDLModels[modelID]["original"]
        this.DTDLModels[modelID]=JSON.parse(jsonStr)
        this.DTDLModels[modelID]["original"]=jsonStr
    }
}


modelAnalyzer.prototype.addModels=function(arr){
    arr.forEach((ele)=>{
        var modelID= ele["@id"]
        ele["original"]=JSON.stringify(ele)
        this.DTDLModels[modelID]=ele
    })
}


modelAnalyzer.prototype.recordAllBaseClasses= function (parentObj, baseClassID) {
    var baseClass = this.DTDLModels[baseClassID]
    if (baseClass == null) return;

    parentObj[baseClassID]=1

    var furtherBaseClassIDs = baseClass.extends;
    if (furtherBaseClassIDs == null) return;
    if(Array.isArray(furtherBaseClassIDs)) var tmpArr=furtherBaseClassIDs
    else tmpArr=[furtherBaseClassIDs]
    tmpArr.forEach((eachBase) => { this.recordAllBaseClasses(parentObj, eachBase) })
}

modelAnalyzer.prototype.expandEditablePropertiesFromBaseClass = function (parentObj, baseClassID) {
    var baseClass = this.DTDLModels[baseClassID]
    if (baseClass == null) return;
    if (baseClass.editableProperties) {
        for (var ind in baseClass.editableProperties) parentObj[ind] = baseClass.editableProperties[ind]
    }
    var furtherBaseClassIDs = baseClass.extends;
    if (furtherBaseClassIDs == null) return;
    if(Array.isArray(furtherBaseClassIDs)) var tmpArr=furtherBaseClassIDs
    else tmpArr=[furtherBaseClassIDs]
    tmpArr.forEach((eachBase) => { this.expandEditablePropertiesFromBaseClass(parentObj, eachBase) })
}

modelAnalyzer.prototype.expandValidRelationshipTypesFromBaseClass = function (parentObj, baseClassID) {
    var baseClass = this.DTDLModels[baseClassID]
    if (baseClass == null) return;
    if (baseClass.validRelationships) {
        for (var ind in baseClass.validRelationships) {
            if(parentObj[ind]==null) parentObj[ind] = this.relationshipTypes[ind][baseClassID]
        }
    }
    var furtherBaseClassIDs = baseClass.extends;
    if (furtherBaseClassIDs == null) return;
    if(Array.isArray(furtherBaseClassIDs)) var tmpArr=furtherBaseClassIDs
    else tmpArr=[furtherBaseClassIDs]
    tmpArr.forEach((eachBase) => { this.expandValidRelationshipTypesFromBaseClass(parentObj, eachBase) })
}

modelAnalyzer.prototype.expandEditableProperties=function(parentObj,dataInfo,embeddedSchema){
    dataInfo.forEach((oneContent)=>{
        if(oneContent["@type"]=="Relationship") return;
        if(oneContent["@type"]=="Property"
        ||(Array.isArray(oneContent["@type"]) && oneContent["@type"].includes("Property"))
        || oneContent["@type"]==null) {
            if(typeof(oneContent["schema"]) != 'object' && embeddedSchema[oneContent["schema"]]!=null) oneContent["schema"]=embeddedSchema[oneContent["schema"]]

            if(typeof(oneContent["schema"]) === 'object' && oneContent["schema"]["@type"]=="Object"){
                var newParent={}
                parentObj[oneContent["name"]]=newParent
                this.expandEditableProperties(newParent,oneContent["schema"]["fields"],embeddedSchema)
            }else if(typeof(oneContent["schema"]) === 'object' && oneContent["schema"]["@type"]=="Enum"){
                parentObj[oneContent["name"]]=oneContent["schema"]["enumValues"]
            }else{
                parentObj[oneContent["name"]]=oneContent["schema"]
            }           
        }
    })
}


modelAnalyzer.prototype.analyze=function(){
    //console.log("analyze model info")
    //analyze all relationship types
    for (var id in this.relationshipTypes) delete this.relationshipTypes[id]
    for (var modelID in this.DTDLModels) {
        var ele = this.DTDLModels[modelID]
        var embeddedSchema = {}
        if (ele.schemas) {
            var tempArr;
            if (Array.isArray(ele.schemas)) tempArr = ele.schemas
            else tempArr = [ele.schemas]
            tempArr.forEach((ele) => {
                embeddedSchema[ele["@id"]] = ele
            })
        }

        var contentArr = ele.contents
        if (!contentArr) continue;
        contentArr.forEach((oneContent) => {
            if (oneContent["@type"] == "Relationship") {
                if(!this.relationshipTypes[oneContent["name"]]) this.relationshipTypes[oneContent["name"]]= {}
                this.relationshipTypes[oneContent["name"]][modelID] = oneContent
                oneContent.editableRelationshipProperties = {}
                if (Array.isArray(oneContent.properties)) {
                    this.expandEditableProperties(oneContent.editableRelationshipProperties, oneContent.properties, embeddedSchema)
                }
            }
        })
    }

    //analyze each model's property that can be edited
    for(var modelID in this.DTDLModels){ //expand possible embedded schema to editableProperties, also extract possible relationship types for this model
        var ele=this.DTDLModels[modelID]
        var embeddedSchema={}
        if(ele.schemas){
            var tempArr;
            if(Array.isArray(ele.schemas)) tempArr=ele.schemas
            else tempArr=[ele.schemas]
            tempArr.forEach((ele)=>{
                embeddedSchema[ele["@id"]]=ele
            })
        }
        ele.editableProperties={}
        ele.validRelationships={}
        ele.includedComponents=[]
        ele.allBaseClasses={}
        if(Array.isArray(ele.contents)){
            this.expandEditableProperties(ele.editableProperties,ele.contents,embeddedSchema)

            ele.contents.forEach((oneContent)=>{
                if(oneContent["@type"]=="Relationship") {
                    ele.validRelationships[oneContent["name"]]=this.relationshipTypes[oneContent["name"]][modelID]
                }
            })
        }
    }

    for(var modelID in this.DTDLModels){//expand component properties
        var ele=this.DTDLModels[modelID]
        if(Array.isArray(ele.contents)){
            ele.contents.forEach(oneContent=>{
                if(oneContent["@type"]=="Component"){
                    var componentName=oneContent["name"]
                    var componentClass=oneContent["schema"]
                    ele.editableProperties[componentName]={}
                    this.expandEditablePropertiesFromBaseClass(ele.editableProperties[componentName],componentClass)
                    ele.includedComponents.push(componentName)
                } 
            })
        }
    }

    for(var modelID in this.DTDLModels){//expand base class properties to editableProperties and valid relationship types to validRelationships
        var ele=this.DTDLModels[modelID]
        var baseClassIDs=ele.extends;
        if(baseClassIDs==null) continue;
        if(Array.isArray(baseClassIDs)) var tmpArr=baseClassIDs
        else tmpArr=[baseClassIDs]
        tmpArr.forEach((eachBase)=>{
            this.recordAllBaseClasses(ele.allBaseClasses,eachBase)
            this.expandEditablePropertiesFromBaseClass(ele.editableProperties,eachBase)
            this.expandValidRelationshipTypesFromBaseClass(ele.validRelationships,eachBase)
        })
    }

    //console.log(this.DTDLModels)
    //console.log(this.relationshipTypes)
}

modelAnalyzer.prototype.listModelsForDeleteModel=function(modelID){
    var childModelIDs=[]
    for(var aID in this.DTDLModels){
        var aModel=this.DTDLModels[aID]
        if(aModel.allBaseClasses && aModel.allBaseClasses[modelID]) childModelIDs.push(aModel["@id"])
    }
    return childModelIDs
}

modelAnalyzer.prototype.deleteModel=async function(modelID,funcAfterEachSuccessDelete,funcAfterFail,completeFunc){
    var relatedModelIDs=this.listModelsForDeleteModel(modelID)
    var modelLevel=[]
    relatedModelIDs.forEach(oneID=>{
        var checkModel=this.DTDLModels[oneID]
        modelLevel.push({"modelID":oneID,"level":Object.keys(checkModel.allBaseClasses).length})
    })
    modelLevel.push({"modelID":modelID,"level":0})
    modelLevel.sort(function (a, b) {return b["level"]-a["level"] });
    
    for(var i=0;i<modelLevel.length;i++){
        var aModelID=modelLevel[i].modelID
        try{
            await msalHelper.callAPI("digitaltwin/deleteModel", "POST", { "model": aModelID },"withProjectID")
            delete this.DTDLModels[aModelID]
            if(funcAfterEachSuccessDelete) funcAfterEachSuccessDelete(aModelID)
        }catch(e){
            var deletedModels=[]
            var alertStr="Delete model is incomplete. Deleted Model:"
            for(var j=0;j<i;j++){
                alertStr+= modelLevel[j].modelID+" "
                deletedModels.push(modelLevel[j].modelID)
            } 
            alertStr+=". Fail to delete "+aModelID+". Error is "+e
            if(funcAfterFail) funcAfterFail(deletedModels)
            alert(e)
        }
    }
    if(completeFunc) completeFunc()
}


modelAnalyzer.prototype.fetchPropertyPathsOfModel=function(modelID){
    var properties=this.DTDLModels[modelID].editableProperties
    var propertyPaths=[]
    this.analyzePropertyPath(properties,[],propertyPaths)
    return propertyPaths
}

modelAnalyzer.prototype.analyzePropertyPath=function (jsonInfo,pathArr,propertyPaths){
    for(var ind in jsonInfo){
        var newPath=pathArr.concat([ind])
        if(!Array.isArray(jsonInfo[ind]) && typeof(jsonInfo[ind])==="object") {
            this.analyzePropertyPath(jsonInfo[ind],newPath,propertyPaths)
        }else {
            propertyPaths.push(newPath)
        }
    }
}

module.exports = new modelAnalyzer();
},{"../msalHelper":18}],23:[function(require,module,exports){
const modelAnalyzer=require("./modelAnalyzer")
const simpleSelectMenu= require("./simpleSelectMenu")
const msalHelper=require("../msalHelper")
const simpleConfirmDialog=require("./simpleConfirmDialog")
const globalCache=require("./globalCache")

function modelEditorDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:100" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

modelEditorDialog.prototype.popup = async function() {
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:665px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Digital Twin Model Editor</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var buttonRow=$('<div  style="height:40px" class="w3-bar"></div>')
    this.contentDOM.append(buttonRow)
    var importButton =$('<button class="w3-button w3-card w3-deep-orange w3-hover-light-green w3-right" style="height:100%">Import</button>')
    this.importButton=importButton
    buttonRow.append(importButton)

    importButton.on("click", async () => {
        var currentModelID=this.dtdlobj["@id"]
        if(modelAnalyzer.DTDLModels[currentModelID]==null) this.importModelArr([this.dtdlobj])
        else this.replaceModel()       
    })

    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;font-size:1.2em;">Model Template</div>')
    buttonRow.append(lable)
    var modelTemplateSelector=new simpleSelectMenu(" ",{withBorder:1,fontSize:"1.2em",colorClass:"w3-light-gray",buttonCSS:{"padding":"5px 10px"},"optionListHeight":300})
    buttonRow.append(modelTemplateSelector.DOM)
    modelTemplateSelector.callBack_clickOption=(optionText,optionValue)=>{
        modelTemplateSelector.changeName(optionText)
        this.chooseTemplate(optionValue)
    }
    modelTemplateSelector.addOption("New Model...","New")
    for(var modelName in modelAnalyzer.DTDLModels){
        modelTemplateSelector.addOption(modelName)
    }

    var panelHeight="450px"
    var row2=$('<div class="w3-cell-row" style="margin:2px"></div>')
    this.contentDOM.append(row2)
    var leftSpan=$('<div class="w3-card" style="padding:5px;width:330px;padding-right:5px;height:'+panelHeight+';overflow:auto"></div>')
    row2.append(leftSpan)
    this.leftSpan=leftSpan

    var rightSpan=$('<div class="w3-container w3-cell"></div>')
    row2.append(rightSpan) 
    var dtdlScriptPanel=$('<div class="w3-card-2 w3-white" style="overflow:auto;margin-top:2px;width:310px;height:'+panelHeight+'"></div>')
    rightSpan.append(dtdlScriptPanel)
    this.dtdlScriptPanel=dtdlScriptPanel

    modelTemplateSelector.triggerOptionIndex(0)
}

modelEditorDialog.prototype.replaceModel=function(){
    //delete the old same name model, then create it again
    var currentModelID=this.dtdlobj["@id"]

    var relatedModelIDs=modelAnalyzer.listModelsForDeleteModel(currentModelID)

    var dialogStr = (relatedModelIDs.length == 0) ? ("Twins will be impact under model \"" + currentModelID + "\"") :
        (currentModelID + " is base model of " + relatedModelIDs.join(", ") + ". Twins under these models will be impact.")
    var confirmDialogDiv = new simpleConfirmDialog()
    confirmDialogDiv.show(
        { width: "350px" },
        {
            title: "Warning"
            , content: dialogStr
            , buttons: [
                {
                    colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": () => {
                        confirmDialogDiv.close();
                        this.confirmReplaceModel(currentModelID)
                    }
                },
                {
                    colorClass: "w3-gray", text: "Cancel", "clickFunc": () => {
                        confirmDialogDiv.close()
                    }
                }
            ]
        }
    )    
}

modelEditorDialog.prototype.importModelArr=async function(modelToBeImported,forReplacing,afterFailure){
    try {
        await msalHelper.callAPI("digitaltwin/importModels", "POST", { "models": JSON.stringify(modelToBeImported) },"withProjectID")
        if(forReplacing) alert("Model " + this.dtdlobj["displayName"] + " is modified successfully!")
        else alert("Model " + this.dtdlobj["displayName"] + " is created!")

        this.broadcastMessage({ "message": "ADTModelEdited" })
        modelAnalyzer.addModels(modelToBeImported) //add so immediatley the list can show the new models
        this.popup() //refresh content
    }catch(e){
        if(afterFailure) afterFailure()
        console.log(e)
        if(e.responseText) alert(e.responseText)
    } 
}

modelEditorDialog.prototype.confirmReplaceModel=function(modelID){
    var relatedModelIDs=modelAnalyzer.listModelsForDeleteModel(modelID)
    var backupModels=[]
    relatedModelIDs.forEach(oneID=>{
        backupModels.push(JSON.parse(modelAnalyzer.DTDLModels[oneID]["original"]))
    })
    backupModels.push(this.dtdlobj)
    var backupModelsStr=encodeURIComponent(JSON.stringify(backupModels))

    var funcAfterFail=(deletedModelIDs)=>{
        var pom = $("<a></a>")
        pom.attr('href', 'data:text/plain;charset=utf-8,' + backupModelsStr);
        pom.attr('download', "exportModelsAfterFailedOperation.json");
        pom[0].click()
    }
    var funcAfterEachSuccessDelete = (eachDeletedModelID,eachModelName) => {}
    
    var completeFunc=()=>{ 
        //import all the models again
        this.importModelArr(backupModels,"forReplacing",funcAfterFail)
    }
    modelAnalyzer.deleteModel(modelID,funcAfterEachSuccessDelete,funcAfterFail,completeFunc)
}



modelEditorDialog.prototype.chooseTemplate=function(tempalteName){
    if(tempalteName!="New"){
        this.dtdlobj=JSON.parse(modelAnalyzer.DTDLModels[tempalteName]["original"])
    }else{
        this.dtdlobj = {
            "@id": "dtmi:aNameSpace:aModelID;1",
            "@context": ["dtmi:dtdl:context;2"],
            "@type": "Interface",
            "displayName": "New Model",
            "contents": [
                {
                    "@type": "Property",
                    "name": "attribute1",
                    "schema": "double"
                },{
                    "@type": "Relationship",
                    "name": "link"
                }
            ]
        }
    }
    this.leftSpan.empty()

    this.refreshDTDL()
    this.leftSpan.append($('<div class="w3-bar"><div class="w3-bar-item w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Model ID & Name<p style="position:absolute;text-align:left;font-weight:normal;top:-10px;width:200px" class="w3-text w3-tag w3-tiny">model ID contains namespace, a model string and a version number</p></div></div>'))
    new idRow(this.dtdlobj,this.leftSpan,()=>{this.refreshDTDL()})
    new displayNameRow(this.dtdlobj,this.leftSpan,()=>{this.refreshDTDL()})

    if(!this.dtdlobj["contents"])this.dtdlobj["contents"]=[]
    new parametersRow(this.dtdlobj["contents"],this.leftSpan,()=>{this.refreshDTDL()},this.DOM.offset())
    new relationsRow(this.dtdlobj["contents"],this.leftSpan,()=>{this.refreshDTDL()},this.DOM.offset())
    new componentsRow(this.dtdlobj["contents"],this.leftSpan,()=>{this.refreshDTDL()})

    if(!this.dtdlobj["extends"])this.dtdlobj["extends"]=[]
    new baseClassesRow(this.dtdlobj["extends"],this.leftSpan,()=>{this.refreshDTDL()})
}

modelEditorDialog.prototype.refreshDTDL=function(){
    //it will refresh the generated DTDL sample, it will also change the import button to show "Create" or "Modify"
    var currentModelID=this.dtdlobj["@id"]
    if(modelAnalyzer.DTDLModels[currentModelID]==null) this.importButton.text("Create")
    else this.importButton.text("Modify")

    this.dtdlScriptPanel.empty()
    this.dtdlScriptPanel.append($('<div style="height:20px;width:100px" class="w3-bar w3-gray">Generated DTDL</div>'))
    this.dtdlScriptPanel.append($('<pre style="color:gray">'+JSON.stringify(this.dtdlobj,null,2)+'</pre>'))
}

module.exports = new modelEditorDialog();


function baseClassesRow(dtdlObj,parentDOM,refreshDTDLF){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item  w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Base Classes<p style="position:absolute;text-align:left;top:-10px;font-weight:normal;width:200px" class="w3-text w3-tag w3-tiny">Base class model\'s parameters and relationship type are inherited</p></div></div>')

    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)
    addButton.on("click",()=>{
        var newObj = "unknown"
        dtdlObj.push(newObj)
        new singleBaseclassRow(newObj,contentDOM,refreshDTDLF,dtdlObj)
        refreshDTDLF()
    })
    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        new singleBaseclassRow(element,contentDOM,refreshDTDLF,dtdlObj)
    });
}

function singleBaseclassRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj){
    var DOM = $('<div class="w3-cell-row"></div>')
    var baseClassNameInput=$('<input type="text" style="outline:none;display:inline;width:220px;padding:4px"  placeholder="base model id"/>').addClass("w3-bar-item w3-input w3-border");
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    DOM.append(baseClassNameInput,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] == dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })

    parentDOM.append(DOM)

    baseClassNameInput.val(dtdlObj)
    baseClassNameInput.on("change",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] == dtdlObj) {
                parentDtdlObj[i]=baseClassNameInput.val()
                break;
            }
        }
        refreshDTDLF()
    })
}

function componentsRow(dtdlObj,parentDOM,refreshDTDLF){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item  w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Components<p style="position:absolute;text-align:left;top:-10px;font-weight:normal;width:200px" class="w3-text w3-tag w3-tiny">Component model\'s parameters are embedded under a name</p></div></div>')

    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)

    addButton.on("click",()=>{
        var newObj = {
            "@type": "Component",
            "name": "SomeComponent",
            "schema":"dtmi:someComponentModel;1"
        }
        dtdlObj.push(newObj)
        new singleComponentRow(newObj,contentDOM,refreshDTDLF,dtdlObj)
        refreshDTDLF()
    })
    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        if(element["@type"]!="Component") return
        new singleComponentRow(element,contentDOM,refreshDTDLF,dtdlObj)
    });
}

function singleComponentRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj){
    var DOM = $('<div class="w3-cell-row"></div>')
    var componentNameInput=$('<input type="text" style="outline:none;display:inline;width:100px;padding:4px"  placeholder="component name"/>').addClass("w3-bar-item w3-input w3-border");
    var schemaInput=$('<input type="text" style="outline:none;display:inline;width:160px;padding:4px"  placeholder="component model id..."/>').addClass("w3-bar-item w3-input w3-border");
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    DOM.append(componentNameInput,schemaInput,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] === dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })

    parentDOM.append(DOM)

    componentNameInput.val(dtdlObj["name"])
    schemaInput.val(dtdlObj["schema"]||"")

    componentNameInput.on("change",()=>{
        dtdlObj["name"]=componentNameInput.val()
        refreshDTDLF()
    })
    schemaInput.on("change",()=>{
        dtdlObj["schema"]=schemaInput.val()
        refreshDTDLF()
    })
}

function relationsRow(dtdlObj,parentDOM,refreshDTDLF,dialogOffset){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item w3-tooltip" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Relationship Types<p style="position:absolute;text-align:left;top:-10px;font-weight:normal;width:200px" class="w3-text w3-tag w3-tiny">Relationship can have its own parameters</p></div></div>')


    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)

    addButton.on("click",()=>{
        var newObj = {
            "@type": "Relationship",
            "name": "relation1",
        }
        dtdlObj.push(newObj)
        new singleRelationTypeRow(newObj,contentDOM,refreshDTDLF,dtdlObj,dialogOffset)
        refreshDTDLF()
    })

    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        if(element["@type"]!="Relationship") return
        new singleRelationTypeRow(element,contentDOM,refreshDTDLF,dtdlObj,dialogOffset)
    });
}

function singleRelationTypeRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj,dialogOffset){
    var DOM = $('<div class="w3-cell-row"></div>')
    var relationNameInput=$('<input type="text" style="outline:none;display:inline;width:90px;padding:4px"  placeholder="relation name"/>').addClass("w3-bar-item w3-input w3-border");
    var targetModelID=$('<input type="text" style="outline:none;display:inline;width:140px;padding:4px"  placeholder="(optional)target model"/>').addClass("w3-bar-item w3-input w3-border");
    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-cog fa-lg"></i></button>')
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    DOM.append(relationNameInput,targetModelID,addButton,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] === dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })

    var contentDOM=$('<div style="padding-left:10px"></div>')
    DOM.append(contentDOM)
    parentDOM.append(DOM)

    relationNameInput.val(dtdlObj["name"])
    targetModelID.val(dtdlObj["target"]||"")

    addButton.on("click",()=>{
        if(! dtdlObj["properties"]) dtdlObj["properties"]=[]
        var newObj = {
            "name": "newP",
            "schema": "double"
        }
        dtdlObj["properties"].push(newObj)
        new singleParameterRow(newObj,contentDOM,refreshDTDLF,dtdlObj["properties"],null,dialogOffset)
        refreshDTDLF()
    })

    relationNameInput.on("change",()=>{
        dtdlObj["name"]=relationNameInput.val()
        refreshDTDLF()
    })
    targetModelID.on("change",()=>{
        if(targetModelID.val()=="") delete dtdlObj["target"]
        else dtdlObj["target"]=targetModelID.val()
        refreshDTDLF()
    })
    if(dtdlObj["properties"] && dtdlObj["properties"].length>0){
        var properties=dtdlObj["properties"]
        properties.forEach(oneProperty=>{
            new singleParameterRow(oneProperty,contentDOM,refreshDTDLF,dtdlObj["properties"],null,dialogOffset)
        })
    }
}

function parametersRow(dtdlObj,parentDOM,refreshDTDLF,dialogOffset){
    var rowDOM=$('<div class="w3-bar"><div class="w3-bar-item" style="font-size:1.2em;padding-left:2px;font-weight:bold;color:gray">Parameters</div></div>')
    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-red w3-hover-amber" style="margin-top:2px;font-size:1.2em;padding:4px 8px">+</button>')
    rowDOM.append(addButton)
    parentDOM.append(rowDOM)
    var contentDOM=$('<div style="padding-left:10px"></div>')
    rowDOM.append(contentDOM)
    addButton.on("click",()=>{
        var newObj = {
            "@type": "Property",
            "name": "newP",
            "schema": "double"
        }
        dtdlObj.push(newObj)
        new singleParameterRow(newObj,contentDOM,refreshDTDLF,dtdlObj,"topLevel",dialogOffset)
        refreshDTDLF()
    })

    //check existed content initially from template and trigger their drawing
    dtdlObj.forEach(element => {
        if(element["@type"]!="Property") return
        new singleParameterRow(element,contentDOM,refreshDTDLF,dtdlObj,"topLevel",dialogOffset)
    });
}

function singleParameterRow(dtdlObj,parentDOM,refreshDTDLF,parentDtdlObj,topLevel,dialogOffset){
    var DOM = $('<div class="w3-cell-row"></div>')
    var parameterNameInput=$('<input type="text" style="outline:none;display:inline;width:100px;padding:4px"  placeholder="parameter name"/>').addClass("w3-bar-item w3-input w3-border");
    var enumValueInput=$('<input type="text" style="outline:none;display:inline;width:100px;padding:4px"  placeholder="str1,str2,..."/>').addClass("w3-bar-item w3-input w3-border");
    var addButton = $('<button class="w3-ripple w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-plus fa-lg"></i></button>')
    var removeButton = $('<button class="w3-bar-item w3-button w3-hover-amber" style="color:gray;margin-left:3px;margin-top:2px;font-size:1.2em;padding:2px"><i class="fa fa-trash fa-lg"></i></button>')
    var ptypeSelector=new simpleSelectMenu(" ",{withBorder:1,fontSize:"1em",colorClass:"w3-light-gray w3-bar-item",buttonCSS:{"padding":"4px 5px"},"optionListHeight":300,"isClickable":1,"optionListMarginTop":-150,"optionListMarginLeft":60,
    "adjustPositionAnchor":dialogOffset})
    ptypeSelector.addOptionArr(["string","float","integer","Enum","Object","double","boolean","date","dateTime","duration","long","time"])
    DOM.append(parameterNameInput,ptypeSelector.DOM,enumValueInput,addButton,removeButton)

    removeButton.on("click",()=>{
        for (var i =0;i< parentDtdlObj.length; i++) {
            if (parentDtdlObj[i] === dtdlObj) {
                parentDtdlObj.splice(i, 1);
                break;
            }
        }
        DOM.remove()
        refreshDTDLF()
    })
    
    var contentDOM=$('<div style="padding-left:10px"></div>')
    DOM.append(contentDOM)
    parentDOM.append(DOM)

    parameterNameInput.val(dtdlObj["name"])
    ptypeSelector.callBack_clickOption=(optionText,optionValue,realMouseClick)=>{
        ptypeSelector.changeName(optionText)
        contentDOM.empty()//clear all content dom content
        if(realMouseClick){
            for(var ind in dtdlObj) delete dtdlObj[ind]    //clear all object content
            if(topLevel) dtdlObj["@type"]="Property"
            dtdlObj["name"]=parameterNameInput.val()
        } 
        if(optionText=="Enum"){
            enumValueInput.val("")
            enumValueInput.show();
            addButton.hide()
            if(realMouseClick) dtdlObj["schema"]={"@type": "Enum","valueSchema": "string"}
        }else if(optionText=="Object"){
            enumValueInput.hide();
            addButton.show()
            if(realMouseClick) dtdlObj["schema"]={"@type": "Object"}
        }else{
            if(realMouseClick) dtdlObj["schema"]=optionText
            enumValueInput.hide();
            addButton.hide()
        }
        refreshDTDLF()
    }
    addButton.on("click",()=>{
        if(! dtdlObj["schema"]["fields"]) dtdlObj["schema"]["fields"]=[]
        var newObj = {
            "name": "newP",
            "schema": "double"
        }
        dtdlObj["schema"]["fields"].push(newObj)
        new singleParameterRow(newObj,contentDOM,refreshDTDLF,dtdlObj["schema"]["fields"],null,dialogOffset)
        refreshDTDLF()
    })

    parameterNameInput.on("change",()=>{
        dtdlObj["name"]=parameterNameInput.val()
        refreshDTDLF()
    })
    enumValueInput.on("change",()=>{
        var valueArr=enumValueInput.val().split(",")
        dtdlObj["schema"]["enumValues"]=[]
        valueArr.forEach(aVal=>{
            dtdlObj["schema"]["enumValues"].push({
                "name": aVal.replace(" ",""), //remove all the space in name
                "enumValue": aVal
              })
        })
        refreshDTDLF()
    })
    if(typeof(dtdlObj["schema"]) != 'object') var schema=dtdlObj["schema"]
    else schema=dtdlObj["schema"]["@type"]
    ptypeSelector.triggerOptionValue(schema)
    if(schema=="Enum"){
        var enumArr=dtdlObj["schema"]["enumValues"]
        if(enumArr!=null){
            var inputStr=""
            enumArr.forEach(oneEnumValue=>{inputStr+=oneEnumValue.enumValue+","})
            inputStr=inputStr.slice(0, -1)//remove the last ","
            enumValueInput.val(inputStr)
        }
    }else if(schema=="Object"){
        var fields=dtdlObj["schema"]["fields"]
        fields.forEach(oneField=>{
            new singleParameterRow(oneField,contentDOM,refreshDTDLF,dtdlObj["schema"]["fields"],null,dialogOffset)
        })
    }
}


function idRow(dtdlObj,parentDOM,refreshDTDLF){
    var DOM = $('<div class="w3-cell-row"></div>')
    var label1=$('<div class="w3-opacity" style="display:inline">dtmi:</div>')
    var domainInput=$('<input type="text" style="outline:none;display:inline;width:88px;padding:4px"  placeholder="Namespace"/>').addClass("w3-input w3-border");
    var modelIDInput=$('<input type="text" style="outline:none;display:inline;width:132px;padding:4px"  placeholder="ModelID"/>').addClass("w3-input w3-border");
    var versionInput=$('<input type="text" style="outline:none;display:inline;width:60px;padding:4px"  placeholder="version"/>').addClass("w3-input w3-border");
    DOM.append(label1,domainInput,$('<div class="w3-opacity" style="display:inline">:</div>'),modelIDInput,$('<div class="w3-opacity" style="display:inline">;</div>'),versionInput)
    parentDOM.append(DOM)

    var valueChange=()=>{
        var str=`dtmi:${domainInput.val()}:${modelIDInput.val()};${versionInput.val()}`
        dtdlObj["@id"]=str
        refreshDTDLF()
    }
    domainInput.on("change",valueChange)
    modelIDInput.on("change",valueChange)
    versionInput.on("change",valueChange)

    var str=dtdlObj["@id"]
    if(str!="" && str!=null){
        var arr1=str.split(";")
        if(arr1.length!=2) return;
        versionInput.val(arr1[1])
        var arr2=arr1[0].split(":")
        domainInput.val(arr2[1])
        arr2.shift(); arr2.shift()
        modelIDInput.val(arr2.join(":"))
    }
}

function displayNameRow(dtdlObj,parentDOM,refreshDTDLF){
    var DOM = $('<div class="w3-cell-row"></div>')
    var label1=$('<div class="w3-opacity" style="display:inline">Display Name:</div>')
    var nameInput=$('<input type="text" style="outline:none;display:inline;width:150px;padding:4px"  placeholder="ModelID"/>').addClass("w3-input w3-border");
    DOM.append(label1,nameInput)
    parentDOM.append(DOM)
    var valueChange=()=>{
        dtdlObj["displayName"]=nameInput.val()
        refreshDTDLF()
    }
    nameInput.on("change",valueChange)
    var str=dtdlObj["displayName"]
    if(str!="" && str!=null) nameInput.val(str)
}
},{"../msalHelper":18,"./globalCache":21,"./modelAnalyzer":22,"./simpleConfirmDialog":31,"./simpleSelectMenu":33}],24:[function(require,module,exports){
const modelAnalyzer=require("./modelAnalyzer")
const simpleTree= require("./simpleTree")
const simpleConfirmDialog = require("./simpleConfirmDialog")
const modelEditorDialog = require("./modelEditorDialog")
const globalCache = require("./globalCache")
const msalHelper=require("../msalHelper")
const simpleExpandableSection= require("../sharedSourceFiles/simpleExpandableSection")
const simpleSelectMenu=require("../sharedSourceFiles/simpleSelectMenu")
function modelManagerDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:99" class="w3-card-2"></div>')
        this.DOM.css("overflow","hidden")
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
    this.showRelationVisualizationSettings=true;
}

modelManagerDialog.prototype.popup = async function() {
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:700px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Digital Twin Models</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var importModelsBtn = $('<button class="w3-button w3-card w3-deep-orange w3-hover-light-green" style="height:100%">Import</button>')
    var actualImportModelsBtn =$('<input type="file" name="modelFiles" multiple="multiple" style="display:none"></input>')
    var modelEditorBtn = $('<button class="w3-button w3-card w3-deep-orange w3-hover-light-green" style="height:100%">Create/Modify Model</button>')
    var exportModelBtn = $('<button class="w3-ripple w3-button w3-card w3-deep-orange w3-hover-light-green" style="height:100%">Export All Models</button>')
    this.contentDOM.children(':first').append(importModelsBtn,actualImportModelsBtn, modelEditorBtn,exportModelBtn)
    importModelsBtn.on("click", ()=>{
        actualImportModelsBtn.trigger('click');
    });
    actualImportModelsBtn.change(async (evt)=>{
        var files = evt.target.files; // FileList object
        await this.readModelFilesContentAndImport(files)
        actualImportModelsBtn.val("")
    })
    modelEditorBtn.on("click",()=>{
        modelEditorDialog.popup()
    })
    exportModelBtn.on("click", () => {
        var modelArr=[]
        for(var modelID in modelAnalyzer.DTDLModels) modelArr.push(JSON.parse(modelAnalyzer.DTDLModels[modelID]["original"]))
        var pom = $("<a></a>")
        pom.attr('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(modelArr)));
        pom.attr('download', "exportModels.json");
        pom[0].click()
    })

    var row2=$('<div class="w3-cell-row" style="margin-top:2px"></div>')
    this.contentDOM.append(row2)
    var leftSpan=$('<div class="w3-cell" style="width:240px;padding-right:5px"></div>')
    row2.append(leftSpan)
    leftSpan.append($('<div style="height:30px" class="w3-bar w3-red"><div class="w3-bar-item" style="">Models</div></div>'))
    
    var modelList = $('<ul class="w3-ul w3-hoverable">')
    modelList.css({"overflow-x":"hidden","overflow-y":"auto","height":"420px", "border":"solid 1px lightgray"})
    leftSpan.append(modelList)
    this.modelList = modelList;
    
    var rightSpan=$('<div class="w3-container w3-cell" style="padding:0px"></div>')
    row2.append(rightSpan) 
    var panelCardOut=$('<div class="w3-card-2 w3-white" style="margin-top:2px"></div>')

    this.modelButtonBar=$('<div class="w3-bar" style="height:35px"></div>')
    panelCardOut.append(this.modelButtonBar)

    rightSpan.append(panelCardOut)
    var panelCard=$('<div style="width:460px;height:412px;overflow:auto;margin-top:2px"></div>')
    panelCardOut.append(panelCard)
    this.panelCard=panelCard;

    this.modelButtonBar.empty()
    panelCard.html("<a style='display:block;font-style:italic;color:gray;padding-left:5px'>Choose a model to view infomration</a>")

    this.listModels()
}

modelManagerDialog.prototype.resizeImgFile = async function(theFile,max_size) {
    return new Promise((resolve, reject) => {
        try {
            var reader = new FileReader();
            var tmpImg = new Image();
            reader.onload = () => {
                tmpImg.onload =  ()=> {
                    var canvas = document.createElement('canvas')
                    var width = tmpImg.width
                    var height = tmpImg.height;
                    if (width > height) {
                        if (width > max_size) {
                            height *= max_size / width;
                            width = max_size;
                        }
                    } else {
                        if (height > max_size) {
                            width *= max_size / height;
                            height = max_size;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    canvas.getContext('2d').drawImage(tmpImg, 0, 0, width, height);
                    var dataUrl = canvas.toDataURL('image/png');
                    resolve(dataUrl)
                }
                tmpImg.src = reader.result;
            }
            reader.readAsDataURL(theFile);
        } catch (e) {
            reject(e)
        }
    })
}

modelManagerDialog.prototype.fillRightSpan=async function(modelID){
    this.panelCard.empty()
    this.modelButtonBar.empty()

    var delBtn = $('<button style="margin-bottom:2px" class="w3-ripple w3-button w3-light-gray w3-hover-pink w3-border-right">Delete Model</button>')
    this.modelButtonBar.append(delBtn)


    var importPicBtn = $('<button class="w3-button w3-light-gray w3-hover-amber w3-border-right">Upload Avarta</button>')
    var actualImportPicBtn = $('<input type="file" name="img" style="display:none"></input>')
    var chooseAvartaBtn = $('<button class="w3-ripple w3-button w3-light-gray w3-hover-pink w3-border-right">Choose A Symbol</button>')
    
    var clearAvartaBtn = $('<button class="w3-ripple w3-button w3-light-gray w3-hover-pink w3-border-right">Clear Avarta</button>')
    this.modelButtonBar.append(importPicBtn, actualImportPicBtn,chooseAvartaBtn, clearAvartaBtn)
    importPicBtn.on("click", () => {
        actualImportPicBtn.trigger('click');
    });

    actualImportPicBtn.change(async (evt) => {
        var files = evt.target.files; // FileList object
        var theFile = files[0]

        if (theFile.type == "image/svg+xml") {
            var str = await this.readOneFile(theFile)
            var dataUrl = 'data:image/svg+xml;utf8,' + encodeURIComponent(str);
        } else if (theFile.type.match('image.*')) {
            var dataUrl = await this.resizeImgFile(theFile, 256)
        } else {
            var confirmDialogDiv = new simpleConfirmDialog()
            confirmDialogDiv.show({ width: "200px" },
                {
                    title: "Note"
                    , content: "Please import image file (png,jpg,svg and so on)"
                    , buttons: [{ colorClass: "w3-gray", text: "Ok", "clickFunc": () => { confirmDialogDiv.close() } }]
                }
            )
        }
        this.updateAvartaDataUrl(dataUrl,modelID)
        actualImportPicBtn.val("")
    })

    chooseAvartaBtn.on("click",()=>{this.chooseAvarta(modelID)})

    clearAvartaBtn.on("click", () => {
        this.updateAvartaDataUrl(null,modelID)
    });

    
    delBtn.on("click",()=>{
        var relatedModelIDs =modelAnalyzer.listModelsForDeleteModel(modelID)
        var dialogStr=(relatedModelIDs.length==0)? ("This will DELETE model \"" + modelID + "\"."): 
            (modelID + " is base model of "+relatedModelIDs.join(", ")+".")
        var confirmDialogDiv = new simpleConfirmDialog()

        //check how many twins are under this model ID
        var numberOfTwins=0
        var checkTwinsModelArr=[modelID].concat(relatedModelIDs)
        for(var oneTwinID in globalCache.DBTwins){
            var oneDBTwin = globalCache.DBTwins[oneTwinID]
            var theIndex=checkTwinsModelArr.indexOf(oneDBTwin["modelID"])
            if(theIndex!=-1) numberOfTwins++
        }

        dialogStr+=" (There will be "+((numberOfTwins>1)?(numberOfTwins+" twins"):(numberOfTwins+" twin") ) + " being impacted)"
        confirmDialogDiv.show(
            { width: "350px" },
            {
                title: "Warning"
                , content: dialogStr
                , buttons: [
                    {
                        colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": async () => {
                            confirmDialogDiv.close();
                            this.confirmDeleteModel(modelID) 
                        }
                    },
                    {
                        colorClass: "w3-gray", text: "Cancel", "clickFunc": () => {
                            confirmDialogDiv.close()
                        }
                    }
                ]
            }
        )
        
    })
    
    var VisualizationDOM=this.addAPartInRightSpan("Visualization",{"marginTop":0}) 
    var editablePropertiesDOM=this.addAPartInRightSpan("Editable Properties And Relationships")
    var baseClassesDOM=this.addAPartInRightSpan("Base Classes")
    var originalDefinitionDOM=this.addAPartInRightSpan("Original Definition")

    var str=JSON.stringify(JSON.parse(modelAnalyzer.DTDLModels[modelID]["original"]),null,2)
    originalDefinitionDOM.append($('<pre id="json">'+str+'</pre>'))

    var edittableProperties=modelAnalyzer.DTDLModels[modelID].editableProperties
    this.fillEditableProperties(edittableProperties,editablePropertiesDOM)
    var validRelationships=modelAnalyzer.DTDLModels[modelID].validRelationships
    this.fillRelationshipInfo(validRelationships,editablePropertiesDOM)

    this.fillVisualization(modelID,VisualizationDOM)

    this.fillBaseClasses(modelAnalyzer.DTDLModels[modelID].allBaseClasses,baseClassesDOM) 
}

modelManagerDialog.prototype.updateAvartaDataUrl = function (dataUrl,modelID) {
    if (!dataUrl){
        var visualJson = globalCache.visualDefinition["default"].detail
        if (visualJson[modelID]){
            delete visualJson[modelID].avarta
            delete visualJson[modelID].avartaWidth
            delete visualJson[modelID].avartaHeight
        } 
        if (this.avartaImg) this.avartaImg.removeAttr('src');
        this.saveVisualDefinition()
        this.broadcastMessage({ "message": "visualDefinitionChange", "modelID": modelID, "noAvarta": true })
        this.refreshModelTreeLabel()
        return;
    } 
    
    //if it is svg, check if the svg set its width and height attribute, as cytoscape js can not handle svg scaling withouth width and heigh attribute
    var dec= decodeURIComponent(dataUrl)
    if(dec.startsWith("data:image/svg+xml")){
        var pos=dec.indexOf("<svg ")
        var svgPart=dec.substr(pos)
        var tmpObj=$(svgPart)
        if(tmpObj.attr('width')==null){
            var ss=tmpObj.attr('viewBox')
            if(ss){
                var arr=ss.split(" ")
                tmpObj.attr("width",arr[2]-arr[0])
                tmpObj.attr("height",arr[3]-arr[1])
                dataUrl=`data:image/svg+xml;utf8,${encodeURIComponent(tmpObj[0].outerHTML)}`
            }
        }
    }

    if (this.avartaImg) this.avartaImg.attr("src", dataUrl)

    var visualJson = globalCache.visualDefinition["default"].detail //currently there is only one visual definition: "default"
    if (!visualJson[modelID]) visualJson[modelID] = {}
    visualJson[modelID].avarta = dataUrl
    
    var testImg = $(`<img src="${dataUrl}"/>`)
    testImg.on('load', ()=>{
        testImg.css({"display":"none"}) //to get the image size, append it to body temporarily
        $('body').append(testImg)
        visualJson[modelID].avartaWidth=testImg.width()
        visualJson[modelID].avartaHeight=testImg.height()
        testImg.remove()
        this.saveVisualDefinition()
        this.broadcastMessage({ "message": "visualDefinitionChange", "modelID": modelID, "avarta": dataUrl })
        this.refreshModelTreeLabel()
    });
}

modelManagerDialog.prototype.chooseAvarta=function(modelID){
    var popWindow=new simpleConfirmDialog()
    popWindow.show({"max-width":"450px","min-width":"300px"},{
        "title": "Choose Symbol as Avarta (best with rectangle shape )",
        "customDrawing": (parentDOM) => {
            var row1=$('<div class="w3-bar" style="padding:2px"></div>')
            parentDOM.append(row1)
            var lable = $('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">Icon Set </div>')
            row1.append(lable)
            var iconSetSelector = new simpleSelectMenu(" ", { withBorder: 1, colorClass: "w3-light-gray", buttonCSS: { "padding": "5px 10px" } })
            row1.append(iconSetSelector.DOM)
            this.iconsHolderDiv=$("<div/>")
            parentDOM.append(this.iconsHolderDiv)
            iconSetSelector.callBack_clickOption = (optionText, optionValue) => {
                iconSetSelector.changeName(optionText)
                this.iconsHolderDiv.empty()
                var symbolList=globalCache.symbolLibs[optionText]
                for(var symbolName in symbolList){
                    this.createSymbolDOM(optionText,symbolName,modelID,this.iconsHolderDiv,popWindow)
                }
            }
            for (var ind in globalCache.symbolLibs) iconSetSelector.addOption(ind)
            iconSetSelector.triggerOptionIndex(0)
        }
    })
}

modelManagerDialog.prototype.createSymbolDOM=function(libName,symbolName,modelID,parentDOM,popWindow){
    var symbolSize=80
    var symbolList=globalCache.symbolLibs[libName]
    var aSymbolDOM=$("<div class='w3-button w3-white' style='padding:0px;width:"+symbolSize+"px;height:"+symbolSize+"px;float:left'></div>")
    var svgStr=symbolList[symbolName].replaceAll("'",'"')
    var dataUrl=`data:image/svg+xml;utf8,${encodeURIComponent(svgStr)}`
    var svgImg=$(`<img style='max-width:${symbolSize}px;max-height:${symbolSize}px' src='${dataUrl}'></img>`)
    aSymbolDOM.append(svgImg)
    parentDOM.append(aSymbolDOM)
    aSymbolDOM.on("click",()=>{
        popWindow.close()
        this.updateAvartaDataUrl(dataUrl,modelID)
    })
}

modelManagerDialog.prototype.confirmDeleteModel=function(modelID){
    var funcAfterEachSuccessDelete = (eachDeletedModelID) => {
        this.tree.deleteLeafNode(globalCache.modelIDMapToName[eachDeletedModelID])
        //TODO: clear the visualization setting of this deleted model, but if it is replace, should not, so I comment out first
        /*
        if (globalCache.visualDefinition["default"].detail[modelID]) {
            delete globalCache.visualDefinition["default"].detail[modelID]
            this.saveVisualDefinition()
        }*/
    }
    var completeFunc=()=>{ 
        this.broadcastMessage({ "message": "ADTModelsChange"})
        this.panelCard.empty()
    }

    //even not completely successful deleting, it will still invoke completeFunc
    modelAnalyzer.deleteModel(modelID,funcAfterEachSuccessDelete,completeFunc,completeFunc)
}

modelManagerDialog.prototype.refreshModelTreeLabel=function(){
    if(this.tree.selectedNodes.length>0) this.tree.selectedNodes[0].redrawLabel()
}

modelManagerDialog.prototype.fillBaseClasses=function(baseClasses,parentDom){
    for(var ind in baseClasses){
        var keyDiv= $("<label style='display:block;padding:.1em'>"+ind+"</label>")
        parentDom.append(keyDiv)
    }
}

modelManagerDialog.prototype.fillVisualization=function(modelID,parentDom){
    var modelJson=modelAnalyzer.DTDLModels[modelID];
    var aTable=$("<table style='width:100%'></table>")
    aTable.html('<tr><td></td><td align="center"></td></tr>')
    parentDom.append(aTable) 

    var leftPart=aTable.find("td:first")
    var rightPart=aTable.find("td:nth-child(2)")
    var outerDIV=$("<div class='w3-border' style='width:55px;height:55px;padding:5px'></div>")
    var avartaImg=$("<img style='height:45px'></img>")
    rightPart.append(outerDIV)
    outerDIV.append(avartaImg)
    var visualJson=globalCache.visualDefinition["default"].detail
    if(visualJson && visualJson[modelID] && visualJson[modelID].avarta) avartaImg.attr('src',visualJson[modelID].avarta)
    this.avartaImg=avartaImg;
    this.addOneVisualizationRow(modelID,leftPart)

    if(this.showRelationVisualizationSettings){
        for(var ind in modelJson.validRelationships){
            this.addOneVisualizationRow(modelID,leftPart,ind)
        }
    }
    this.addLabelVisualizationRow(modelID,leftPart)
}

modelManagerDialog.prototype.addLabelVisualizationRow=function(modelID,parentDom){
    var containerDiv=$("<div style='padding-bottom:8px'></div>")
    parentDom.append(containerDiv)
    var contentDOM=$("<label class='w3-text-gray' style='margin-right:10px;font-style:italic; font-weight:bold;font-size:0.9em'>Position Label</label>")
    containerDiv.append(contentDOM)
    var definedLblX=0
    var definedLblY=0
    var visualJson=globalCache.visualDefinition["default"].detail
    if(visualJson[modelID] && visualJson[modelID].labelX) definedLblX=visualJson[modelID].labelX
    if(visualJson[modelID] && visualJson[modelID].labelY) definedLblY=visualJson[modelID].labelY
    var lblXAdjustSelector = $('<select class="w3-border" style="outline:none;width:110px"></select>')
    for(var f=-25;f<=30;f+=5){
        var val=f.toFixed(0)+""
        lblXAdjustSelector.append($("<option value="+val+">xoff:"+val+"</option>"))
    }
    if(definedLblX!=null) lblXAdjustSelector.val(definedLblX)
    else lblXAdjustSelector.val("0")
    containerDiv.append(lblXAdjustSelector)
    var lblYAdjustSelector = $('<select class="w3-border" style="outline:none;width:110px"></select>')
    for(var f=0;f<30;f+=5){
        var val=f.toFixed(0)+""
        lblYAdjustSelector.append($("<option value="+val+">yoff:"+val+"</option>"))
    }
    for(var f=30;f<=90;f+=10){
        var val=f.toFixed(0)+""
        lblYAdjustSelector.append($("<option value="+val+">yoff:"+val+"</option>"))
    }
    if(definedLblY!=null) lblYAdjustSelector.val(definedLblY)
    else lblYAdjustSelector.val("0")
    containerDiv.append(lblYAdjustSelector)

    lblXAdjustSelector.change((eve)=>{
        var chooseVal=eve.target.value
        this.modifyLblOffset("labelX",chooseVal,modelID)
    })
    lblYAdjustSelector.change((eve)=>{
        var chooseVal=eve.target.value
        this.modifyLblOffset("labelY",chooseVal,modelID)
    })
}

modelManagerDialog.prototype.modifyLblOffset = function (XY, val,modelID) {
    var visualJson = globalCache.visualDefinition["default"].detail
    if (!visualJson[modelID]) visualJson[modelID] = {}
    visualJson[modelID][XY] = val
    this.broadcastMessage({ "message": "visualDefinitionChange", "modelID": modelID, "labelPosition":true })
    this.saveVisualDefinition()
}

modelManagerDialog.prototype.addOneVisualizationRow=function(modelID,parentDom,relatinshipName){
    if(relatinshipName==null) var nameStr="" //visual for node
    else nameStr=" "+relatinshipName
    var containerDiv=$("<div style='padding-bottom:8px'></div>")
    parentDom.append(containerDiv)
    var contentDOM=$("<label class='w3-text-gray' style='margin-right:10px;font-weight:bold;font-size:0.9em'>"+nameStr+"</label>")
    containerDiv.append(contentDOM)

    var definedColor=null
    var definedColor2=null
    var definedShape=null
    var definedDimensionRatio=null
    var definedEdgeWidth=null
    var visualJson=globalCache.visualDefinition["default"].detail
    if(relatinshipName==null){
        if(visualJson[modelID] && visualJson[modelID].color) definedColor=visualJson[modelID].color
        if(visualJson[modelID] && visualJson[modelID].secondColor) definedColor2=visualJson[modelID].secondColor
        if(visualJson[modelID] && visualJson[modelID].shape) definedShape=visualJson[modelID].shape
        if(visualJson[modelID] && visualJson[modelID].dimensionRatio) definedDimensionRatio=visualJson[modelID].dimensionRatio
    }else{
        if (visualJson[modelID] && visualJson[modelID]["rels"] && visualJson[modelID]["rels"][relatinshipName]) {
            if (visualJson[modelID]["rels"][relatinshipName].color) definedColor = visualJson[modelID]["rels"][relatinshipName].color
            if (visualJson[modelID]["rels"][relatinshipName].shape) definedShape = visualJson[modelID]["rels"][relatinshipName].shape
            if(visualJson[modelID]["rels"][relatinshipName].edgeWidth) definedEdgeWidth=visualJson[modelID]["rels"][relatinshipName].edgeWidth
        }
    }

    var createAColorSelector=(predefinedColor,nameOfColorField)=>{
        var colorSelector=$('<select class="w3-border" style="outline:none;width:75px"></select>')
        containerDiv.append(colorSelector)

        var colorArr=["darkGray","Black","LightGray","Red","Green","Blue","Bisque","Brown","Coral","Crimson","DodgerBlue","Gold"]
        colorArr.forEach((oneColorCode)=>{
            var anOption=$("<option value='"+oneColorCode+"'>"+oneColorCode+"</option>")
            colorSelector.append(anOption)
            anOption.css("color",oneColorCode)
        })

        if(relatinshipName==null){
            var anOption=$("<option value='none'>none</option>")
            anOption.css("color","darkGray")
            colorSelector.append(anOption)
        }

        if(nameOfColorField=="secondColor"){
            if(predefinedColor==null) predefinedColor="none"
        }else{
            if(predefinedColor==null) predefinedColor="darkGray"
        }

        colorSelector.val(predefinedColor)
        if(predefinedColor!="none") {
            colorSelector.css("color",predefinedColor)
        }else{
            colorSelector.css("color","darkGray")
        }
        
        colorSelector.change((eve)=>{
            var selectColorCode=eve.target.value
            if(selectColorCode=="none") colorSelector.css("color","darkGray")
            else colorSelector.css("color",selectColorCode)
            var visualJson=globalCache.visualDefinition["default"].detail
    
            if(!visualJson[modelID]) visualJson[modelID]={}
            if(!relatinshipName) {
                if(selectColorCode=="none" && nameOfColorField=="secondColor") delete visualJson[modelID]["secondColor"]
                else visualJson[modelID][nameOfColorField]=selectColorCode
                this.broadcastMessage({ "message": "visualDefinitionChange", "modelID":modelID
                    ,"color":visualJson[modelID]["color"],"secondColor":visualJson[modelID]["secondColor"] })
                this.refreshModelTreeLabel()
            }else{
                if(!visualJson[modelID]["rels"]) visualJson[modelID]["rels"]={}
                if(!visualJson[modelID]["rels"][relatinshipName]) visualJson[modelID]["rels"][relatinshipName]={}
                visualJson[modelID]["rels"][relatinshipName].color=selectColorCode
                this.broadcastMessage({ "message": "visualDefinitionChange", "srcModelID":modelID,"relationshipName":relatinshipName,"color":selectColorCode })
            }
            this.saveVisualDefinition()
        })
    }

    createAColorSelector(definedColor,"color")
    if(relatinshipName==null) createAColorSelector(definedColor2,"secondColor")


    var shapeSelector = $('<select class="w3-border" style="outline:none"></select>')
    containerDiv.append(shapeSelector)
    if(relatinshipName==null){
        shapeSelector.append($("<option value='ellipse'></option>"))
        shapeSelector.append($("<option value='rectangle' style='font-size:120%'></option>"))
        shapeSelector.append($("<option value='hexagon' style='font-size:130%'></option>"))
    }else{
        shapeSelector.append($("<option value='solid'></option>"))
        shapeSelector.append($("<option value='dotted'></option>"))
    }
    if(definedShape!=null) {
        shapeSelector.val(definedShape)
    }
    shapeSelector.change((eve)=>{
        var selectShape=eve.target.value
        var visualJson = globalCache.visualDefinition["default"].detail

        if(!visualJson[modelID]) visualJson[modelID]={}
        if(!relatinshipName) {
            visualJson[modelID].shape=selectShape
            this.broadcastMessage({ "message": "visualDefinitionChange", "modelID":modelID,"shape":selectShape })
            this.refreshModelTreeLabel()
        }else{
            if(!visualJson[modelID]["rels"]) visualJson[modelID]["rels"]={}
            if(!visualJson[modelID]["rels"][relatinshipName]) visualJson[modelID]["rels"][relatinshipName]={}
            visualJson[modelID]["rels"][relatinshipName].shape=selectShape
            this.broadcastMessage({ "message": "visualDefinitionChange", "srcModelID":modelID,"relationshipName":relatinshipName,"shape":selectShape })
        }
        this.saveVisualDefinition()
    })

    var sizeAdjustSelector = $('<select class="w3-border" style="outline:none;width:110px"></select>')
    if(relatinshipName==null){
        for(var f=0.2;f<=2;f+=0.4){
            var val=f.toFixed(1)+""
            sizeAdjustSelector.append($("<option value="+val+">dimension*"+val+"</option>"))
        }
        for(var f=2;f<=10;f+=1){
            var val=f.toFixed(1)+""
            sizeAdjustSelector.append($("<option value="+val+">dimension*"+val+"</option>"))
        }
        if(definedDimensionRatio!=null) sizeAdjustSelector.val(definedDimensionRatio)
        else sizeAdjustSelector.val("1.0")
    }else{
        sizeAdjustSelector.css("width","80px")
        for(var f=0.5;f<=4;f+=0.5){
            var val=f.toFixed(1)+""
            sizeAdjustSelector.append($("<option value="+val+">width *"+val+"</option>"))
        }
        for(var f=5;f<=10;f+=1){ 
            var val=f.toFixed(1)+""
            sizeAdjustSelector.append($("<option value="+val+">width *"+val+"</option>"))
        }
        if(definedEdgeWidth!=null) sizeAdjustSelector.val(definedEdgeWidth)
        else sizeAdjustSelector.val("2.0")
    }
    containerDiv.append(sizeAdjustSelector)

    
    sizeAdjustSelector.change((eve)=>{
        var chooseVal=eve.target.value
        var visualJson = globalCache.visualDefinition["default"].detail

        if(!relatinshipName) {
            if(!visualJson[modelID]) visualJson[modelID]={}
            visualJson[modelID].dimensionRatio=chooseVal
            this.broadcastMessage({ "message": "visualDefinitionChange", "modelID":modelID,"dimensionRatio":chooseVal })
            this.refreshModelTreeLabel()
        }else{
            if(!visualJson[modelID]["rels"]) visualJson[modelID]["rels"]={}
            if(!visualJson[modelID]["rels"][relatinshipName]) visualJson[modelID]["rels"][relatinshipName]={}
            visualJson[modelID]["rels"][relatinshipName].edgeWidth=chooseVal
            this.broadcastMessage({ "message": "visualDefinitionChange", "srcModelID":modelID,"relationshipName":relatinshipName,"edgeWidth":chooseVal })
        }
        this.saveVisualDefinition()
    })
    
}

modelManagerDialog.prototype.saveVisualDefinition=async function(){
    try{
        await msalHelper.callAPI("digitaltwin/saveVisualDefinition", "POST", {"visualDefinitionJson":JSON.stringify(globalCache.visualDefinition["default"].detail)},"withProjectID")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }
}

modelManagerDialog.prototype.fillRelationshipInfo=function(validRelationships,parentDom){
    for(var ind in validRelationships){
        var keyDiv= $("<label style='display:inline;padding:.1em .3em .1em .3em;margin-right:.3em'>"+ind+"</label>")
        parentDom.append(keyDiv)
        keyDiv.css("padding-top",".1em")
        var label=$("<label class='w3-lime' style='display:inline;font-size:9px;padding:2px'></label>")
        label.text("Relationship")
        parentDom.append(label)
        if(validRelationships[ind].target){
            var label1=$("<label class='w3-lime' style='display:inline;font-size:9px;padding:2px;margin-left:2px'></label>")
            label1.text(validRelationships[ind].target)
            parentDom.append(label1)
        }
        var contentDOM=$("<label></label>")
        contentDOM.css("display","block")
        contentDOM.css("padding-left","1em")
        parentDom.append(contentDOM)
        this.fillEditableProperties(validRelationships[ind].editableRelationshipProperties, contentDOM)
    }
}

modelManagerDialog.prototype.fillEditableProperties=function(jsonInfo,parentDom){
    for(var ind in jsonInfo){
        var keyDiv= $("<label style='display:block'><label style='display:inline;padding:.1em .3em .1em .3em;margin-right:.3em'>"+ind+"</label></label>")
        parentDom.append(keyDiv)
        keyDiv.css("padding-top",".1em")

        if(Array.isArray(jsonInfo[ind])){
            var contentDOM=$("<label class='w3-dark-gray' ></label>")
            contentDOM.text("enum")
            contentDOM.css({"fontSize":"9px","padding":'2px'})
            keyDiv.append(contentDOM)

            var valueArr=[]
            jsonInfo[ind].forEach(ele=>{valueArr.push(ele.enumValue)})
            var label1=$("<label class='w3-dark-gray' ></label>")
            label1.css({"fontSize":"9px","padding":'2px',"margin-left":"2px"})
            label1.text(valueArr.join())
            keyDiv.append(label1)
        }else if(typeof(jsonInfo[ind])==="object") {
            var contentDOM=$("<label></label>")
            contentDOM.css("display","block")
            contentDOM.css("padding-left","1em")
            this.fillEditableProperties(jsonInfo[ind],contentDOM)
            keyDiv.append(contentDOM)
        }else {
            var contentDOM=$("<label class='w3-dark-gray' ></label>")
            contentDOM.text(jsonInfo[ind])
            contentDOM.css({"fontSize":"9px","padding":'2px'})
            keyDiv.append(contentDOM)
        }
    }
}


modelManagerDialog.prototype.addAPartInRightSpan=function(partName,options){
    options=options||{}
    var section= new simpleExpandableSection(partName,this.panelCard,options)
    section.expand()
    return section.listDOM;
}

modelManagerDialog.prototype.readModelFilesContentAndImport=async function(files){
    // files is a FileList of File objects. List some properties.
    var fileContentArr=[]
    for (var i = 0;i< files.length; i++) {
        var f=files[i]
        // Only process json files.
        if (f.type!="application/json") continue;
        try{
            var str= await this.readOneFile(f)
            var obj=JSON.parse(str)
            if(Array.isArray(obj)) fileContentArr=fileContentArr.concat(obj)
            else fileContentArr.push(obj)
        }catch(err){
            alert(err)
        }
    }
    if(fileContentArr.length==0) return;
    try {
        await msalHelper.callAPI("digitaltwin/importModels", "POST", {"models":JSON.stringify(fileContentArr)},"withProjectID")
        this.listModels("shouldBroadCast")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }  
}

modelManagerDialog.prototype.readOneFile= async function(aFile){
    return new Promise((resolve, reject) => {
        try{
            var reader = new FileReader();
            reader.onload = ()=> {
                resolve(reader.result)
            };
            reader.readAsText(aFile);
        }catch(e){
            reject(e)
        }
    })
}


modelManagerDialog.prototype.listModels=async function(shouldBroadcast){
    this.modelList.empty()
    this.panelCard.empty()
    try{
        var res=await msalHelper.callAPI("digitaltwin/fetchProjectModelsData","POST",null,"withProjectID")
        globalCache.storeProjectModelsData(res.DBModels,res.adtModels)
        modelAnalyzer.clearAllModels();
        modelAnalyzer.addModels(res.adtModels)
        modelAnalyzer.analyze();
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
        return
    }

    if($.isEmptyObject(modelAnalyzer.DTDLModels)){
        var zeroModelItem=$('<li style="font-size:0.9em">zero model record. Please import...</li>')
        this.modelList.append(zeroModelItem)
        zeroModelItem.css("cursor","default")

        var createSampleModelsButton = $('<button class="w3-button w3-amber w3-hover-pink w3-border" style="margin:10%;font-size:1em">Create Sample Models</button>')
        this.modelList.append(createSampleModelsButton) 
        createSampleModelsButton.on("click", async () => {
            createSampleModelsButton.hide()
            var nameSpaceStr = msalHelper.userName.replaceAll(" ", "_")
            if (nameSpaceStr == "") {
                var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                var charactersLength = characters.length;
                for (var i = 0; i < 6; i++) {
                    nameSpaceStr += characters.charAt(Math.floor(Math.random() * charactersLength));
                }
            }
            try {
                await msalHelper.callAPI("digitaltwin/importModels", "POST", {"models":this.sampleModelsStr(nameSpaceStr)},"withProjectID")
                this.listModels("shouldBroadCast")
            }catch(e){
                console.log(e)
                if(e.responseText) alert(e.responseText)
            } 
        }) 
    }else{
        this.tree = new simpleTree(this.modelList, {
            "leafNameProperty": "displayName"
            , "noMultipleSelectAllowed": true, "hideEmptyGroup": true
        })

        this.tree.options.leafNodeIconFunc = (ln) => {
            return globalCache.generateModelIcon(ln.leafInfo["@id"])
        }

        this.tree.callback_afterSelectNodes = (nodesArr, mouseClickDetail) => {
            var theNode = nodesArr[0]
            this.fillRightSpan(theNode.leafInfo["@id"])
        }

        var groupNameList = {}
        for (var modelID in modelAnalyzer.DTDLModels) groupNameList[this.modelNameToGroupName(modelID)] = 1
        var modelgroupSortArr = Object.keys(groupNameList)
        modelgroupSortArr.sort(function (a, b) { return a.toLowerCase().localeCompare(b.toLowerCase()) });
        modelgroupSortArr.forEach(oneGroupName => {
            var gn=this.tree.addGroupNode({ displayName: oneGroupName })
            gn.expand()
        })

        for (var modelID in modelAnalyzer.DTDLModels) {
            var gn = this.modelNameToGroupName(modelID)
            this.tree.addLeafnodeToGroup(gn, JSON.parse(modelAnalyzer.DTDLModels[modelID]["original"]))
        }

        this.tree.sortAllLeaves()
    }
    
    if(shouldBroadcast) this.broadcastMessage({ "message": "ADTModelsChange"})
}

modelManagerDialog.prototype.modelNameToGroupName=function(modelName){
    var nameParts=modelName.split(":")
    if(nameParts.length>=2)  return nameParts[1]
    else return "Others"
}

modelManagerDialog.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="ADTModelEdited") this.listModels("shouldBroadcast")
}

modelManagerDialog.prototype.sampleModelsStr=function(randomeNameSpace){
    var sampleStr='[{"@id":"dtmi:PID1:reducer;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"Reducer","contents":[{"@type":"Property","name":"upstreamSize","schema":"float"},{"@type":"Relationship","name":"pipeConnect"},{"@type":"Property","name":"downstreamSize","schema":"float"},{"@type":"Property","name":"type","schema":{"@type":"Enum","valueSchema":"string","enumValues":[{"name":"concentric","enumValue":"concentric"},{"name":"eccentric","enumValue":"eccentric"}]}},{"@type":"Property","name":"height","schema":"float"},{"@type":"Property","name":"thickness","schema":"float"}],"extends":[]},{"@id":"dtmi:PID1:pressureTransmitter;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"Pressure Transmitter","contents":[{"@type":"Property","name":"pressure","schema":"float"},{"@type":"Relationship","name":"sensing"},{"@type":"Property","name":"unit","schema":"string"},{"@type":"Property","name":"type","schema":{"@type":"Enum","valueSchema":"string","enumValues":[{"name":"analog","enumValue":"analog"},{"name":"digital","enumValue":"digital"}]}},{"@type":"Property","name":"model","schema":"string"}],"extends":[]},{"@id":"dtmi:PID1:mixingReactor;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"Mixing Reactor","contents":[{"@type":"Relationship","name":"pipeConnect"},{"@type":"Property","name":"volume","schema":"double"},{"@type":"Property","name":"temperature","schema":"double"},{"@type":"Property","name":"pressure","schema":"double"},{"@type":"Property","name":"model","schema":"string"},{"@type":"Property","name":"type","schema":{"@type":"Enum","valueSchema":"string","enumValues":[{"name":"CSTR","enumValue":"CSTR"},{"name":"PFR","enumValue":"PFR"},{"name":"Catalytic","enumValue":"Catalytic"}]}}],"extends":[]},{"@id":"dtmi:PID1:packedColumn;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"Packed Column","contents":[{"@type":"Relationship","name":"pipeConnect"},{"@type":"Property","name":"volume","schema":"double"},{"@type":"Property","name":"temperature","schema":"double"},{"@type":"Property","name":"pressure","schema":"double"},{"@type":"Property","name":"model","schema":"string"}],"extends":[]},{"@id":"dtmi:PID1:vessel;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"Vessel","contents":[{"@type":"Relationship","name":"pipeConnect"},{"@type":"Property","name":"volume","schema":"double"},{"@type":"Property","name":"temperature","schema":"double"},{"@type":"Property","name":"pressure","schema":"double"},{"@type":"Property","name":"model","schema":"string"}],"extends":[]},{"@id":"dtmi:PID1:motorValve;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"Motor Valve","contents":[{"@type":"Relationship","name":"pipeConnect"},{"@type":"Property","name":"size","schema":"double"},{"@type":"Property","name":"ports","schema":"integer"}],"extends":[]},{"@id":"dtmi:PID1:oneToOne;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"oneToOne","contents":[{"@type":"Relationship","name":"pipeConnect"},{"@type":"Property","name":"model","schema":"string"}],"extends":[]},{"@id":"dtmi:PID1:oneToOptionalMulti;1","@context":["dtmi:dtdl:context;2"],"@type":"Interface","displayName":"oneToOptionalMulti","contents":[{"@type":"Relationship","name":"pipeConnect"},{"@type":"Property","name":"model","schema":"string"}],"extends":[]}]'
    return sampleStr.replaceAll(":PID1:",":"+randomeNameSpace+":")
}

module.exports = new modelManagerDialog();
},{"../msalHelper":18,"../sharedSourceFiles/simpleExpandableSection":32,"../sharedSourceFiles/simpleSelectMenu":33,"./globalCache":21,"./modelAnalyzer":22,"./modelEditorDialog":23,"./simpleConfirmDialog":31,"./simpleTree":34}],25:[function(require,module,exports){
const globalAppSettings=require("../globalAppSettings")

function moduleSwitchDialog(){
    this.modulesSidebar=$('<div class="w3-sidebar w3-bar-block w3-white w3-animate-left w3-card-4" style="display:none;height:195px;width:240px;overflow:hidden"><div style="height:40px" class="w3-bar w3-red"><button class="w3-bar-item w3-button w3-left w3-hover-amber" style="font-size:2em;padding-top:4px;width:55px"></button><div class="w3-bar-item" style="font-size:1.5em;width:70px;float:left;cursor:default">Open</div></div><a href="#" class="w3-bar-item w3-button w3-medium"><img src="faviconiothub.ico" style="width:25px;margin-right:10px"></img>Device Management</a><a href="#" class="w3-bar-item w3-button w3-medium"><img src="favicondigitaltwin.ico" style="width:25px;margin-right:10px"></img>Digital Twin</a><a href="#" class="w3-bar-item w3-button w3-medium"><img src="faviconeventlog.ico" style="width:25px;margin-right:10px"></img>Event Log</a><a href="#" class="w3-bar-item w3-button w3-medium">Log out</a></div>')
    
    this.modulesSwitchButton=$('<a class="w3-bar-item w3-button" href="#"></a>')
    
    this.modulesSwitchButton.on("click",()=>{ this.modulesSidebar.css("display","block") })
    this.modulesSidebar.children(':first').on("click",()=>{this.modulesSidebar.css("display","none")})
    
    var allModeuls=this.modulesSidebar.children("a")
    $(allModeuls[0]).on("click",()=>{
        window.open("devicemanagement.html", "_blank")
        this.modulesSidebar.css("display","none")
    })
    $(allModeuls[1]).on("click",()=>{
        window.open("digitaltwinmodule.html", "_blank")
        this.modulesSidebar.css("display","none")
    })
    $(allModeuls[2]).on("click",()=>{
        window.open("eventlogmodule.html", "_blank")
        this.modulesSidebar.css("display","none")
    })
    $(allModeuls[3]).on("click",()=>{
        const logoutRequest = {
            postLogoutRedirectUri: globalAppSettings.logoutRedirectUri,
            mainWindowRedirectUri: globalAppSettings.logoutRedirectUri
        };
        var myMSALObj = new msal.PublicClientApplication(globalAppSettings.msalConfig);
        myMSALObj.logoutPopup(logoutRequest);
    })
}

module.exports = new moduleSwitchDialog();
},{"../globalAppSettings":17}],26:[function(require,module,exports){
const modelAnalyzer=require("./modelAnalyzer")
const simpleSelectMenu= require("./simpleSelectMenu")
const msalHelper=require("../msalHelper")
const globalCache=require("./globalCache")

function newTwinDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:99" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

newTwinDialog.prototype.popup = async function(twinInfo,afterTwinCreatedCallback) {
    this.afterTwinCreatedCallback=afterTwinCreatedCallback
    this.originalTwinInfo=JSON.parse(JSON.stringify(twinInfo))
    this.twinInfo=twinInfo
    this.DOM.show()
    this.DOM.empty()
    this.contentDOM = $('<div style="width:520px"></div>')
    this.DOM.append(this.contentDOM)
    this.contentDOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Digital Twin Editor</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.contentDOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    if(!this.afterTwinCreatedCallback){
        var addButton = $('<button class="w3-ripple w3-button w3-card w3-green w3-hover-light-green" style="height:100%">Add</button>')
        this.contentDOM.children(':first').append(addButton)
        addButton.on("click", async () => { this.addNewTwin() })        
    }
    
    var addAndCloseButton = $('<button class="w3-button w3-card w3-green w3-hover-light-green" style="height:100%;margin-left:5px">Add & Close</button>')    
    this.contentDOM.children(':first').append(addAndCloseButton)
    addAndCloseButton.on("click", async () => {this.addNewTwin("CloseDialog")})
        
    var IDLableDiv= $("<div class='w3-padding' style='display:inline;font-weight:bold;color:black'>Twin ID</div>")
    var IDInput=$('<input type="text" style="margin:8px 0;padding:2px;width:150px;outline:none;display:inline" placeholder="ID"/>').addClass("w3-input w3-border");
    this.IDInput=IDInput 
    var modelID=twinInfo["$metadata"]["$model"]
    var modelLableDiv= $("<div class='w3-padding' style='display:inline;font-weight:bold;color:black'>Model</div>")
    var modelInput=$('<label type="text" style="margin:8px 0;padding:2px;display:inline"/>').text(modelID);  
    this.contentDOM.append($("<div/>").append(IDLableDiv,IDInput))
    this.contentDOM.append($("<div style='padding:8px 0px'/>").append(modelLableDiv,modelInput))
    IDInput.change((e)=>{
        this.twinInfo["$dtId"]=$(e.target).val()
    })

    var dialogDOM=$('<div />')
    this.contentDOM.append(dialogDOM)    
    var titleTable=$('<table style="width:100%" cellspacing="0px" cellpadding="0px"></table>')
    titleTable.append($('<tr><td style="font-weight:bold">Properties Tree</td></tr>'))
    dialogDOM.append($("<div class='w3-container'/>").append(titleTable))

    var settingsDiv=$("<div class='w3-container w3-border' style='width:100%;max-height:310px;overflow:auto'></div>")
    this.settingsDiv=settingsDiv
    dialogDOM.append(settingsDiv)
    this.drawModelSettings()
}

newTwinDialog.prototype.addNewTwin = async function(closeDialog) {
    var modelID=this.twinInfo["$metadata"]["$model"]
    var DBModelInfo=globalCache.getSingleDBModelByID(modelID)

    if(!this.twinInfo["$dtId"]||this.twinInfo["$dtId"]==""){
        alert("Please fill in name for the new digital twin")
        return;
    }
    var componentsNameArr=modelAnalyzer.DTDLModels[modelID].includedComponents
    componentsNameArr.forEach(oneComponentName=>{ //adt service requesting all component appear by mandatory
        if(this.twinInfo[oneComponentName]==null)this.twinInfo[oneComponentName]={}
        this.twinInfo[oneComponentName]["$metadata"]= {}
    })

    //ask taskmaster to add the twin
    try{
        var postBody= {"newTwinJson":JSON.stringify(this.twinInfo)}
        var data = await msalHelper.callAPI("digitaltwin/upsertDigitalTwin", "POST", postBody,"withProjectID" )
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }

    globalCache.storeSingleDBTwin(data.DBTwin)    
    globalCache.storeSingleADTTwin(data.ADTTwin)


    //ask taskmaster to provision the twin to iot hub if the model is a iot device model
    if(DBModelInfo.isIoTDeviceModel){
        try{
            var postBody= {"DBTwin":data.DBTwin,"desiredInDeviceTwin":{}}
            DBModelInfo.desiredProperties.forEach(ele=>{
                var propertyName=ele.path[ele.path.length-1]
                var propertySampleV= ""
                postBody.desiredInDeviceTwin[propertyName]=propertySampleV
            })
            var provisionedDocument = await msalHelper.callAPI("devicemanagement/provisionIoTDeviceTwin", "POST", postBody,"withProjectID" )
        }catch(e){
            console.log(e)
            if(e.responseText) alert(e.responseText)
        }
        data.DBTwin=provisionedDocument
        globalCache.storeSingleDBTwin(provisionedDocument)   
    }

    //it should select the new node in the tree, and move topology view to show the new node (note pan to a place that is not blocked by the dialog itself)
    this.broadcastMessage({ "message": "addNewTwin", "twinInfo": data.ADTTwin, "DBTwinInfo":data.DBTwin})

    if(this.afterTwinCreatedCallback){
        this.afterTwinCreatedCallback(data.ADTTwin)
        this.DOM.hide()
    }else{
        if(closeDialog)this.DOM.hide()
        else{
            //clear the input editbox
            this.popup(this.originalTwinInfo)
        }
    }
}

newTwinDialog.prototype.drawModelSettings = async function() {
    var modelID=this.twinInfo["$metadata"]["$model"]
    var modelDetail= modelAnalyzer.DTDLModels[modelID]
    var copyModelEditableProperty=JSON.parse(JSON.stringify(modelDetail.editableProperties))
    
    if($.isEmptyObject(copyModelEditableProperty)){
        this.settingsDiv.text("There is no editable property")
        this.settingsDiv.addClass("w3-text-gray")
        return;
    }   

    var settingsTable=$('<table style="width:100%" cellspacing="0px" cellpadding="0px"></table>')
    this.settingsDiv.append(settingsTable)

    var initialPathArr=[]
    var lastRootNodeRecord=[]
    this.drawEditable(settingsTable,copyModelEditableProperty,this.twinInfo,initialPathArr,lastRootNodeRecord)
}


newTwinDialog.prototype.drawEditable = async function(parentTable,jsonInfo,originElementInfo,pathArr,lastRootNodeRecord) {
    if(jsonInfo==null) return;
    var arr=[]
    for(var ind in jsonInfo) arr.push(ind)

    for(var theIndex=0;theIndex<arr.length;theIndex++){
        if(theIndex==arr.length-1) lastRootNodeRecord[pathArr.length] =true;
        
        var ind = arr[theIndex]
        var tr=$("<tr/>")
        var rightTD=$("<td style='height:30px'/>")
        tr.append(rightTD)
        parentTable.append(tr)
        
        for(var i=0;i<pathArr.length;i++){
            if(!lastRootNodeRecord[i]) rightTD.append(this.treeLineDiv(2))
            else rightTD.append(this.treeLineDiv(4))
        }

        if(theIndex==arr.length-1) rightTD.append(this.treeLineDiv(3))
        else rightTD.append(this.treeLineDiv(1))

        var pNameDiv=$("<div style='float:left;line-height:28px;margin-left:3px'>"+ind+"</div>")
        rightTD.append(pNameDiv)
        var newPath=pathArr.concat([ind])

        if (Array.isArray(jsonInfo[ind])) { //it is a enumerator
            this.drawDropDownBox(rightTD,newPath,jsonInfo[ind],originElementInfo)
        } else if (typeof (jsonInfo[ind])==="object") {
            this.drawEditable(parentTable,jsonInfo[ind],originElementInfo,newPath,lastRootNodeRecord)
        }else {
            var val = globalCache.searchValue(originElementInfo, newPath)
            var aInput=$('<input type="text" style="margin-left:5px;padding:2px;width:200px;outline:none;display:inline" placeholder="type: '+jsonInfo[ind]+'"/>').addClass("w3-input w3-border");  
            if (val != null) aInput.val(val)
            rightTD.append(aInput)
            aInput.data("path", newPath)
            aInput.data("dataType", jsonInfo[ind])
            aInput.change((e)=>{
                this.updateOriginObjectValue($(e.target).data("path"),$(e.target).val(),$(e.target).data("dataType"))
            })
        } 
    }
}

newTwinDialog.prototype.drawDropDownBox=function(rightTD,newPath,valueArr,originElementInfo){
    var aSelectMenu = new simpleSelectMenu(""
        , { width: "200" 
            ,buttonCSS: { "padding": "4px 16px"}
            , "optionListMarginTop": 25//,"optionListMarginLeft":210
            , "adjustPositionAnchor": this.DOM.offset()
        })


    rightTD.append(aSelectMenu.rowDOM)  //use rowDOM instead of DOM to allow select option window float above dialog
    aSelectMenu.DOM.data("path", newPath)
    valueArr.forEach((oneOption) => {
        var str = oneOption["displayName"] || oneOption["enumValue"]
        aSelectMenu.addOption(str)
    })
    aSelectMenu.callBack_clickOption = (optionText, optionValue, realMouseClick) => {
        aSelectMenu.changeName(optionText)
        if (realMouseClick) this.updateOriginObjectValue(aSelectMenu.DOM.data("path"), optionValue, "string")
    }
    var val = globalCache.searchValue(originElementInfo, newPath)
    if (val != null) {
        aSelectMenu.triggerOptionValue(val)
    }
}

newTwinDialog.prototype.updateOriginObjectValue=function(pathArr,newVal,dataType){
    if(["double","boolean","float","integer","long"].includes(dataType)) newVal=Number(newVal)
    if(pathArr.length==0) return;
    var theJson=this.twinInfo
    for(var i=0;i<pathArr.length;i++){
        var key=pathArr[i]

        if(i==pathArr.length-1){
            theJson[key]=newVal
            break
        }
        if(theJson[key]==null) theJson[key]={}
        theJson=theJson[key]
    }
}

newTwinDialog.prototype.treeLineDiv = function(typeNumber) {
    var reDiv=$('<div style="margin-left:10px;width:15px;height: 100%;float: left"></div>')
    if(typeNumber==1){
        reDiv.append($('<div class="w3-border-bottom w3-border-left" style="width:100%;height:50%;"></div><div class="w3-border-left" style="width:100%;height:50%;"></div>'))
    }else if(typeNumber==2){
        reDiv.append($('<div class="w3-border-left" style="width:100%;height:50%;"></div><div class="w3-border-left" style="width:100%;height:50%;"></div>'))
    }else if(typeNumber==3){
        reDiv.append($('<div class="w3-border-bottom w3-border-left" style="width:100%;height:50%;">'))
    }else if(typeNumber==4){
        
    }
    return reDiv
}

module.exports = new newTwinDialog();
},{"../msalHelper":18,"./globalCache":21,"./modelAnalyzer":22,"./simpleSelectMenu":33}],27:[function(require,module,exports){
const globalCache=require("./globalCache")
const msalHelper=require("../msalHelper")
const simpleConfirmDialog = require("./simpleConfirmDialog")

function projectSettingDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:101" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

projectSettingDialog.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="projectIsChanged"){
        this.contentInitialized=false
        this.DOM.empty()
        this.DOM.hide()
    }
}

projectSettingDialog.prototype.popup = function () {
    this.DOM.show()
    if(this.contentInitialized)return;
    this.contentInitialized=true; 
    this.DOM.css({"width":"420px","padding-bottom":"3px"})
    this.DOM.append($('<div style="height:40px;margin-bottom:2px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.2em">Setting</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.DOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    var tabControl=$('<div class="w3-bar w3-light-gray"></div>')
    var layoutBtn=$('<button class="w3-bar-item w3-button ">Layout</button>')
    var visualSchemaBtn=$('<button class="w3-bar-item w3-button">Visual Schema</button>')
    tabControl.append(layoutBtn,visualSchemaBtn)
    this.DOM.append(tabControl)

    this.layoutContentDiv=$('<div class="w3-animate-opacity" style="padding:10px;display:none"></div>')
    this.visualSchemaContentDiv=$('<div class="w3-animate-opacity" style="padding:10px;display:none"></div>')
    this.DOM.append(this.layoutContentDiv,this.visualSchemaContentDiv)
    this.fillLayoutDivContent()
    this.fillVisualSchemaContent()

    layoutBtn.on("click",()=>{
        layoutBtn.addClass("w3-white")
        visualSchemaBtn.removeClass("w3-white")
        this.visualSchemaContentDiv.hide()
        this.layoutContentDiv.show()
    })

    visualSchemaBtn.on("click",()=>{
        layoutBtn.removeClass("w3-white")
        visualSchemaBtn.addClass("w3-white")
        this.visualSchemaContentDiv.show()
        this.layoutContentDiv.hide()
    })

    layoutBtn.trigger("click")
}

projectSettingDialog.prototype.fillLayoutDivContent = function () {
    var showOtherUserLayoutCheck = $('<input class="w3-check" style="width:20px;margin-left:10px;margin-right:10px" type="checkbox">')
    var showOtherUserLayoutText = $('<label style="padding:2px 8px;">Show shared layouts from other users</label>')
    this.layoutContentDiv.append(showOtherUserLayoutCheck, showOtherUserLayoutText)
    if(this.showSharedLayouts) showOtherUserLayoutCheck.prop( "checked", true );
    showOtherUserLayoutCheck.on("change",()=>{
        this.showSharedLayouts=showOtherUserLayoutCheck.prop('checked')
        this.refillLayouts()
    })


    var layoutsDiv=$('<div class="w3-border" style="margin-top:10px;max-height:200px;overflow-x:hidden;overflow-y:auto"></div>')
    this.layoutContentDiv.append(layoutsDiv)
    this.layoutsDiv=layoutsDiv

    this.refillLayouts()
}


projectSettingDialog.prototype.fillVisualSchemaContent= function () {
    var shareSelfVisualSchemaCheck = $('<input class="w3-check" style="width:20px;margin-left:10px;margin-right:10px" type="checkbox">')
    var shareSelfVisualSchemaText = $('<label style="padding:2px 8px;">Share my own visual legend</label>')
    this.visualSchemaContentDiv.append(shareSelfVisualSchemaCheck, shareSelfVisualSchemaText)

    if(globalCache.visualDefinition["default"].isShared) shareSelfVisualSchemaCheck.prop( "checked", true );
    
    shareSelfVisualSchemaCheck.on("change", async () => {
        globalCache.visualDefinition["default"].isShared=shareSelfVisualSchemaCheck.prop('checked')

        var visualSchemaName = "default" //fixed in current version, there is only "default" schema for each user
        try {
            await msalHelper.callAPI("digitaltwin/setVisualSchemaSharedFlag", "POST", { "visualSchema": visualSchemaName, "isShared": shareSelfVisualSchemaCheck.prop('checked') }, "withProjectID")
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
        }
    })

    var visualSchemaDiv=$('<div class="w3-border" style="margin-top:10px;max-height:200px;overflow-x:hidden;overflow-y:auto"></div>')
    this.visualSchemaContentDiv.append(visualSchemaDiv)
    this.visualSchemaDiv=visualSchemaDiv

    this.refillVisualSchemas()
}

projectSettingDialog.prototype.refillVisualSchemas=function(){
    this.visualSchemaDiv.empty()
    var selfSchema
    for (var ind in globalCache.visualDefinition) {
        var oneSchema=globalCache.visualDefinition[ind]
        if(oneSchema.owner!=null && oneSchema.owner!=globalCache.accountInfo.id) this.addOneVisualSchema(oneSchema,this.visualSchemaDiv)
        else selfSchema=oneSchema
    }
    this.addOneVisualSchema(selfSchema,this.visualSchemaDiv)
}

projectSettingDialog.prototype.addOneVisualSchema=function(oneSchemaObj,parentDiv){
    var owner= oneSchemaObj.owner || globalCache.accountInfo.id
    
    var oneSchemaRow=$('<a href="#" class="w3-bar w3-button w3-border-bottom"></a>')
    parentDiv.append(oneSchemaRow)
    var lblStr=(owner==globalCache.accountInfo.id)?"Self":"Shared by "+owner
    //var nameLbl=$('<a style="text-align:left;color:grey;margin:5px 0px;display:block">'+lblStr+'</a>')
    var titleRow=$('<a href="#" class="w3-bar w3-text-grey"  ></a>')
    oneSchemaRow.append(titleRow)
    var nameLbl=$('<a class="w3-bar-item w3-button" >'+lblStr+'</a>')
    var copyBtn=$('<button class="w3-ripple w3-bar-item w3-button w3-right w3-lime w3-hover-amber">Copy</button>')
    titleRow.append(nameLbl)
    if(owner!=globalCache.accountInfo.id) titleRow.append(copyBtn)

    var detail=oneSchemaObj.detail

    copyBtn.on("click", async ()=>{
        //replace self visual schema
        globalCache.visualDefinition["default"].detail=JSON.parse(JSON.stringify(detail))
        this.refillVisualSchemas()
        try{
            await msalHelper.callAPI("digitaltwin/saveVisualDefinition", "POST", {"visualDefinitionJson":JSON.stringify(detail)},"withProjectID")
        }catch(e){
            console.log(e)
            if(e.responseText) alert(e.responseText)
        }
    })

    for(var modelID in detail){
        var iconDOM=globalCache.generateModelIcon(modelID)
        oneSchemaRow.append(iconDOM)
    }

}

projectSettingDialog.prototype.refillLayouts=function(){
    this.layoutsDiv.empty()
    var projectInfo=globalCache.findProjectInfo(globalCache.currentProjectID)
    var defaultLayoutName=projectInfo.defaultLayout

    if(this.showSharedLayouts){
        for (var ind in globalCache.layoutJSON) {
            var oneLayoutObj=globalCache.layoutJSON[ind]
            if(oneLayoutObj.owner!=globalCache.accountInfo.id) {
                this.addOneLayoutBar(oneLayoutObj,this.layoutsDiv,defaultLayoutName)
            }
        }
    }
    for (var ind in globalCache.layoutJSON) {
        var oneLayoutObj=globalCache.layoutJSON[ind]
        if(oneLayoutObj.owner!=globalCache.accountInfo.id) continue
        this.addOneLayoutBar(oneLayoutObj,this.layoutsDiv,defaultLayoutName)
    }
    
}

projectSettingDialog.prototype.addOneLayoutBar=function(oneLayoutObj,parentDiv,defaultLayoutName){
    var layoutName = oneLayoutObj.name
    var sharedFlag = oneLayoutObj.isShared

    var selfLayout=(oneLayoutObj.owner==globalCache.accountInfo.id)

    var oneLayout=$('<a href="#" class="w3-bar w3-button w3-border-bottom"></a>')
    parentDiv.append(oneLayout)

    var nameLbl=$('<a class="w3-bar-item w3-button" href="#">'+layoutName+'</a>')
    var defaultLbl=$("<a class='w3-bar-item' style='font-size:9px;padding:1px 2px;margin-top:9px;border-radius: 2px;'></a>")
    
    oneLayout.data("layoutObj",oneLayoutObj)

    oneLayout.data("defaultLbl",defaultLbl)
    oneLayout.append(nameLbl,defaultLbl)

    if(layoutName!=defaultLayoutName) this.showAsNotDefaultLayoutLbl(oneLayout)
    else this.showAsDefaultLayoutLbl(oneLayout)

    if(selfLayout){
        var str=(sharedFlag)?"Shared":"Share"
        var shareBtn=$('<button class="w3-ripple w3-bar-item w3-button w3-right w3-hover-amber">'+str+'</button>')
        oneLayout.data("shareBtn",shareBtn)
        
        var deleteBtn=$('<button class="w3-bar-item w3-button w3-right w3-hover-amber"><i class="fa fa-trash fa-lg"></i></button>')
        oneLayout.append(shareBtn,deleteBtn)
        if(!sharedFlag) shareBtn.hide()
        deleteBtn.hide()
    
        oneLayout.hover(()=>{
            oneLayout.data("defaultLbl").show()
            var isShared=oneLayout.data("layoutObj").isShared
            if(!isShared) shareBtn.show()
            deleteBtn.show()
        },()=>{
            if(!oneLayout.data("defaultLbl").hasClass("w3-lime")) oneLayout.data("defaultLbl").hide()
            var isShared=oneLayout.data("layoutObj").isShared
            if(!isShared) shareBtn.hide()
            deleteBtn.hide()
        })
        oneLayout.on("click",()=>{
            var projectInfo=globalCache.findProjectInfo(globalCache.currentProjectID)
            console.log(projectInfo.defaultLayout)
            if(layoutName!=projectInfo.defaultLayout) this.setAsDefaultLayout(oneLayout)
            else this.setAsDefaultLayout()
        })
        deleteBtn.on("click",()=>{
            this.deleteLayout(oneLayout)
            return false
        })
        shareBtn.on("click",()=>{
            this.clickShareLayoutBtn(oneLayout)
            return false
        })    
    }else{
        oneLayout.addClass("w3-gray","w3-hover-gray")
        var copyBtn=$('<button class="w3-ripple w3-bar-item w3-button w3-right w3-lime w3-hover-amber">Copy</button>')
        oneLayout.append(copyBtn)
        copyBtn.on("click",()=>{
            this.copyLayout(oneLayout.data("layoutObj"))
            return false
        }) 
    }    
}

projectSettingDialog.prototype.copyLayout=async function(dict){
    var layoutDict=dict.detail
    if(layoutDict["edges"]==null) layoutDict["edges"]={}    
    var saveLayoutObj={"layouts":{}}
    saveLayoutObj["layouts"][dict.oname]=JSON.stringify(layoutDict)  

    globalCache.recordSingleLayout(layoutDict,globalCache.accountInfo.id,dict.oname,false)
    try{
        await msalHelper.callAPI("digitaltwin/saveLayout", "POST", saveLayoutObj,"withProjectID")
        this.broadcastMessage({ "message": "layoutsUpdated"})
        this.refillLayouts()
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    }
}

projectSettingDialog.prototype.clickShareLayoutBtn=async function(oneLayoutDOM){
    var isShared=oneLayoutDOM.data("layoutObj").isShared
    var theBtn=oneLayoutDOM.data("shareBtn")
    isShared=!isShared
    oneLayoutDOM.data("layoutObj").isShared=isShared
    if(!isShared) theBtn.text("Share")
    else theBtn.text("Shared")
    
    var layoutName=oneLayoutDOM.data("layoutObj").name 
    try {
        await msalHelper.callAPI("digitaltwin/setLayoutSharedFlag", "POST", {"layout":layoutName,"isShared":isShared },"withProjectID")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    } 
}


projectSettingDialog.prototype.deleteLayout=async function(oneLayoutDOM){
    var layoutName=oneLayoutDOM.data("layoutObj").name 
    var confirmDialogDiv=new simpleConfirmDialog()

    confirmDialogDiv.show(
        { width: "250px" },
        {
            title: "Confirm"
            , content: "Confirm deleting layout \"" + layoutName + "\"?"
            , buttons:[
                {
                    colorClass: "w3-red w3-hover-pink", text: "Confirm", "clickFunc": async () => {
                        delete globalCache.layoutJSON[layoutName]
                        if (layoutName == globalCache.currentLayoutName) globalCache.currentLayoutName = null
                        confirmDialogDiv.close()
                        this.broadcastMessage({ "message": "layoutsUpdated"})
                        oneLayoutDOM.remove()
                        try{
                            await msalHelper.callAPI("digitaltwin/deleteLayout", "POST", { "layoutName": layoutName },"withProjectID")
                        }catch(e){
                            console.log(e)
                            if(e.responseText) alert(e.responseText)
                        }
                    }
                },
                {
                    colorClass: "w3-gray",text: "Cancel", "clickFunc": () => {
                        confirmDialogDiv.close()
                }}
            ]
        }
    )
}

projectSettingDialog.prototype.showAsDefaultLayoutLbl=async function(oneLayoutDOM){
    var defaultLbl=oneLayoutDOM.data("defaultLbl")
    defaultLbl.show()
    defaultLbl.text("Default")
    defaultLbl.addClass("w3-lime")
}

projectSettingDialog.prototype.showAsNotDefaultLayoutLbl=async function(oneLayoutDOM){
    var defaultLbl=oneLayoutDOM.data("defaultLbl")
    defaultLbl.hide()
    defaultLbl.text("Set As Default")
    defaultLbl.removeClass("w3-lime")
}

projectSettingDialog.prototype.setAsDefaultLayout=async function(oneLayoutDOM){
    this.layoutsDiv.children('a').each((index,aLayout)=>{
        this.showAsNotDefaultLayoutLbl($(aLayout))
    })

    if(oneLayoutDOM==null){ //remove default layout
        var layoutName=""
    }else{
        this.showAsDefaultLayoutLbl($(oneLayoutDOM))
        layoutName=oneLayoutDOM.data("layoutObj").name 
    }
       
    var projectInfo=globalCache.findProjectInfo(globalCache.currentProjectID)
    projectInfo.defaultLayout=layoutName
    //update database
    try {
        await msalHelper.callAPI("accountManagement/setProjectDefaultLayout", "POST", {"defaultLayout":layoutName },"withProjectID")
    }catch(e){
        console.log(e)
        if(e.responseText) alert(e.responseText)
    } 
}

module.exports = new projectSettingDialog();
},{"../msalHelper":18,"./globalCache":21,"./simpleConfirmDialog":31}],28:[function(require,module,exports){
const globalCache = require("./globalCache")
const modelAnalyzer = require("./modelAnalyzer");

function scriptTestDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:100" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

scriptTestDialog.prototype.popup = async function(inputsArr,twinName,formulaTwinModel,valueTemplate) {
    this.scriptContent=""
    this.selfTwinName=twinName
    this.valueTemplate=valueTemplate
    this.DOM.show()
    this.DOM.empty()
    
    this.DOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Twin Data Processing Testflight</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.DOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.DOM.hide() })

    this.contentDOM = $('<div class="w3-container" style="width:420px;font-size:1.2em"></div>')
    this.DOM.append(this.contentDOM)

    var twinNameLbl=this.generateNameLabel("Twin Name","10px")
    twinNameLbl.append($('<label class="w3-text-gray">'+twinName+'</label>'))
    this.contentDOM.append(twinNameLbl)

    var twinNameLbl=this.generateNameLabel("Model","10px")
    twinNameLbl.append($('<label class="w3-text-gray">'+formulaTwinModel+'</label>'))
    this.contentDOM.append(twinNameLbl)

    this.contentDOM.append(this.generateNameLabel("Inputs","10px"))
    
    var aTable=$('<table class="w3-text-gray" style="border-collapse: collapse;font-size:.8em;width:100%"></table>')
    this.contentDOM.append(aTable)
    aTable.append($('<tr><td class="w3-light-gray w3-border"></td><td class="w3-light-gray w3-border" style="font-weight:bold;text-align:center">Twin</td><td class="w3-light-gray w3-border" style="font-weight:bold;text-align:center">Property Path</td><td class="w3-light-gray w3-border" style="font-weight:bold;text-align:center">Value</td></tr>'))

    var valueEditorArr=[]
    inputsArr.forEach(oneProperty=>{
        var tr=$('<tr></tr>')
        var td0=$('<td class="w3-border" style="padding:0px 10px"><i class="fas fa-unlock"></i></td>')
        var td1=$('<td class="w3-light-gray w3-border" style="padding:0px 10px">'+oneProperty.twinName+'</td>')
        var td2=$('<td class="w3-light-gray w3-border" style="padding:0px 10px">'+oneProperty.path+'</td>')
        var td3=$('<td class="w3-border" style="padding:0px 10px"></td>')
        var valueType=this.findPropertyType(oneProperty.twinName_origin,oneProperty.path)
        var valueEdit=$('<input type="text" style="outline:none;border:none;padding:5px 0px;width:100%"  placeholder="type: ' +valueType + '"/>');
        td0.children(':first').on("click",(e)=>{
            var lockDom=$(e.target)
            if(lockDom.hasClass("fa-unlock")){lockDom.removeClass("fa-unlock");lockDom.addClass("fa-lock");lockDom.addClass("w3-text-amber")}
            else {lockDom.removeClass("fa-lock");lockDom.addClass("fa-unlock");lockDom.removeClass("w3-text-amber")}
        })
        valueEditorArr.push({"type":valueType,"editor":valueEdit,"lockIcon":td0.children(':first')
            ,"twinName":oneProperty.twinName_origin
            ,"inputPath":oneProperty.path
        })
        aTable.append(tr.append(td0,td1,td2,td3))
        td3.append(valueEdit)
    })

    var randomInputBtn = $('<button class="w3-ripple w3-card w3-margin-right w3-light-gray w3-button w3-hover-pink w3-margin-top w3-margin-bottom">Generate Random Input & Execute</button>')

    randomInputBtn.on("click",()=>{
        valueEditorArr.forEach(ele=>{
            if(ele.lockIcon.hasClass("fa-lock")) return;
            var dataType=ele.type
            var theEditor=ele.editor
            theEditor.val(this.generateRandomValue(dataType))
        })

        //do execute automatically
        this.testFlight(valueEditorArr)
    })


    var executeScriptBtn = $('<button class="w3-ripple w3-card w3-button w3-amber w3-hover-pink w3-margin-top w3-margin-bottom">Execute</button>')
    executeScriptBtn.on("click",()=>{this.testFlight(valueEditorArr)})
    this.contentDOM.append(randomInputBtn,executeScriptBtn)

    var lbl1=$('<label class="w3-text-amber" style="font-style: italic;font-size:11px;display:block">You can still change the calculation script in the infomration panel and test the modified script immediately</label>')
    this.contentDOM.append(lbl1)

    var resultDiv=$('<div style="width:100%;height:140px;padding:5px"/>').addClass("w3-light-gray w3-text-gray w3-border w3-margin-bottom");
    resultDiv.text("Calculation result...")
    this.contentDOM.append(resultDiv)
    this.resultDiv=resultDiv
}

scriptTestDialog.prototype.testFlight=function(valueEditorArr){
    var _self=JSON.parse(JSON.stringify(this.valueTemplate))
    var _twinVal={}
    
    valueEditorArr.forEach(ele=>{
        var obj=null
        if(ele.twinName!=this.selfTwinName){
            _twinVal[ele.twinName]={}
            obj=_twinVal[ele.twinName]
        }else{
            obj=_self
        }
        var rootObj=obj
        for(var i=0;i<ele.inputPath.length-1;i++){
            var pname=ele.inputPath[i]
            if(rootObj[pname]==null) rootObj[pname]={}
            rootObj=rootObj[pname]
        }
        var originVal=ele.editor.val()
        if(ele.type=="boolean") var theVal= (originVal === 'true')
        else if(ele.type=="double"||ele.type=="float"||ele.type=="integer"||ele.type=="long") theVal=parseFloat(originVal)
        else theVal=originVal
        rootObj[ele.inputPath[ele.inputPath.length-1]]=theVal
    })

    this.resultDiv.empty()
    try{
        var evalStr=this.scriptContent+"\n_self"
        var result=eval(evalStr) // jshint ignore:line
        this.resultDiv.append($('<pre style="margin:0px;font-size:11px" id="json">'+JSON.stringify(result,null,2)+'</pre>')) 
    }catch(e){
        this.resultDiv.append($('<pre style="margin:0px;font-size:11px" id="json">'+e+'</pre>'))
    }
}

scriptTestDialog.prototype.generateRandomValue=function(dataType){
    var randData=Math.random()
    if(dataType=="boolean"){
        return (randData>0.5)
    }else if(dataType=="dateTime"){
        return new Date().toISOString()
    }else if(dataType=="date"){
        return (new Date().toISOString()).split("T")[0]
    }else if(dataType=="time"){
        return ("T"+((new Date().toISOString()).split("T")[1]))
    }else if(dataType=="double" || dataType=="float"){
        return parseFloat((randData*100).toFixed(1))
    }else if(dataType=="integer" || dataType=="long"){
        return parseInt(randData*100)
    }else{
        return null
    }
}

scriptTestDialog.prototype.findPropertyType=function(twinName,propertyPath){
    var dbtwin=globalCache.getSingleDBTwinByName(twinName)
    var modelID=dbtwin["modelID"]
    var editableProperties=modelAnalyzer.DTDLModels[modelID].editableProperties
    var theType=editableProperties
    for(var i=0;i<propertyPath.length;i++){
        var ele=propertyPath[i]
        if(theType[ele]) theType=theType[ele]
        else return null
    }
    return theType
}


scriptTestDialog.prototype.generateNameLabel=function(str,paddingTop){
    var keyDiv = $("<div><div class='w3-border' style='background-color:#f6f6f6;display:inline;padding:.1em .3em .1em .3em;margin-right:.3em'>"+str+"</div></div>")
    keyDiv.css("padding-top",paddingTop)
    return keyDiv
}

module.exports = new scriptTestDialog();
},{"./globalCache":21,"./modelAnalyzer":22}],29:[function(require,module,exports){
const msalHelper=require("../msalHelper")
const globalCache = require("../sharedSourceFiles/globalCache");

function serviceWorkerHelper(){
    this.projectID=null
    this.allLiveMonitor={}
    setInterval(()=>{
        if(this.projectID==null) return;
        this.subscribeImportantEvent(this.projectID)

        for(var ind in this.allLiveMonitor){
            var aLiveProperty=this.allLiveMonitor[ind]
            this.subscribeLiveProperty(aLiveProperty.twinID,aLiveProperty.propertyPath)
        }

    },8*60*1000) //every 8 minute renew the service worker subscription
}

serviceWorkerHelper.prototype.subscribeImportantEvent = async function (projectID) {    
    var subscription=await this.createSubscription()
    if(subscription==null) return;
    try {
        var payload={
            type:'events',
            serviceWorkerSubscription:JSON.stringify(subscription)
        }
        msalHelper.callAPI("digitaltwin/serviceWorkerSubscription", "POST", payload, "withProjectID")
    } catch (e) {
        console.log(e)
    }
}

serviceWorkerHelper.prototype.subscribeLiveProperty = async function (twinID,propertyPath) {    
    var subscription=await this.createSubscription()
    if(subscription==null) return;
    try {
        var payload={
            type:'propertyValue',
            serviceWorkerSubscription:JSON.stringify(subscription),
            twinID:twinID,
            propertyPath:propertyPath
        }
        msalHelper.callAPI("digitaltwin/serviceWorkerSubscription", "POST", payload, "withProjectID")
    } catch (e) {
        console.log(e) 
    }
}

serviceWorkerHelper.prototype.unsubscribeLiveProperty = async function (twinID,propertyPath) {    
    try {
        msalHelper.callAPI("digitaltwin/serviceWorkerUnsubscription", "POST", {twinID:twinID,propertyPath:propertyPath}, "withProjectID")
    } catch (e) {
        console.log(e)
    }
}

serviceWorkerHelper.prototype.createSubscription = async function () {
    if (!('serviceWorker' in navigator)) return null;
    //this public key should be the one used in backend server side for pushing message (in azureiotrocksfunction)
    const publicVapidKey = 'BCxvFqk0czIkCTblAMy80fMWTj2WaAkeXCyp98-S2MiVrTL59u046eLRrTBImo9ZCWAQ3Yqj_7PwEOuyhDmC-WY';
    var subscription = null
    try {
        const registration = await navigator.serviceWorker.register('/worker.js', { scope: '/' });
        subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: publicVapidKey
        });
        navigator.serviceWorker.onmessage = (e)=> {
            this.processLiveMessage(e.data)
            this.broadcastMessage({ "message": "liveData","body":e.data })
        };
    } catch (e) {
        console.log(e)
    }
    return subscription;
}

serviceWorkerHelper.prototype.processLiveMessage=function(msgBody){
    //console.log(msgBody)
    if(msgBody.connectionState && msgBody.projectID==globalCache.currentProjectID){
        var twinID=msgBody.twinID
        var twinDBInfo=globalCache.DBTwins[twinID]
        if(msgBody.connectionState=="deviceConnected") twinDBInfo.connectState=true
        else twinDBInfo.connectState=false
        //console.log(msgBody)
    }else if(msgBody.propertyPath){
        var twinInfo=globalCache.storedTwins[msgBody.twinID]
        this.updateOriginObjectValue(twinInfo,msgBody.propertyPath,msgBody.value)
    }
}

serviceWorkerHelper.prototype.updateOriginObjectValue=function(nodeInfo, pathArr, newVal) {
    if (pathArr.length == 0) return;
    var theJson = nodeInfo
    for (var i = 0; i < pathArr.length; i++) {
        var key = pathArr[i]

        if (i == pathArr.length - 1) {
            theJson[key] = newVal
            break
        }
        if (theJson[key] == null) theJson[key] = {}
        theJson = theJson[key]
    }
}

serviceWorkerHelper.prototype.rxMessage=function(msgPayload){
    if(msgPayload.message=="projectIsChanged"){
        for(var ind in this.allLiveMonitor) delete this.allLiveMonitor[ind]
        this.projectID=msgPayload.projectID
        this.subscribeImportantEvent(msgPayload.projectID)
    }else if(msgPayload.message=="addLiveMonitor"){
        var str=this.generateID(msgPayload.twinID,msgPayload.propertyPath)
        this.allLiveMonitor[str]=msgPayload
        this.subscribeLiveProperty(msgPayload.twinID,msgPayload.propertyPath)
    }else if(msgPayload.message=="removeLiveMonitor"){
        var str=this.generateID(msgPayload.twinID,msgPayload.propertyPath)
        delete this.allLiveMonitor[str]
        this.unsubscribeLiveProperty(msgPayload.twinID,msgPayload.propertyPath)
    }
}

serviceWorkerHelper.prototype.generateID=function(twinID,propertyPath){
    return twinID+"."+propertyPath.join(".")
}


module.exports = new serviceWorkerHelper();
},{"../msalHelper":18,"../sharedSourceFiles/globalCache":21}],30:[function(require,module,exports){
function simpleChart(parentDom,xLength,cssOptions,customDrawing){
    this.chartDOM=$("<div/>")
    parentDom.append(this.chartDOM)
    if(customDrawing){
        customDrawing(this.chartDOM)
    }
    this.canvas = $('<canvas></canvas>')
    this.canvas.css(cssOptions)
    this.chartDOM.append(this.canvas)
    
    this.chart=new Chart(this.canvas, {
        type: "line",
        data: {
            labels: [],
            datasets: [{stepped:true, data: []}]
        },
        options: {
            animation: false,
            datasets: {
                line: {
                    spanGaps:true,
                    borderColor: "rgba(0,0,255,0.7)",
                    borderWidth:1,
                    pointRadius:0
                }
            },
            plugins:{
                legend: { display: false },
                tooltip:{enabled:false}
            },
            scales: {
                x:{grid:{display:false},ticks:{display:false}}
                ,y:{grid:{tickLength:0},ticks:{font:{size:9}}}
                ,x2: {position:'top',grid:{display:false},ticks:{display:false}}
                ,y2: {position:'right',grid:{display:false},ticks:{display:false}}     
            }
            
        }
    });
    this.setXLength(xLength)
}

simpleChart.prototype.setDataArr=function(dataArr){
    this.chart.data.datasets[0].data=dataArr
    this.chart.update()
}

simpleChart.prototype.addDataValue=function(dataIndex,value){
    var dataArr=this.chart.data.datasets[0].data

    var totalPoints=dataArr.length

    if(this.lastDataIndex==null) this.lastDataIndex=dataIndex-1
    if(dataIndex<this.lastDataIndex){
        if(this.lastDataIndex-dataIndex>=totalPoints) return; //ignore receiving too old points
        var diff=this.lastDataIndex - dataIndex
        dataArr[totalPoints-1-diff]=value
    }else{
        var numOfPassedPoints=dataIndex-this.lastDataIndex
        dataArr=dataArr.slice(numOfPassedPoints)
        dataArr[totalPoints-1]=value
    }
    this.setDataArr(dataArr)
    this.lastDataIndex=dataIndex
}

simpleChart.prototype.setXLength=function(xlen){
    var labels=this.chart.data.labels
    labels.length=0
    for(var i=0;i<xlen;i++) labels.push(i)
    //shorten or expand the length of data array
    var dataArr=this.chart.data.datasets[0].data
    if(dataArr.length>xlen) dataArr=dataArr.slice(dataArr.length-xlen)
    else if(dataArr.length<xlen){
        var numberToAdd=xlen-dataArr.length
        var tmpArr=[]
        tmpArr[numberToAdd-1]=null
        dataArr=tmpArr.concat(dataArr)
    }
    this.chart.data.datasets[0].data=dataArr
    this.chart.update()
}

simpleChart.prototype.destroy=function(){
    this.chartDOM.remove()
}

module.exports = simpleChart;
},{}],31:[function(require,module,exports){
const globalCache=require('./globalCache')
function simpleConfirmDialog(){
    this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:102" class="w3-card-4"></div>')
    globalCache.makeDOMDraggable(this.DOM)
    //this.DOM.css("overflow","hidden")
}

simpleConfirmDialog.prototype.show=function(cssOptions,otherOptions){
    this.DOM.css(cssOptions)
    this.DOM.append($('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.2em">' + otherOptions.title + '</div></div>'))
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    this.DOM.children(':first').append(closeButton)
    closeButton.on("click", () => { this.close() })

    var dialogDiv=$('<div class="w3-container" style="margin-top:10px;margin-bottom:10px"></div>')
    if(otherOptions.customDrawing){
        otherOptions.customDrawing(dialogDiv)
    }else{
        dialogDiv.text(otherOptions.content)
    }
    this.DOM.append(dialogDiv)
    this.dialogDiv=dialogDiv

    this.bottomBar=$('<div class="w3-bar"></div>')
    this.DOM.append(this.bottomBar)

    if(!otherOptions.buttons) otherOptions.buttons=[]
    otherOptions.buttons.forEach(btn=>{
        var aButton=$('<button class="w3-ripple w3-button w3-right '+(btn.colorClass||"")+'" style="margin-right:2px;margin-left:2px">'+btn.text+'</button>')
        aButton.on("click",()=> { btn.clickFunc()  }  )
        this.bottomBar.append(aButton)    
    })
    $("body").append(this.DOM)
}

simpleConfirmDialog.prototype.close=function(){
    this.DOM.remove()
}

module.exports = simpleConfirmDialog;
},{"./globalCache":21}],32:[function(require,module,exports){
function simpleExpandableSection(titleStr,parentDOM,options) {
    this.expandStatus=false
    options=options||{}
    var marginTop=10
    if(options.marginTop!=null) marginTop=options.marginTop
    this.headerDOM = $(`<button class="w3-button w3-block w3-light-grey w3-left-align w3-border-bottom w3-hover-amber w3-text-gray" style="margin-top:${marginTop}px;font-weight:bold"><a>${titleStr}</a><i class="w3-margin-left fas fa-caret-up"></i></button>`)
    this.listDOM = $('<div class="w3-container w3-hide" style="padding-top:2px"></div>')

    this.headerTextDOM=this.headerDOM.children(":first")

    this.triangle=this.headerDOM.children('i').eq(0)
    parentDOM.append(this.headerDOM, this.listDOM)
    this.headerDOM.on("click", (evt) => {
        if(this.expandStatus) this.shrink()
        else this.expand()
        this.callBack_change(this.expandStatus)
        return false;
    });
    this.callBack_change=(status)=>{}
}

simpleExpandableSection.prototype.deleteSelf=function(){
    this.headerDOM.remove()
    this.listDOM.remove()
}

simpleExpandableSection.prototype.expand=function(){
    this.listDOM.addClass("w3-show")
    this.triangle.addClass("fa-caret-down")
    this.triangle.removeClass("fa-caret-up")
    this.expandStatus = true
}

simpleExpandableSection.prototype.shrink=function(){
    this.listDOM.removeClass("w3-show")
    this.triangle.removeClass("fa-caret-down")
    this.triangle.addClass("fa-caret-up")
    this.expandStatus = false
}

module.exports = simpleExpandableSection;
},{}],33:[function(require,module,exports){
function simpleSelectMenu(buttonName,options){
    options=options||{} //{isClickable:1,withBorder:1,fontSize:"",colorClass:"",buttonCSS:""}
    if(options.isClickable){
        this.isClickable=true
        this.DOM=$('<div class="w3-dropdown-click"></div>')
    }else{
        this.DOM=$('<div class="w3-dropdown-hover "></div>')
        this.DOM.on("mouseover",(e)=>{
            this.adjustDropDownPosition()
        })
    }


    //it seems that the select menu only can show outside of a parent scrollable dom when it is inside a w3-bar item... not very sure about why 
    var rowDOM=$('<div class="w3-bar" style="display:inline-block;margin-left:5px"></div>')
    rowDOM.css("width",(options.width||100)+"px")
    this.rowDOM=rowDOM
    this.rowDOM.append(this.DOM)
    
    this.button=$('<button class="w3-button" style="outline: none;"><a>'+buttonName+'</a><a style="font-weight:bold;padding-left:2px"></a><i class="fa fa-caret-down" style="padding-left:3px"></i></button>')
    if(options.withBorder) this.button.addClass("w3-border")
    if(options.fontSize) this.DOM.css("font-size",options.fontSize)
    if(options.colorClass) this.button.addClass(options.colorClass)
    if(options.width) this.button.css("width",options.width)
    if(options.buttonCSS) this.button.css(options.buttonCSS)
    if(options.adjustPositionAnchor) this.adjustPositionAnchor=options.adjustPositionAnchor

    this.optionContentDOM=$('<div class="w3-dropdown-content w3-bar-block w3-card-4"></div>')
    if(options.optionListHeight) this.optionContentDOM.css({"max-height":options.optionListHeight+"px","overflow-y":"auto","overflow-x":"visible"})
    if(options.optionListMarginTop) this.optionContentDOM.css({"margin-top":options.optionListMarginTop+"px"})
    if(options.optionListMarginLeft) this.optionContentDOM.css({"margin-left":options.optionListMarginLeft+"px"})
    
    this.DOM.append(this.button,this.optionContentDOM)
    this.curSelectVal=null;

    if(options.isClickable){
        this.button.on("click",(e)=>{
            this.adjustDropDownPosition()
            if(this.optionContentDOM.hasClass("w3-show"))  this.optionContentDOM.removeClass("w3-show")
            else{
                this.callBack_beforeClickExpand()
                this.optionContentDOM.addClass("w3-show")
            } 
            return false;
        })    
    }
}

simpleSelectMenu.prototype.shrink=function(){
    if(this.optionContentDOM.hasClass("w3-show"))  this.optionContentDOM.removeClass("w3-show")
}

simpleSelectMenu.prototype.adjustDropDownPosition=function(){
    if(!this.adjustPositionAnchor) return;
    var offset=this.DOM.offset()
    var newTop=offset.top-this.adjustPositionAnchor.top
    var newLeft=offset.left-this.adjustPositionAnchor.left
    this.optionContentDOM.css({"top":newTop+"px","left":newLeft+"px"})
}

simpleSelectMenu.prototype.findOption=function(optionValue){
    var options=this.optionContentDOM.children()
    for(var i=0;i<options.length;i++){
        var anOption=$(options[i])
        if(optionValue==anOption.data("optionValue")){
            return {"text":anOption.text(),"value":anOption.data("optionValue"),"colorClass":anOption.data("optionColorClass")}
        }
    }
}

simpleSelectMenu.prototype.findOptionByText=function(optionText){
    var options=this.optionContentDOM.children()
    for(var i=0;i<options.length;i++){
        var anOption=$(options[i])
        if(optionText==anOption.text()){
            return {"text":anOption.text(),"value":anOption.data("optionValue"),"colorClass":anOption.data("optionColorClass")}
        }
    }
}

simpleSelectMenu.prototype.addOptionArr=function(arr){
    arr.forEach(element => {
        this.addOption(element)
    });
}

simpleSelectMenu.prototype.addOption=function(optionText,optionValue,colorClass){
    var optionItem=$('<a href="#" class="w3-bar-item w3-button" style="white-space:nowrap">'+optionText+'</a>')
    if(colorClass) optionItem.addClass(colorClass)
    this.optionContentDOM.append(optionItem)
    optionItem.data("optionValue",optionValue||optionText)
    optionItem.data("optionColorClass",colorClass)
    optionItem.on('click',(e)=>{
        this.curSelectVal=optionItem.data("optionValue")
        if(this.isClickable){
            this.optionContentDOM.removeClass("w3-show")
        }else{
            this.DOM.removeClass('w3-dropdown-hover')
            this.DOM.addClass('w3-dropdown-click')
            setTimeout(() => { //this is to hide the drop down menu after click
                this.DOM.addClass('w3-dropdown-hover')
                this.DOM.removeClass('w3-dropdown-click')
            }, 100);
        }
        this.callBack_clickOption(optionText,optionItem.data("optionValue"),"realMouseClick",optionItem.data("optionColorClass"))
        return false
    })
}

simpleSelectMenu.prototype.changeName=function(nameStr1,nameStr2){
    this.button.children(":first").text(nameStr1)
    this.button.children().eq(1).text(nameStr2)
}

simpleSelectMenu.prototype.triggerOptionIndex=function(optionIndex){
    var theOption=this.optionContentDOM.children().eq(optionIndex)
    if(theOption.length==0) {
        this.curSelectVal=null;
        this.callBack_clickOption(null,null)
        return;
    }
    this.curSelectVal=theOption.data("optionValue")
    this.callBack_clickOption(theOption.text(),theOption.data("optionValue"),null,theOption.data("optionColorClass"))
}

simpleSelectMenu.prototype.triggerOptionValue=function(optionValue){
    var re=this.findOption(optionValue)
    if(re==null){
        this.curSelectVal=null
        this.callBack_clickOption(null,null)
    }else{
        this.curSelectVal=re.value
        this.callBack_clickOption(re.text,re.value,null,re.colorClass)
    }
}

simpleSelectMenu.prototype.triggerOptionText=function(optionText){
    var re=this.findOptionByText(optionText)
    if(re==null){
        this.curSelectVal=null
        this.callBack_clickOption(null,null)
    }else{
        this.curSelectVal=re.value
        this.callBack_clickOption(re.text,re.value,null,re.colorClass)
    }
}


simpleSelectMenu.prototype.clearOptions=function(optionText,optionValue){
    this.optionContentDOM.empty()
    this.curSelectVal=null;
}

simpleSelectMenu.prototype.callBack_clickOption=function(optiontext,optionValue,realMouseClick){
}

simpleSelectMenu.prototype.callBack_beforeClickExpand=function(optiontext,optionValue,realMouseClick){
}


module.exports = simpleSelectMenu;
},{}],34:[function(require,module,exports){
'use strict';

function simpleTree(DOM,options){
    this.DOM=DOM
    this.groupNodes=[] //each group header is one node
    this.selectedNodes=[];
    this.options=options || {}

    this.lastClickedNode=null;
}

simpleTree.prototype.scrollToLeafNode=function(aNode){
    var scrollTop=this.DOM.scrollTop()
    var treeHeight=this.DOM.height()
    var nodePosition=aNode.DOM.position().top //which does not consider parent DOM's scroll height
    //console.log(scrollTop,treeHeight,nodePosition)
    if(treeHeight-50<nodePosition){
        this.DOM.scrollTop(scrollTop + nodePosition-(treeHeight-50)) 
    }else if(nodePosition<50){
        this.DOM.scrollTop(scrollTop + (nodePosition-50)) 
    }
}

simpleTree.prototype.clearAllLeafNodes=function(){
    this.lastClickedNode=null
    this.groupNodes.forEach((gNode)=>{
        gNode.listDOM.empty()
        gNode.childLeafNodes.length=0
        gNode.refreshName()
    })
}

simpleTree.prototype.firstLeafNode=function(){
    if(this.groupNodes.length==0) return null;
    var firstLeafNode=null;
    this.groupNodes.forEach(aGroupNode=>{
        if(firstLeafNode!=null) return;
        if(aGroupNode.childLeafNodes.length>0) firstLeafNode=aGroupNode.childLeafNodes[0]
    })

    return firstLeafNode
}

simpleTree.prototype.nextGroupNode=function(aGroupNode){
    if(aGroupNode==null) return;
    var index=this.groupNodes.indexOf(aGroupNode)
    if(this.groupNodes.length-1>index){
        return this.groupNodes[index+1]
    }else{ //rotate backward to first group node
        return this.groupNodes[0] 
    }
}

simpleTree.prototype.nextLeafNode=function(aLeafNode){
    if(aLeafNode==null) return;
    var aGroupNode=aLeafNode.parentGroupNode
    var index=aGroupNode.childLeafNodes.indexOf(aLeafNode)
    if(aGroupNode.childLeafNodes.length-1>index){
        //next node is in same group
        return aGroupNode.childLeafNodes[index+1]
    }else{
        //find next group first node
        while(true){
            var nextGroupNode = this.nextGroupNode(aGroupNode)
            if(nextGroupNode.childLeafNodes.length==0){
                aGroupNode=nextGroupNode
            }else{
                return nextGroupNode.childLeafNodes[0]
            }
        }
    }
}

simpleTree.prototype.searchText=function(str){
    if(str=="") return null;
    //search from current select item the next leaf item contains the text
    var regex = new RegExp(str, 'i');
    var startNode
    if(this.selectedNodes.length==0) {
        startNode=this.firstLeafNode()
        if(startNode==null) return;
        var theStr=startNode.name;
        if(theStr.match(regex)!=null){
            //find target node 
            return startNode
        }
    }else startNode=this.selectedNodes[0]

    if(startNode==null) return null;
    
    var fromNode=startNode;
    while(true){
        var nextNode=this.nextLeafNode(fromNode)
        if(nextNode==startNode) return null;
        var nextNodeStr=nextNode.name;
        if(nextNodeStr.match(regex)!=null){
            //find target node
            return nextNode
        }else{
            fromNode=nextNode;
        }
    }    
}

simpleTree.prototype.getAllLeafNodeArr=function(){
    var allLeaf=[]
    this.groupNodes.forEach(gn=>{
        allLeaf=allLeaf.concat(gn.childLeafNodes)
    })
    return allLeaf;
}


simpleTree.prototype.addLeafnodeToGroup=function(groupName,obj,skipRepeat){
    var aGroupNode=this.findGroupNode(groupName)
    if(aGroupNode == null) return;
    aGroupNode.addNode(obj,skipRepeat)
}

simpleTree.prototype.removeAllNodes=function(){
    this.lastClickedNode=null
    this.groupNodes.length=0;
    this.selectedNodes.length=0;
    this.DOM.empty()
}

simpleTree.prototype.findGroupNode=function(groupName){
    var foundGroupNode=null
    this.groupNodes.forEach(aGroupNode=>{
        if(aGroupNode.name==groupName){
            foundGroupNode=aGroupNode
            return;
        }
    })
    return foundGroupNode;
}

simpleTree.prototype.delGroupNode=function(gnode){
    this.lastClickedNode=null
    gnode.deleteSelf()
}

simpleTree.prototype.deleteLeafNode=function(nodeName){
    this.lastClickedNode=null
    var findLeafNode=null
    this.groupNodes.forEach((gNode)=>{
        if(findLeafNode!=null) return;
        gNode.childLeafNodes.forEach((aLeaf)=>{
            if(aLeaf.name==nodeName){
                findLeafNode=aLeaf
                return;
            }
        })
    })
    if(findLeafNode==null) return;
    findLeafNode.deleteSelf()
}


simpleTree.prototype.insertGroupNode=function(obj,index){
    var aNewGroupNode = new simpleTreeGroupNode(this,obj)
    var existGroupNode= this.findGroupNode(aNewGroupNode.name)
    if(existGroupNode!=null) return;
    this.groupNodes.splice(index, 0, aNewGroupNode);

    if(index==0){
        this.DOM.append(aNewGroupNode.headerDOM)
        this.DOM.append(aNewGroupNode.listDOM)
    }else{
        var prevGroupNode=this.groupNodes[index-1]
        aNewGroupNode.headerDOM.insertAfter(prevGroupNode.listDOM)
        aNewGroupNode.listDOM.insertAfter(aNewGroupNode.headerDOM)
    }

    return aNewGroupNode;
}

simpleTree.prototype.addGroupNode=function(obj){
    var aNewGroupNode = new simpleTreeGroupNode(this,obj)
    var existGroupNode= this.findGroupNode(aNewGroupNode.name)
    if(existGroupNode!=null) return existGroupNode;
    this.groupNodes.push(aNewGroupNode);
    this.DOM.append(aNewGroupNode.headerDOM)
    this.DOM.append(aNewGroupNode.listDOM)
    return aNewGroupNode;
}

simpleTree.prototype.selectLeafNode=function(leafNode,mouseClickDetail){
    this.selectLeafNodeArr([leafNode],mouseClickDetail)
}
simpleTree.prototype.appendLeafNodeToSelection=function(leafNode){
    var newArr=[].concat(this.selectedNodes)
    newArr.push(leafNode)
    this.selectLeafNodeArr(newArr)
}

simpleTree.prototype.addNodeArrayToSelection=function(arr){
    var newArr = this.selectedNodes
    var filterArr=arr.filter((item) => newArr.indexOf(item) < 0)
    newArr = newArr.concat(filterArr)
    this.selectLeafNodeArr(newArr)
}

simpleTree.prototype.selectGroupNode=function(groupNode){
    if(this.callback_afterSelectGroupNode) this.callback_afterSelectGroupNode(groupNode.info)
}

simpleTree.prototype.selectLeafNodeArr=function(leafNodeArr,mouseClickDetail){
    for(var i=0;i<this.selectedNodes.length;i++){
        this.selectedNodes[i].dim()
    }
    this.selectedNodes.length=0;
    this.selectedNodes=this.selectedNodes.concat(leafNodeArr)
    for(var i=0;i<this.selectedNodes.length;i++){
        this.selectedNodes[i].highlight()
    }

    if(this.callback_afterSelectNodes) this.callback_afterSelectNodes(this.selectedNodes,mouseClickDetail)
}

simpleTree.prototype.dblClickNode=function(theNode){
    if(this.callback_afterDblclickNode) this.callback_afterDblclickNode(theNode)
}

simpleTree.prototype.sortAllLeaves=function(){
    this.groupNodes.forEach(oneGroupNode=>{oneGroupNode.sortNodesByName()})
}

//----------------------------------tree group node---------------
function simpleTreeGroupNode(parentTree,obj){
    this.parentTree=parentTree
    this.info=obj
    this.childLeafNodes=[] //it's child leaf nodes array
    this.name=obj.displayName;
    this.createDOM()
}

simpleTreeGroupNode.prototype.refreshName=function(){
    this.headerDOM.empty()
    var nameDiv=$("<div style='display:inline;padding-left:5px;padding-right:3px;vertical-align:middle'></div>")
    nameDiv.text(this.name)
    
    if(this.childLeafNodes.length>0) lblColor="w3-lime"
    else var lblColor="w3-gray" 
    this.headerDOM.css("font-weight","bold")

    
    if(this.parentTree.options.groupNodeIconFunc){
        var iconLabel=this.parentTree.options.groupNodeIconFunc(this)
        if(iconLabel){
            this.headerDOM.append(iconLabel)
            var rowHeight=iconLabel.height()
            nameDiv.css("line-height",rowHeight+"px")    
        }
    }
    
    var numberlabel=$("<label class='"+lblColor+"' style='display:inline;font-size:9px;padding:2px 4px;font-weight:normal;border-radius: 2px;'>"+this.childLeafNodes.length+"</label>")
    this.headerDOM.append(nameDiv,numberlabel)


    if(this.parentTree.options.groupNodeTailButtonFunc){
        var tailButton=this.parentTree.options.groupNodeTailButtonFunc(this)
        this.headerDOM.append(tailButton)
    }

    this.checkOptionHideEmptyGroup()

}
simpleTreeGroupNode.prototype.checkOptionHideEmptyGroup=function(){
    if (this.parentTree.options.hideEmptyGroup && this.childLeafNodes.length == 0) {
        this.shrink()
        this.headerDOM.hide()
        if (this.listDOM) this.listDOM.hide()
    } else {
        this.headerDOM.show()
        if (this.listDOM) this.listDOM.show()
    }

}
simpleTreeGroupNode.prototype.deleteSelf = function () {
    this.headerDOM.remove()
    this.listDOM.remove()
    var parentArr = this.parentTree.groupNodes
    const index = parentArr.indexOf(this);
    if (index > -1) parentArr.splice(index, 1);
}

simpleTreeGroupNode.prototype.createDOM=function(){
    this.headerDOM=$('<button class="w3-button w3-block w3-light-grey w3-left-align w3-border-bottom" style="position:relative"></button>')
    this.refreshName()
    this.listDOM=$('<div class="w3-container w3-hide w3-border" style="padding:8px"></div>')

    this.headerDOM.on("click",(evt)=> {
        if(this.listDOM.hasClass("w3-show")) this.listDOM.removeClass("w3-show")
        else this.listDOM.addClass("w3-show")

        this.parentTree.selectGroupNode(this)    
        return false;
    });
}

simpleTreeGroupNode.prototype.isOpen=function(){
    return  this.listDOM.hasClass("w3-show")
}


simpleTreeGroupNode.prototype.expand=function(){
    if(this.listDOM) this.listDOM.addClass("w3-show")
}

simpleTreeGroupNode.prototype.shrink=function(){
    if(this.listDOM) this.listDOM.removeClass("w3-show")
}

simpleTreeGroupNode.prototype.sortNodesByName=function(){
    var treeOptions=this.parentTree.options
    if(treeOptions.leafNameProperty) var leafNameProperty=treeOptions.leafNameProperty
    else leafNameProperty="$dtId"
    this.childLeafNodes.sort(function (a, b) { 
        var aName=a.name.toLowerCase()
        var bName=b.name.toLowerCase()
        return aName.localeCompare(bName) 
    });
    //this.listDOM.empty() //NOTE: Can not delete those leaf node otherwise the event handle is lost
    this.childLeafNodes.forEach(oneLeaf=>{this.listDOM.append(oneLeaf.DOM)})
}

simpleTreeGroupNode.prototype.addNode=function(obj,skipRepeat){
    var treeOptions=this.parentTree.options
    if(treeOptions.leafNameProperty) var leafNameProperty=treeOptions.leafNameProperty
    else leafNameProperty="$dtId"

    if(skipRepeat){
        var foundRepeat=false;
        this.childLeafNodes.forEach(aNode=>{
            if(aNode.name==obj[leafNameProperty]) {
                foundRepeat=true
                return;
            }
        })
        if(foundRepeat) return;
    }

    var aNewNode = new simpleTreeLeafNode(this,obj)
    this.childLeafNodes.push(aNewNode)
    this.refreshName()
    this.listDOM.append(aNewNode.DOM)
}

//----------------------------------tree leaf node------------------
function simpleTreeLeafNode(parentGroupNode,obj){
    this.parentGroupNode=parentGroupNode
    this.leafInfo=obj;

    var treeOptions=this.parentGroupNode.parentTree.options
    if(treeOptions.leafNameProperty) this.name=this.leafInfo[treeOptions.leafNameProperty]
    else this.name=this.leafInfo["$dtId"]

    this.createLeafNodeDOM()
}

simpleTreeLeafNode.prototype.deleteSelf = function () {
    this.DOM.remove()
    var gNode = this.parentGroupNode
    const index = gNode.childLeafNodes.indexOf(this);
    if (index > -1) gNode.childLeafNodes.splice(index, 1);
    gNode.refreshName()
}

simpleTreeLeafNode.prototype.clickSelf=function(mouseClickDetail){
    this.parentGroupNode.parentTree.lastClickedNode=this;
    this.parentGroupNode.parentTree.selectLeafNode(this,mouseClickDetail)
}

simpleTreeLeafNode.prototype.createLeafNodeDOM=function(){
    this.DOM=$('<button class="w3-button w3-white" style="display:block;text-align:left;width:98%"></button>')
    this.redrawLabel()


    var clickF=(e)=>{
        this.highlight();
        var clickDetail=e.detail
        if (e.ctrlKey) {
            if(this.parentGroupNode.parentTree.options.noMultipleSelectAllowed){
                this.clickSelf()
                return;
            }
            this.parentGroupNode.parentTree.appendLeafNodeToSelection(this)
            this.parentGroupNode.parentTree.lastClickedNode=this;
        }else if(e.shiftKey){
            if(this.parentGroupNode.parentTree.options.noMultipleSelectAllowed){
                this.clickSelf()
                return;
            }
            if(this.parentGroupNode.parentTree.lastClickedNode==null){
                this.clickSelf()
            }else{
                var allLeafNodeArr=this.parentGroupNode.parentTree.getAllLeafNodeArr()
                var index1 = allLeafNodeArr.indexOf(this.parentGroupNode.parentTree.lastClickedNode)
                var index2 = allLeafNodeArr.indexOf(this)
                if(index1==-1 || index2==-1){
                    this.clickSelf()
                }else{
                    //select all leaf between
                    var lowerI= Math.min(index1,index2)
                    var higherI= Math.max(index1,index2)
                    
                    var middleArr=allLeafNodeArr.slice(lowerI,higherI)                  
                    middleArr.push(allLeafNodeArr[higherI])
                    this.parentGroupNode.parentTree.addNodeArrayToSelection(middleArr)
                }
            }
        }else{
            this.clickSelf(clickDetail)
        }
    }
    this.DOM.on("click",(e)=>{clickF(e)})

    this.DOM.on("dblclick",(e)=>{
        this.parentGroupNode.parentTree.dblClickNode(this)
    })
}

simpleTreeLeafNode.prototype.redrawLabel=function(){
    this.DOM.empty()

    var nameDiv=$("<label style='display:inline;padding-left:5px;padding-right:3px;vertical-align:middle'></label>")
    nameDiv.text(this.name)

    if(this.parentGroupNode.parentTree.options.leafNodeIconFunc){
        var iconLabel=this.parentGroupNode.parentTree.options.leafNodeIconFunc(this)
        this.DOM.append(iconLabel)
        var rowHeight=iconLabel.height()
        nameDiv.css("line-height",rowHeight+"px")
    }
    
    this.DOM.append(nameDiv)
}
simpleTreeLeafNode.prototype.highlight=function(){
    this.DOM.addClass("w3-orange")
    this.DOM.addClass("w3-hover-amber")
    this.DOM.removeClass("w3-white")
}
simpleTreeLeafNode.prototype.dim=function(){
    this.DOM.removeClass("w3-orange")
    this.DOM.removeClass("w3-hover-amber")
    this.DOM.addClass("w3-white")
}


module.exports = simpleTree;
},{}],35:[function(require,module,exports){
const globalCache = require("./globalCache")
const simpleSelectMenu=require("./simpleSelectMenu")
const msalHelper=require("../msalHelper")
const editProjectDialog=require("./editProjectDialog")
const modelManagerDialog = require("./modelManagerDialog")
const modelAnalyzer = require("./modelAnalyzer")

function startSelectionDialog() {
    if(!this.DOM){
        this.DOM = $('<div style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:99" class="w3-card-2"></div>')
        $("body").append(this.DOM)
        this.DOM.hide()
        globalCache.makeDOMDraggable(this.DOM)
    }
}

startSelectionDialog.prototype.popup = async function() {
    this.DOM.show()
    this.DOM.empty()

    this.contentDOM = $('<div style="width:680px"></div>')
    this.DOM.append(this.contentDOM)
    var titleDiv=$('<div style="height:40px" class="w3-bar w3-red"><div class="w3-bar-item" style="font-size:1.5em">Select Twins</div></div>')
    this.contentDOM.append(titleDiv)
    var closeButton = $('<button class="w3-bar-item w3-button w3-right" style="font-size:2em;padding-top:4px"></button>')
    titleDiv.append(closeButton)

    this.buttonHolder = $("<div style='height:100%'></div>")
    titleDiv.append(this.buttonHolder)
    closeButton.on("click", () => {
        this.useStartSelection("append")
        this.closeDialog() 
    })

    var row1=$('<div class="w3-bar" style="padding:2px"></div>')
    this.contentDOM.append(row1)
    var lable=$('<div class="w3-bar-item w3-opacity" style="padding-right:5px;">Project </div>')
    row1.append(lable)
    var switchProjectSelector=new simpleSelectMenu(" ",{withBorder:1,colorClass:"w3-light-gray",buttonCSS:{"padding":"5px 10px"}})
    this.switchProjectSelector=switchProjectSelector
    row1.append(switchProjectSelector.DOM)
    var joinedProjects=globalCache.accountInfo.joinedProjects
    joinedProjects.forEach(aProject=>{
        var str = aProject.name
        if(aProject.owner!=globalCache.accountInfo.accountID) str+=" (from "+aProject.owner+")"
        switchProjectSelector.addOption(str,aProject.id)
    })
    switchProjectSelector.callBack_clickOption=(optionText,optionValue)=>{
        switchProjectSelector.changeName(optionText)
        this.chooseProject(optionValue)
    }

    this.editProjectBtn=$('<a class="w3-bar-item w3-button" href="#"><i class="fa fa-edit fa-lg"></i></a>')
    this.deleteProjectBtn=$('<a class="w3-button" href="#"><i class="fa fa-trash fa-lg"></i></a>')
    this.newProjectBtn=$('<a class="w3-button" href="#"><i class="fa fa-plus fa-lg"></i></a>')
    row1.append(this.editProjectBtn,this.deleteProjectBtn,this.newProjectBtn)

    var panelHeight=400
    var row2=$('<div class="w3-cell-row"></div>')
    this.contentDOM.append(row2)
    var leftSpan=$('<div style="padding:5px;width:260px;padding-right:5px;overflow:hidden"></div>')
    row2.append(leftSpan)
    this.leftSpan=leftSpan

    var rightSpan=$('<div class="w3-container w3-cell" style="padding-top:10px;"></div>')
    row2.append(rightSpan) 
    rightSpan.append($('<div class="w3-container w3-card" style="color:gray;height:'+(panelHeight-10)+'px;overflow:auto;width:390px;"></div>'))
    var selectedTwinsDOM=$("<table style='width:100%'></table>")
    selectedTwinsDOM.css({"border-collapse":"collapse"})
    rightSpan.children(':first').append(selectedTwinsDOM)
    this.selectedTwinsDOM=selectedTwinsDOM 

    var row1=$("<div style='margin:8px 0px;font-weight:bold;color:gray;display:flex;align-items:center;height:24px'></div>")
    this.leftSpan.append(row1)
    row1.append($('<label style="padding-right:5px">Choose twins</label>'))

    var radioByModel=$('<input type="radio" name="SelectTwins" value="model" checked><label style="font-weight:normal;padding-right:8px">By Model</label>')
    var radioBTag=$('<input type="radio" name="SelectTwins" value="tag"><label  style="font-weight:normal">By Tag</label>')
    row1.append(radioByModel,radioBTag)
    radioBTag.on("change",(e)=>{this.chooseTwinBy="tag"; this.fillAvailableTags() })
    radioByModel.on("change",(e)=>{this.chooseTwinBy="model"; this.fillAvailableModels() })
    
    this.modelsCheckBoxes=$('<form class="w3-container w3-border" style="height:'+(panelHeight-40)+'px;overflow:auto"></form>')
    leftSpan.append(this.modelsCheckBoxes)
    
    if(this.previousSelectedProject!=null){
        switchProjectSelector.triggerOptionValue(this.previousSelectedProject)
    }else{
        switchProjectSelector.triggerOptionIndex(0)
    }

    radioByModel.trigger("change") 
}

startSelectionDialog.prototype.chooseProject = async function (selectedProjectID) {
    this.buttonHolder.empty()

    var projectInfo=globalCache.findProjectInfo(selectedProjectID)
    if(projectInfo.owner==globalCache.accountInfo.accountID){
        this.editProjectBtn.show()
        this.deleteProjectBtn.show()
        this.editProjectBtn.on("click", () => { editProjectDialog.popup(projectInfo) })
        this.deleteProjectBtn.on("click",async ()=>{
            try {
                await msalHelper.callAPI("accountManagement/deleteProjectTo", "POST", {"projectID":selectedProjectID})
            } catch (e) {
                console.log(e)
                if (e.responseText) alert(e.responseText)
                return
            }
        })
    }else{
        this.editProjectBtn.hide()
        this.deleteProjectBtn.hide()
    }
    this.newProjectBtn.on("click",async ()=>{
        var tsStr=(new Date().toLocaleString()) 
        try {
            var newProjectInfo = await msalHelper.callAPI("accountManagement/newProjectTo", "POST", { "projectName": "New Project " + tsStr })
            globalCache.accountInfo.joinedProjects.unshift(newProjectInfo)
            this.switchProjectSelector.clearOptions()
            var joinedProjects = globalCache.accountInfo.joinedProjects
            joinedProjects.forEach(aProject => {
                var str = aProject.name
                if(aProject.owner!=globalCache.accountInfo.accountID) str+=" (from "+aProject.owner+")"
                this.switchProjectSelector.addOption(str, aProject.id)
            })
            //NOTE: must query the new joined projects JWT token again
            await msalHelper.reloadUserAccountData()
            this.switchProjectSelector.triggerOptionIndex(0)
        } catch (e) {
            console.log(e)
            if (e.responseText) alert(e.responseText)
            return
        }
    })
    

    if(this.previousSelectedProject==null){
        var replaceButton = $('<button class="w3-button w3-card w3-hover-deep-orange w3-green" style="height:100%; margin-right:8px">Start</button>')
        replaceButton.on("click", () => { this.useStartSelection("replace") })
        this.buttonHolder.append(replaceButton)
    }else if(this.previousSelectedProject == selectedProjectID){
        var replaceButton = $('<button class="w3-button w3-card w3-deep-orange w3-hover-green" style="height:100%; margin-right:8px">Replace All Data</button>')
        var appendButton = $('<button class="w3-button w3-card w3-deep-orange w3-hover-green" style="height:100%">Append Data</button>')
    
        replaceButton.on("click", () => { this.useStartSelection("replace") })
        appendButton.on("click", () => { this.useStartSelection("append") })
        this.buttonHolder.append(appendButton,replaceButton)
    }else{
        var replaceButton = $('<button class="w3-button w3-card w3-deep-orange w3-hover-green" style="height:100%; margin-right:8px">Replace All Data</button>')
        replaceButton.on("click", () => { this.useStartSelection("replace") })
        this.buttonHolder.append(replaceButton)
    }
    globalCache.currentProjectID = selectedProjectID

    var projectOwner=projectInfo.owner
    try {
        var res = await msalHelper.callAPI("digitaltwin/fetchProjectModelsData", "POST", null, "withProjectID")
        globalCache.storeProjectModelsData(res.DBModels, res.adtModels)
        modelAnalyzer.clearAllModels();
        modelAnalyzer.addModels(res.adtModels)
        modelAnalyzer.analyze();
        var res = await msalHelper.callAPI("digitaltwin/fetchProjectTwinsAndVisualData", "POST", {"projectOwner":projectOwner}, "withProjectID")
        globalCache.storeProjectTwinsAndVisualData(res)
    } catch (e) {
        console.log(e)
        if (e.responseText) alert(e.responseText)
        return
    }
    if(this.chooseTwinBy=="tag") this.fillAvailableTags()
    else this.fillAvailableModels()
    this.listTwins()
}



startSelectionDialog.prototype.closeDialog=function(){
    this.DOM.hide()
    this.broadcastMessage({ "message": "startSelectionDialog_closed"})
}

startSelectionDialog.prototype.getTagsTwins = function(){
    var tagsTwins={"ALL":[],"Non Tagged":[]}
    for(var twinID in globalCache.DBTwins){
        var aDBTwin=globalCache.DBTwins[twinID]
        tagsTwins["ALL"].push(aDBTwin)
        var tag=aDBTwin.groupTag
        if(tag==null) tagsTwins["Non Tagged"].push(aDBTwin)
        else{
            if(tagsTwins[tag]==null)tagsTwins[tag]=[]
            tagsTwins[tag].push(aDBTwin)
        }
    }
    return tagsTwins
}

startSelectionDialog.prototype.fillAvailableTags = function(){
    var tagsTwins=this.getTagsTwins()
    this.modelsCheckBoxes.empty() 
    for(var tagName in tagsTwins){
        var arr=tagsTwins[tagName]
        var rowDiv=$("<div style='display:flex;align-items:center;margin-top:8px;height:24px'></div>")
        this.modelsCheckBoxes.append(rowDiv)
        rowDiv.append(`<input class="w3-check" style="top:0px;float:left" type="checkbox" id="${tagName}"/>`)
        rowDiv.append(`<label style="padding-left:5px">${tagName}</label><p/>`)
        var numberlabel=$("<label class='w3-lime' style='display:inline;font-size:9px;padding:2px;margin-left:5px;font-weight:normal;border-radius: 2px;'>"+arr.length+"</label>")
        rowDiv.append(numberlabel)
    }
    this.modelsCheckBoxes.off("change")//clear any previsou on change func
    this.modelsCheckBoxes.on("change",(evt)=>{
        this.listTwins()
    })
}

startSelectionDialog.prototype.fillAvailableModels = function() {
    this.modelsCheckBoxes.empty()
    this.modelsCheckBoxes.append('<div style="display:block"><input class="w3-check" type="checkbox" id="ALL"><label style="padding-left:5px"><b>ALL</b></label><p/></div>')
    globalCache.DBModelsArr.forEach(oneModel=>{
        var modelName=oneModel["displayName"]
        var modelID=oneModel["id"]
        var symbol=globalCache.generateModelIcon(modelID,40,"fixSize")
        var rowDiv=$("<div style='display:flex;align-items:center;margin-top:8px;height:40px'></div>")
        this.modelsCheckBoxes.append(rowDiv)
        rowDiv.append(`<div style="width:24px"><input class="w3-check" style="top:0px;float:left" type="checkbox" id="${modelID}"/></div>`)
        var innerDiv=$("<div style='display:flex;align-items:center;margin-left:6px'></div>")
        rowDiv.append(innerDiv)
        
        innerDiv.append(symbol)
        innerDiv.append(`<label style="padding-left:5px">${modelName}</label><p/>`)
    })
    this.modelsCheckBoxes.off("change") //clear any previsou on change func
    this.modelsCheckBoxes.on("change",(evt)=>{
        if($(evt.target).attr("id")=="ALL"){ 
            //select all the other input
            var val=$(evt.target).prop("checked")
            this.modelsCheckBoxes.find('input').each(function () {
                $(this).prop("checked",val)
            });
        }
        this.listTwins()
    })
}

startSelectionDialog.prototype.getSelectedTwins=function(){
    var reArr=[]
    var tagsTwins=this.getTagsTwins()
    if(this.chooseTwinBy=="tag"){
        var checkedArr=[]
        this.modelsCheckBoxes.find('input').each( function () {
            if(!$(this).prop("checked")) return;
            checkedArr=checkedArr.concat(tagsTwins[$(this).attr("id")])
        });
        var usedID={}
        checkedArr.forEach(oneTwin=>{
            if(usedID[oneTwin["id"]]) return;
            usedID[oneTwin["id"]]=1
            reArr.push(oneTwin)
        })
    }else{
        var chosenModels={}
        this.modelsCheckBoxes.find('input').each(function () {
            if(!$(this).prop("checked")) return;
            if($(this).attr("id")=="ALL") return;
            chosenModels[$(this).attr("id")]=1
        });
        for(var twinID in globalCache.DBTwins){
            var aTwin=globalCache.DBTwins[twinID]
            if(chosenModels[aTwin["modelID"]])  reArr.push(aTwin)
        }    
    }
    return reArr;
}

startSelectionDialog.prototype.listTwins=function(){
    this.selectedTwinsDOM.empty()
    var tr=$('<tr><td style="border-right:solid 1px lightgrey;border-bottom:solid 1px lightgrey;font-weight:bold">TWIN ID</td><td style="border-bottom:solid 1px lightgrey;font-weight:bold">MODEL ID</td></tr>')
    this.selectedTwinsDOM.append(tr)

    var selectedTwins=this.getSelectedTwins()
    selectedTwins.forEach(aTwin=>{
        var tr=$('<tr><td style="border-right:solid 1px lightgrey;border-bottom:solid 1px lightgrey">'+aTwin["displayName"]+'</td><td style="border-bottom:solid 1px lightgrey">'+aTwin['modelID']+'</td></tr>')
        this.selectedTwinsDOM.append(tr)
    })
    if(selectedTwins.length==0){
        var tr=$('<tr><td style="color:gray">zero record</td><td></td></tr>')
        this.selectedTwinsDOM.append(tr)    
    }
}


startSelectionDialog.prototype.useStartSelection=function(action){
    var bool_broadCastProjectChanged=false
    if(this.previousSelectedProject!=globalCache.currentProjectID){
        globalCache.initStoredInformtion()
        this.previousSelectedProject=globalCache.currentProjectID
        bool_broadCastProjectChanged=true
    }

    var selectedTwins=this.getSelectedTwins()
    var twinIDs=[]
    selectedTwins.forEach(aTwin=>{twinIDs.push(aTwin["id"])})

    var modelIDs=[]
    globalCache.DBModelsArr.forEach(oneModel=>{modelIDs.push(oneModel["id"])})

    this.broadcastMessage({ "message": "startSelection_"+action, "twinIDs": twinIDs,"modelIDs":modelIDs })
    var projectInfo=globalCache.findProjectInfo(globalCache.currentProjectID)
    if(projectInfo.defaultLayout && projectInfo.defaultLayout!="") globalCache.currentLayoutName=projectInfo.defaultLayout
    
    if(bool_broadCastProjectChanged){
        this.broadcastMessage({ "message": "projectIsChanged","projectID":globalCache.currentProjectID})
    }

    this.broadcastMessage({ "message": "layoutsUpdated","selectLayout":projectInfo.defaultLayout})
    this.closeDialog()

    if(globalCache.DBModelsArr.length==0){
        //directly popup to model management dialog allow user import or create model
        modelManagerDialog.popup()
        modelManagerDialog.DOM.hide()
        modelManagerDialog.DOM.fadeIn()
        //pop up welcome screen
        var popWin=$('<div class="w3-blue w3-card-4 w3-padding-large" style="position:absolute;top:50%;background-color:white;left:50%;transform: translateX(-50%) translateY(-50%);z-index:105;width:400px;cursor:default"></div>')
        popWin.html(`Welcome, ${msalHelper.userName}! Firstly, let's import or create a few twin models to start. <br/><br/>Click to continue...`)
        $("body").append(popWin)
        popWin.on("click",()=>{popWin.remove()})
        setTimeout(()=>{
            popWin.fadeOut("slow",()=>{popWin.remove()});
        },3000)
    }
}

module.exports = new startSelectionDialog();
},{"../msalHelper":18,"./editProjectDialog":20,"./globalCache":21,"./modelAnalyzer":22,"./modelManagerDialog":24,"./simpleSelectMenu":33}]},{},[4])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vc3BhU291cmNlQ29kZS9kaWdpdGFsdHdpbm1vZHVsZS9kaWdpdGFsdHdpbm1vZHVsZVVJLmpzIiwiLi4vc3BhU291cmNlQ29kZS9kaWdpdGFsdHdpbm1vZHVsZS9lZGl0TGF5b3V0RGlhbG9nLmpzIiwiLi4vc3BhU291cmNlQ29kZS9kaWdpdGFsdHdpbm1vZHVsZS9mbG9hdEluZm9XaW5kb3cuanMiLCIuLi9zcGFTb3VyY2VDb2RlL2RpZ2l0YWx0d2lubW9kdWxlL2luZm9QYW5lbC5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZGlnaXRhbHR3aW5tb2R1bGUvaW5mb1BhbmVsX2xpdmVNb25pdG9yLmpzIiwiLi4vc3BhU291cmNlQ29kZS9kaWdpdGFsdHdpbm1vZHVsZS9tYWluVG9vbGJhci5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZGlnaXRhbHR3aW5tb2R1bGUvbWFwRE9NLmpzIiwiLi4vc3BhU291cmNlQ29kZS9kaWdpdGFsdHdpbm1vZHVsZS90b3BvbG9neURPTS5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZGlnaXRhbHR3aW5tb2R1bGUvdG9wb2xvZ3lET01fbWVudS5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZGlnaXRhbHR3aW5tb2R1bGUvdG9wb2xvZ3lET01fc2ltRGF0YVNvdXJjZS5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZGlnaXRhbHR3aW5tb2R1bGUvdG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyLmpzIiwiLi4vc3BhU291cmNlQ29kZS9kaWdpdGFsdHdpbm1vZHVsZS90b3BvbG9neURPTV92aXN1YWwuanMiLCIuLi9zcGFTb3VyY2VDb2RlL2RpZ2l0YWx0d2lubW9kdWxlL3R3aW5zVHJlZS5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvZ2xvYmFsQXBwU2V0dGluZ3MuanMiLCIuLi9zcGFTb3VyY2VDb2RlL21zYWxIZWxwZXIuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL2Jhc2VJbmZvUGFuZWwuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL2VkaXRQcm9qZWN0RGlhbG9nLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZS5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvbW9kZWxBbmFseXplci5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvbW9kZWxFZGl0b3JEaWFsb2cuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL21vZGVsTWFuYWdlckRpYWxvZy5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvbW9kdWxlU3dpdGNoRGlhbG9nLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9uZXdUd2luRGlhbG9nLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9wcm9qZWN0U2V0dGluZ0RpYWxvZy5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvc2NyaXB0VGVzdERpYWxvZy5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvc2VydmljZVdvcmtlckhlbHBlci5qcyIsIi4uL3NwYVNvdXJjZUNvZGUvc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlQ2hhcnQuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUNvbmZpcm1EaWFsb2cuanMiLCIuLi9zcGFTb3VyY2VDb2RlL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUV4cGFuZGFibGVTZWN0aW9uLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVTZWxlY3RNZW51LmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVUcmVlLmpzIiwiLi4vc3BhU291cmNlQ29kZS9zaGFyZWRTb3VyY2VGaWxlcy9zdGFydFNlbGVjdGlvbkRpYWxvZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDemNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNseEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5jb25zdCB0b3BvbG9neURPTT1yZXF1aXJlKFwiLi90b3BvbG9neURPTS5qc1wiKVxyXG5jb25zdCBtYXBET009cmVxdWlyZShcIi4vbWFwRE9NLmpzXCIpXHJcbmNvbnN0IHR3aW5zVHJlZT1yZXF1aXJlKFwiLi90d2luc1RyZWVcIilcclxuY29uc3Qgc3RhcnRTZWxlY3Rpb25EaWFsb2cgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc3RhcnRTZWxlY3Rpb25EaWFsb2dcIilcclxuY29uc3QgbW9kZWxNYW5hZ2VyRGlhbG9nID0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL21vZGVsTWFuYWdlckRpYWxvZ1wiKVxyXG5jb25zdCBwcm9qZWN0U2V0dGluZ0RpYWxvZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9wcm9qZWN0U2V0dGluZ0RpYWxvZ1wiKVxyXG5jb25zdCBtb2RlbEVkaXRvckRpYWxvZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEVkaXRvckRpYWxvZ1wiKVxyXG5jb25zdCBlZGl0TGF5b3V0RGlhbG9nID0gcmVxdWlyZShcIi4vZWRpdExheW91dERpYWxvZ1wiKVxyXG5jb25zdCBtYWluVG9vbGJhciA9IHJlcXVpcmUoXCIuL21haW5Ub29sYmFyXCIpXHJcbmNvbnN0IGluZm9QYW5lbD0gcmVxdWlyZShcIi4vaW5mb1BhbmVsXCIpO1xyXG5jb25zdCBnbG9iYWxBcHBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9nbG9iYWxBcHBTZXR0aW5ncy5qc1wiKTtcclxuY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBuZXdUd2luRGlhbG9nPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9uZXdUd2luRGlhbG9nXCIpO1xyXG5jb25zdCBmbG9hdEluZm9XaW5kb3c9cmVxdWlyZShcIi4vZmxvYXRJbmZvV2luZG93XCIpXHJcbmNvbnN0IHNlcnZpY2VXb3JrZXJIZWxwZXI9cmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NlcnZpY2VXb3JrZXJIZWxwZXJcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuXHJcbmZ1bmN0aW9uIGRpZ2l0YWx0d2lubW9kdWxlVUkoKSB7XHJcbiAgICBnbG9iYWxDYWNoZS5jaGVja1Rvb0xvbmdJZGxlKClcclxuICAgIHRoaXMuaW5pdFVJTGF5b3V0KClcclxuXHJcbiAgICB0aGlzLnR3aW5zVHJlZT0gbmV3IHR3aW5zVHJlZSgkKFwiI3RyZWVIb2xkZXJcIiksJChcIiN0cmVlU2VhcmNoXCIpKVxyXG4gICAgXHJcbiAgICBtYWluVG9vbGJhci5yZW5kZXIoKVxyXG4gICAgdGhpcy50b3BvbG9neUluc3RhbmNlPW5ldyB0b3BvbG9neURPTSgkKCcjY2FudmFzJykpXHJcbiAgICB0aGlzLnRvcG9sb2d5SW5zdGFuY2UuaW5pdCgpXHJcblxyXG4gICAgdGhpcy5tYXBET00gPSBuZXcgbWFwRE9NKCQoJyNjYW52YXMnKSlcclxuXHJcbiAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoKSAvL2luaXRpYWxpemUgYWxsIHVpIGNvbXBvbmVudHMgdG8gaGF2ZSB0aGUgYnJvYWRjYXN0IGNhcGFiaWxpdHlcclxuXHJcbiAgICAvL3RyeSBpZiBpdCBhbHJlYWR5IEIyQyBzaWduZWQgaW4sIGlmIG5vdCBnb2luZyBiYWNrIHRvIHRoZSBzdGFydCBwYWdlXHJcbiAgICB0aGlzLm15TVNBTE9iaiA9IG5ldyBtc2FsLlB1YmxpY0NsaWVudEFwcGxpY2F0aW9uKGdsb2JhbEFwcFNldHRpbmdzLm1zYWxDb25maWcpO1xyXG5cclxuXHJcbiAgICB2YXIgdGhlQWNjb3VudD1tc2FsSGVscGVyLmZldGNoQWNjb3VudCgpO1xyXG4gICAgaWYodGhlQWNjb3VudD09bnVsbCAmJiAhZ2xvYmFsQXBwU2V0dGluZ3MuaXNMb2NhbFRlc3QpIHdpbmRvdy5vcGVuKGdsb2JhbEFwcFNldHRpbmdzLmxvZ291dFJlZGlyZWN0VXJpLFwiX3NlbGZcIilcclxuXHJcbiAgICB0aGlzLmluaXREYXRhKClcclxuICAgIC8vc2V0VGltZW91dCgoKT0+e3RoaXMuc3RhbGxQYWdlKCl9LDEwMDApXHJcbn1cclxuXHJcblxyXG5cclxuZGlnaXRhbHR3aW5tb2R1bGVVSS5wcm90b3R5cGUuaW5pdERhdGE9YXN5bmMgZnVuY3Rpb24oKXtcclxuICAgIHRyeXtcclxuICAgICAgICBhd2FpdCBtc2FsSGVscGVyLnJlbG9hZFVzZXJBY2NvdW50RGF0YSgpXHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRTZWxlY3Rpb25EaWFsb2cucG9wdXAoKVxyXG59XHJcblxyXG5kaWdpdGFsdHdpbm1vZHVsZVVJLnByb3RvdHlwZS5icm9hZGNhc3RNZXNzYWdlPWZ1bmN0aW9uKHNvdXJjZSxtc2dQYXlsb2FkKXtcclxuICAgIHZhciBjb21wb25lbnRzQXJyPVt0aGlzLnR3aW5zVHJlZSxzdGFydFNlbGVjdGlvbkRpYWxvZyxtb2RlbE1hbmFnZXJEaWFsb2csbW9kZWxFZGl0b3JEaWFsb2csZWRpdExheW91dERpYWxvZyxcclxuICAgICAgICAgbWFpblRvb2xiYXIsdGhpcy50b3BvbG9neUluc3RhbmNlLHRoaXMubWFwRE9NLGluZm9QYW5lbCxuZXdUd2luRGlhbG9nLGZsb2F0SW5mb1dpbmRvdyxwcm9qZWN0U2V0dGluZ0RpYWxvZyxzZXJ2aWNlV29ya2VySGVscGVyLGdsb2JhbENhY2hlXVxyXG5cclxuICAgIGlmKHNvdXJjZT09bnVsbCl7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7aTxjb21wb25lbnRzQXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB2YXIgdGhlQ29tcG9uZW50PWNvbXBvbmVudHNBcnJbaV1cclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25Ccm9hZGNhc3RNZXNzYWdlKHRoZUNvbXBvbmVudClcclxuICAgICAgICB9XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBmb3IodmFyIGk9MDtpPGNvbXBvbmVudHNBcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIHZhciB0aGVDb21wb25lbnQ9Y29tcG9uZW50c0FycltpXVxyXG4gICAgICAgICAgICBpZih0aGVDb21wb25lbnQucnhNZXNzYWdlICYmIHRoZUNvbXBvbmVudCE9c291cmNlKSB0aGVDb21wb25lbnQucnhNZXNzYWdlKG1zZ1BheWxvYWQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5kaWdpdGFsdHdpbm1vZHVsZVVJLnByb3RvdHlwZS5hc3NpZ25Ccm9hZGNhc3RNZXNzYWdlPWZ1bmN0aW9uKHVpQ29tcG9uZW50KXtcclxuICAgIHVpQ29tcG9uZW50LmJyb2FkY2FzdE1lc3NhZ2U9KG1zZ09iaik9Pnt0aGlzLmJyb2FkY2FzdE1lc3NhZ2UodWlDb21wb25lbnQsbXNnT2JqKX1cclxufVxyXG5cclxuZGlnaXRhbHR3aW5tb2R1bGVVSS5wcm90b3R5cGUuaW5pdFVJTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJCgnYm9keScpLmxheW91dCh7XHJcbiAgICAgICAgLy9cdHJlZmVyZW5jZSBvbmx5IC0gdGhlc2Ugb3B0aW9ucyBhcmUgTk9UIHJlcXVpcmVkIGJlY2F1c2UgJ3RydWUnIGlzIHRoZSBkZWZhdWx0XHJcbiAgICAgICAgY2xvc2FibGU6IHRydWVcdC8vIHBhbmUgY2FuIG9wZW4gJiBjbG9zZVxyXG4gICAgICAgICwgcmVzaXphYmxlOiB0cnVlXHQvLyB3aGVuIG9wZW4sIHBhbmUgY2FuIGJlIHJlc2l6ZWQgXHJcbiAgICAgICAgLCBzbGlkYWJsZTogdHJ1ZVx0Ly8gd2hlbiBjbG9zZWQsIHBhbmUgY2FuICdzbGlkZScgb3BlbiBvdmVyIG90aGVyIHBhbmVzIC0gY2xvc2VzIG9uIG1vdXNlLW91dFxyXG4gICAgICAgICwgbGl2ZVBhbmVSZXNpemluZzogdHJ1ZVxyXG5cclxuICAgICAgICAvL1x0c29tZSByZXNpemluZy90b2dnbGluZyBzZXR0aW5nc1xyXG4gICAgICAgICwgbm9ydGhfX3NsaWRhYmxlOiBmYWxzZVx0Ly8gT1ZFUlJJREUgdGhlIHBhbmUtZGVmYXVsdCBvZiAnc2xpZGFibGU9dHJ1ZSdcclxuICAgICAgICAvLywgbm9ydGhfX3RvZ2dsZXJMZW5ndGhfY2xvc2VkOiAnMTAwJSdcdC8vIHRvZ2dsZS1idXR0b24gaXMgZnVsbC13aWR0aCBvZiByZXNpemVyLWJhclxyXG4gICAgICAgICwgbm9ydGhfX3NwYWNpbmdfY2xvc2VkOiA2XHRcdC8vIGJpZyByZXNpemVyLWJhciB3aGVuIG9wZW4gKHplcm8gaGVpZ2h0KVxyXG4gICAgICAgICwgbm9ydGhfX3NwYWNpbmdfb3BlbjowXHJcbiAgICAgICAgLCBub3J0aF9fcmVzaXphYmxlOiBmYWxzZVx0Ly8gT1ZFUlJJREUgdGhlIHBhbmUtZGVmYXVsdCBvZiAncmVzaXphYmxlPXRydWUnXHJcbiAgICAgICAgLCBub3J0aF9fY2xvc2FibGU6IGZhbHNlXHJcbiAgICAgICAgLCB3ZXN0X19jbG9zYWJsZTogZmFsc2VcclxuICAgICAgICAsIGVhc3RfX2Nsb3NhYmxlOiBmYWxzZVxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvL1x0c29tZSBwYW5lLXNpemUgc2V0dGluZ3NcclxuICAgICAgICAsIHdlc3RfX21pblNpemU6IDEwMFxyXG4gICAgICAgICwgZWFzdF9fc2l6ZTogMzAwXHJcbiAgICAgICAgLCBlYXN0X19taW5TaXplOiAyMDBcclxuICAgICAgICAsIGVhc3RfX21heFNpemU6IDAuNSAvLyA1MCUgb2YgbGF5b3V0IHdpZHRoXHJcbiAgICAgICAgLCBjZW50ZXJfX21pbldpZHRoOiAxMDBcclxuICAgICAgICAsZWFzdF9faW5pdENsb3NlZDpcdHRydWVcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICpcdERJU0FCTEUgVEVYVC1TRUxFQ1RJT04gV0hFTiBEUkFHR0lORyAob3IgZXZlbiBfdHJ5aW5nXyB0byBkcmFnISlcclxuICAgICAqXHR0aGlzIGZ1bmN0aW9uYWxpdHkgd2lsbCBiZSBpbmNsdWRlZCBpbiBSQzMwLjgwXHJcbiAgICAgKi9cclxuICAgICQubGF5b3V0LmRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciAkZCA9ICQoZG9jdW1lbnQpXHJcbiAgICAgICAgICAgICwgcyA9ICd0ZXh0U2VsZWN0aW9uRGlzYWJsZWQnXHJcbiAgICAgICAgICAgICwgeCA9ICd0ZXh0U2VsZWN0aW9uSW5pdGlhbGl6ZWQnXHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICBpZiAoJC5mbi5kaXNhYmxlU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICghJGQuZGF0YSh4KSkgLy8gZG9jdW1lbnQgaGFzbid0IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XHJcbiAgICAgICAgICAgICAgICAkZC5vbignbW91c2V1cCcsICQubGF5b3V0LmVuYWJsZVRleHRTZWxlY3Rpb24pLmRhdGEoeCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICghJGQuZGF0YShzKSlcclxuICAgICAgICAgICAgICAgICRkLmRpc2FibGVTZWxlY3Rpb24oKS5kYXRhKHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCckLmxheW91dC5kaXNhYmxlVGV4dFNlbGVjdGlvbicpO1xyXG4gICAgfTtcclxuICAgICQubGF5b3V0LmVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyICRkID0gJChkb2N1bWVudClcclxuICAgICAgICAgICAgLCBzID0gJ3RleHRTZWxlY3Rpb25EaXNhYmxlZCc7XHJcbiAgICAgICAgaWYgKCQuZm4uZW5hYmxlU2VsZWN0aW9uICYmICRkLmRhdGEocykpXHJcbiAgICAgICAgICAgICRkLmVuYWJsZVNlbGVjdGlvbigpLmRhdGEocywgZmFsc2UpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJyQubGF5b3V0LmVuYWJsZVRleHRTZWxlY3Rpb24nKTtcclxuICAgIH07XHJcbiAgICAkKFwiLnVpLWxheW91dC1yZXNpemVyLW5vcnRoXCIpLmhpZGUoKVxyXG4gICAgJChcIi51aS1sYXlvdXQtd2VzdFwiKS5jc3MoXCJib3JkZXItcmlnaHRcIixcInNvbGlkIDFweCBsaWdodEdyYXlcIilcclxuICAgICQoXCIudWktbGF5b3V0LXdlc3RcIikuYWRkQ2xhc3MoXCJ3My1jYXJkXCIpXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBkaWdpdGFsdHdpbm1vZHVsZVVJKCk7IiwiY29uc3Qgc2ltcGxlU2VsZWN0TWVudT0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZVNlbGVjdE1lbnVcIilcclxuY29uc3Qgc2ltcGxlQ29uZmlybURpYWxvZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVDb25maXJtRGlhbG9nXCIpXHJcbmNvbnN0IGdsb2JhbENhY2hlPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcblxyXG5mdW5jdGlvbiBlZGl0TGF5b3V0RGlhbG9nKCkge1xyXG4gICAgaWYoIXRoaXMuRE9NKXtcclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2JhY2tncm91bmQtY29sb3I6d2hpdGU7bGVmdDo1MCU7dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDoxMDFcIiBjbGFzcz1cInczLWNhcmQtMlwiPjwvZGl2PicpXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLm1ha2VET01EcmFnZ2FibGUodGhpcy5ET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbmVkaXRMYXlvdXREaWFsb2cucHJvdG90eXBlLnJlZmlsbE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnN3aXRjaExheW91dFNlbGVjdG9yLmNsZWFyT3B0aW9ucygpXHJcbiAgICBcclxuICAgIGZvcih2YXIgaW5kIGluIGdsb2JhbENhY2hlLmxheW91dEpTT04pe1xyXG4gICAgICAgIHZhciBvbmVMYXlvdXRPYmo9Z2xvYmFsQ2FjaGUubGF5b3V0SlNPTltpbmRdXHJcbiAgICAgICAgaWYob25lTGF5b3V0T2JqLm93bmVyPT1nbG9iYWxDYWNoZS5hY2NvdW50SW5mby5pZCkgIHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IuYWRkT3B0aW9uKGluZClcclxuICAgIH1cclxufVxyXG5cclxuZWRpdExheW91dERpYWxvZy5wcm90b3R5cGUucG9wdXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLkRPTS5zaG93KClcclxuICAgIHRoaXMuRE9NLmVtcHR5KClcclxuXHJcbiAgICB0aGlzLkRPTS5jc3Moe1wid2lkdGhcIjpcIjMyMHB4XCIsXCJwYWRkaW5nLWJvdHRvbVwiOlwiM3B4XCJ9KVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweDttYXJnaW4tYm90dG9tOjJweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuMmVtXCI+TGF5b3V0PC9kaXY+PC9kaXY+JykpXHJcbiAgICB2YXIgY2xvc2VCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJpZ2h0XCIgc3R5bGU9XCJmb250LXNpemU6MmVtO3BhZGRpbmctdG9wOjRweFwiPsOXPC9idXR0b24+JylcclxuICAgIHRoaXMuRE9NLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQoY2xvc2VCdXR0b24pXHJcbiAgICBjbG9zZUJ1dHRvbi5vbihcImNsaWNrXCIsICgpID0+IHsgdGhpcy5ET00uaGlkZSgpIH0pXHJcblxyXG4gICAgdmFyIG5hbWVJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTsgd2lkdGg6MTgwcHg7IGRpc3BsYXk6aW5saW5lO21hcmdpbi1sZWZ0OjJweDttYXJnaW4tcmlnaHQ6MnB4XCIgIHBsYWNlaG9sZGVyPVwiRmlsbCBpbiBhIG5ldyBsYXlvdXQgbmFtZS4uLlwiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTsgICBcclxuICAgIHRoaXMuRE9NLmFwcGVuZChuYW1lSW5wdXQpXHJcbiAgICB2YXIgc2F2ZUFzTmV3QnRuPSQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtZ3JlZW4gdzMtaG92ZXItbGlnaHQtZ3JlZW5cIj5TYXZlIE5ldyBMYXlvdXQ8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKHNhdmVBc05ld0J0bilcclxuICAgIHNhdmVBc05ld0J0bi5vbihcImNsaWNrXCIsKCk9Pnt0aGlzLnNhdmVJbnRvTGF5b3V0KG5hbWVJbnB1dC52YWwoKSl9KVxyXG5cclxuXHJcbiAgICBpZighJC5pc0VtcHR5T2JqZWN0KGdsb2JhbENhY2hlLmxheW91dEpTT04pKXtcclxuICAgICAgICB2YXIgbGJsPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXIgdzMtcGFkZGluZy0xNlwiIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXI7XCI+LSBPUiAtPC9kaXY+JylcclxuICAgICAgICB0aGlzLkRPTS5hcHBlbmQobGJsKSBcclxuICAgICAgICB2YXIgc3dpdGNoTGF5b3V0U2VsZWN0b3I9bmV3IHNpbXBsZVNlbGVjdE1lbnUoXCJcIix7Zm9udFNpemU6XCIxZW1cIixjb2xvckNsYXNzOlwidzMtbGlnaHQtZ3JheVwiLHdpZHRoOlwiMTIwcHhcIn0pXHJcbiAgICAgICAgdGhpcy5zd2l0Y2hMYXlvdXRTZWxlY3Rvcj1zd2l0Y2hMYXlvdXRTZWxlY3RvclxyXG4gICAgICAgIHRoaXMucmVmaWxsT3B0aW9ucygpXHJcbiAgICAgICAgdGhpcy5zd2l0Y2hMYXlvdXRTZWxlY3Rvci5jYWxsQmFja19jbGlja09wdGlvbj0ob3B0aW9uVGV4dCxvcHRpb25WYWx1ZSk9PntcclxuICAgICAgICAgICAgaWYob3B0aW9uVGV4dD09bnVsbCkgdGhpcy5zd2l0Y2hMYXlvdXRTZWxlY3Rvci5jaGFuZ2VOYW1lKFwiIFwiKVxyXG4gICAgICAgICAgICBlbHNlIHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IuY2hhbmdlTmFtZShvcHRpb25UZXh0KVxyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIHNhdmVBc0J0bj0kKCc8YnV0dG9uIGNsYXNzPVwidzMtYnV0dG9uIHczLWdyZWVuIHczLWhvdmVyLWxpZ2h0LWdyZWVuXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDoycHg7bWFyZ2luLXJpZ2h0OjVweFwiPlNhdmUgQXM8L2J1dHRvbj4nKVxyXG4gICAgICAgIHZhciBkZWxldGVCdG49JCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtcmVkIHczLWhvdmVyLXBpbmtcIiBzdHlsZT1cIm1hcmdpbi1sZWZ0OjVweFwiPkRlbGV0ZSBMYXlvdXQ8L2J1dHRvbj4nKVxyXG4gICAgICAgIHRoaXMuRE9NLmFwcGVuZChzYXZlQXNCdG4sc3dpdGNoTGF5b3V0U2VsZWN0b3IuRE9NLGRlbGV0ZUJ0bilcclxuICAgICAgICBzYXZlQXNCdG4ub24oXCJjbGlja1wiLCgpPT57dGhpcy5zYXZlSW50b0xheW91dChzd2l0Y2hMYXlvdXRTZWxlY3Rvci5jdXJTZWxlY3RWYWwpfSlcclxuICAgICAgICBkZWxldGVCdG4ub24oXCJjbGlja1wiLCgpPT57dGhpcy5kZWxldGVMYXlvdXQoc3dpdGNoTGF5b3V0U2VsZWN0b3IuY3VyU2VsZWN0VmFsKX0pXHJcblxyXG4gICAgICAgIGlmKGdsb2JhbENhY2hlLmN1cnJlbnRMYXlvdXROYW1lIT1udWxsKXtcclxuICAgICAgICAgICAgc3dpdGNoTGF5b3V0U2VsZWN0b3IudHJpZ2dlck9wdGlvblZhbHVlKGdsb2JhbENhY2hlLmN1cnJlbnRMYXlvdXROYW1lKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBzd2l0Y2hMYXlvdXRTZWxlY3Rvci50cmlnZ2VyT3B0aW9uSW5kZXgoMClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmVkaXRMYXlvdXREaWFsb2cucHJvdG90eXBlLnNhdmVJbnRvTGF5b3V0ID0gZnVuY3Rpb24gKGxheW91dE5hbWUpIHtcclxuICAgIGlmKGxheW91dE5hbWU9PVwiXCIgfHwgbGF5b3V0TmFtZT09bnVsbCl7XHJcbiAgICAgICAgYWxlcnQoXCJQbGVhc2UgY2hvb3NlIHRhcmdldCBsYXlvdXQgTmFtZVwiKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwic2F2ZUxheW91dFwiLCBcImxheW91dE5hbWVcIjogbGF5b3V0TmFtZX0pXHJcbiAgICB0aGlzLkRPTS5oaWRlKClcclxufVxyXG5cclxuXHJcbmVkaXRMYXlvdXREaWFsb2cucHJvdG90eXBlLmRlbGV0ZUxheW91dCA9IGZ1bmN0aW9uIChsYXlvdXROYW1lKSB7XHJcbiAgICBpZihsYXlvdXROYW1lPT1cIlwiIHx8IGxheW91dE5hbWU9PW51bGwpe1xyXG4gICAgICAgIGFsZXJ0KFwiUGxlYXNlIGNob29zZSB0YXJnZXQgbGF5b3V0IE5hbWVcIilcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbmZpcm1EaWFsb2dEaXY9bmV3IHNpbXBsZUNvbmZpcm1EaWFsb2coKVxyXG5cclxuICAgIGNvbmZpcm1EaWFsb2dEaXYuc2hvdyhcclxuICAgICAgICB7IHdpZHRoOiBcIjI1MHB4XCIgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRpdGxlOiBcIkNvbmZpcm1cIlxyXG4gICAgICAgICAgICAsIGNvbnRlbnQ6IFwiQ29uZmlybSBkZWxldGluZyBsYXlvdXQgXFxcIlwiICsgbGF5b3V0TmFtZSArIFwiXFxcIj9cIlxyXG4gICAgICAgICAgICAsIGJ1dHRvbnM6W1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQ2xhc3M6IFwidzMtcmVkIHczLWhvdmVyLXBpbmtcIiwgdGV4dDogXCJDb25maXJtXCIsIFwiY2xpY2tGdW5jXCI6IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbENhY2hlLmxheW91dEpTT05bbGF5b3V0TmFtZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dE5hbWUgPT0gZ2xvYmFsQ2FjaGUuY3VycmVudExheW91dE5hbWUpIGdsb2JhbENhY2hlLmN1cnJlbnRMYXlvdXROYW1lID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwibGF5b3V0c1VwZGF0ZWRcIn0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmaWxsT3B0aW9ucygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IudHJpZ2dlck9wdGlvbkluZGV4KDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2RlbGV0ZUxheW91dFwiLCBcIlBPU1RcIiwgeyBcImxheW91dE5hbWVcIjogbGF5b3V0TmFtZSB9LFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLWdyYXlcIix0ZXh0OiBcIkNhbmNlbFwiLCBcImNsaWNrRnVuY1wiOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1EaWFsb2dEaXYuY2xvc2UoKVxyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgIClcclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IGVkaXRMYXlvdXREaWFsb2coKTsiLCJjb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBiYXNlSW5mb1BhbmVsID0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL2Jhc2VJbmZvUGFuZWxcIilcclxuXHJcblxyXG5jbGFzcyBmbG9hdEluZm9XaW5kb3cgZXh0ZW5kcyBiYXNlSW5mb1BhbmVse1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKVxyXG4gICAgICAgIGlmKCF0aGlzLkRPTSl7XHJcbiAgICAgICAgICAgIHRoaXMuRE9NPSQoJzxkaXYgY2xhc3M9XCJ3My1jYXJkXCIgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjEwMTtcIj48L2Rpdj4nKVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVTZWxmKClcclxuICAgICAgICAgICAgdGhpcy5ET00uY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpXCIpXHJcbiAgICAgICAgICAgICQoJ2JvZHknKS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVhZE9ubHk9dHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIGhpZGVTZWxmKCl7XHJcbiAgICAgICAgdGhpcy5ET00uaGlkZSgpXHJcbiAgICAgICAgdGhpcy5ET00uY3NzKFwid2lkdGhcIixcIjBweFwiKVxyXG4gICAgICAgIGlmKHRoaXMuYVRpbWVyU2luY2VTaG93aW5nKSBjbGVhclRpbWVvdXQodGhpcy5hVGltZXJTaW5jZVNob3dpbmcpXHJcbiAgICAgICAgdGhpcy5hVGltZXJTaW5jZVNob3dpbmc9bnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTaG93aW5nVHdpbklEPW51bGw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJ4TWVzc2FnZShtc2dQYXlsb2FkKSB7XHJcbiAgICAgICAgaWYgKG1zZ1BheWxvYWQubWVzc2FnZSA9PSBcImhpZGVGbG9hdEluZm9QYW5lbFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZVNlbGYoKVxyXG4gICAgICAgIH1lbHNlIGlmIChtc2dQYXlsb2FkLm1lc3NhZ2UgPT0gXCJzaG93SW5mb0hvdmVyZWRFbGVcIikge1xyXG4gICAgICAgICAgICBpZiAoIWdsb2JhbENhY2hlLnNob3dGbG9hdEluZm9QYW5lbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLkRPTS5lbXB0eSgpXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBtc2dQYXlsb2FkLmluZm87XHJcbiAgICAgICAgICAgIGlmIChhcnIgPT0gbnVsbCB8fCBhcnIubGVuZ3RoID09IDApIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5ET00uY3NzKFwibGVmdFwiLCBcIi0yMDAwcHhcIikgLy9pdCBpcyBhbHdheXMgb3V0c2lkZSBvZiBicm93c2VyIHNvIGl0IHdvbnQgYmxvY2sgbW91c2UgYW5kIGNhdXNlIG1vdXNlIG91dFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNpbmdsZUVsZW1lbnRJbmZvID0gYXJyWzBdO1xyXG4gICAgICAgICAgICBpZihzaW5nbGVFbGVtZW50SW5mbz09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBzaW5nbGVFbGVtZW50SW5mbz10aGlzLmZldGNoUmVhbEVsZW1lbnRJbmZvKHNpbmdsZUVsZW1lbnRJbmZvKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5ET00uY3NzKFwid2lkdGhcIixcIjMyNXB4XCIpXHJcbiAgICAgICAgICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgICAgICAgICB2YXIgY29udGVudERPTT0kKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyXCIvPicpXHJcbiAgICAgICAgICAgIHRoaXMuRE9NLmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGRvY3VtZW50Qm9keVdpZHRoID0gJCgnYm9keScpLndpZHRoKClcclxuICAgICAgICAgICAgaWYgKHNpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHsvLyBzZWxlY3QgYSBub2RlXHJcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlREJUd2luSW5mbz1nbG9iYWxDYWNoZS5EQlR3aW5zW3NpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl1dXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaW5nbGVOb2RlUHJvcGVydGllcyhzaW5nbGVEQlR3aW5JbmZvLHNpbmdsZUVsZW1lbnRJbmZvLGNvbnRlbnRET00sXCJub3RFbWJlZE1ldGFkYXRhXCIpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlRWxlbWVudEluZm9bXCIkc291cmNlSWRcIl0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NpbmdsZVJlbGF0aW9uUHJvcGVydGllcyhzaW5nbGVFbGVtZW50SW5mbyxjb250ZW50RE9NKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYoc2luZ2xlRWxlbWVudEluZm9bXCJzaW1Ob2RlTmFtZVwiXSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mbyhzaW5nbGVFbGVtZW50SW5mbyxjb250ZW50RE9NKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2NyZWVuWFkgPSBtc2dQYXlsb2FkLnNjcmVlblhZXHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dMZWZ0ID0gc2NyZWVuWFkueCArIDUwXHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93TGVmdCArIHRoaXMuRE9NLm91dGVyV2lkdGgoKSArIDEwID4gZG9jdW1lbnRCb2R5V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvd0xlZnQgPSBkb2N1bWVudEJvZHlXaWR0aCAtIHRoaXMuRE9NLm91dGVyV2lkdGgoKSAtIDEwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHdpbmRvd1RvcCA9IHNjcmVlblhZLnkgLSB0aGlzLkRPTS5vdXRlckhlaWdodCgpIC0gNTBcclxuICAgICAgICAgICAgaWYgKHdpbmRvd1RvcCA8IDUpIHdpbmRvd1RvcCA9IDVcclxuICAgICAgICAgICAgdGhpcy5ET00uY3NzKHsgXCJsZWZ0XCI6IHdpbmRvd0xlZnQgKyBcInB4XCIsIFwidG9wXCI6IHdpbmRvd1RvcCArIFwicHhcIiB9KVxyXG4gICAgICAgICAgICB0aGlzLkRPTS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiLFwiNXB4XCIpIFxyXG5cclxuICAgICAgICAgICAgaWYgKHNpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHRoaXMuY3VycmVudFNob3dpbmdUd2luSUQ9c2luZ2xlRWxlbWVudEluZm9bXCIkZHRJZFwiXTtcclxuICAgICAgICAgICAgaWYodGhpcy5jdXJyZW50U2hvd2luZ1R3aW5JRD09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgZGJ0d2luPSBnbG9iYWxDYWNoZS5EQlR3aW5zW3RoaXMuY3VycmVudFNob3dpbmdUd2luSURdXHJcbiAgICAgICAgICAgIGlmKCFkYnR3aW4gfHwgIWRidHdpbi5vcmlnaW5hbFNjcmlwdCB8fCBkYnR3aW4ub3JpZ2luYWxTY3JpcHQ9PVwiXCIpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5ET00uY3NzKFwicGFkZGluZy1ib3R0b21cIixcIjBweFwiKSBcclxuICAgICAgICAgICAgLy92YXIgZGl2PSQoJzxkaXY+JytkYnR3aW4ub3JpZ2luYWxTY3JpcHQrJzwvZGl2PicpXHJcbiAgICAgICAgICAgIC8vdGhpcy5ET00uYXBwZW5kKGRpdilcclxuICAgICAgICAgICAgdmFyIGhvbGRlckRpdj0kKCc8ZGl2IHN0eWxlPVwicGFkZGluZzoxcHhcIi8+JylcclxuICAgICAgICAgICAgdmFyIHNjcmlwdFRleHRBcmVhPSQoJzx0ZXh0YXJlYSBjbGFzcz1cInczLWJvcmRlclwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiIHN0eWxlPVwib3V0bGluZTpub25lO2ZvbnQtc2l6ZToxMXB4O3dpZHRoOjEwMCU7Zm9udC1mYW1pbHk6VmVyZGFuYVwiPicrZGJ0d2luW1wib3JpZ2luYWxTY3JpcHRcIl0rJzwvdGV4dGFyZWE+JylcclxuICAgICAgICAgICAgdGhpcy5ET00uYXBwZW5kKGhvbGRlckRpdi5hcHBlbmQoc2NyaXB0VGV4dEFyZWEpKVxyXG4gICAgICAgICAgICBzY3JpcHRUZXh0QXJlYS5jc3MoXCJoZWlnaHRcIixcIjFweFwiKSAvL3RvIGV4cGFuZCBzY3JpcHRUZXh0QXJlYSB0byB0aGUgaGVpZ2h0IHRoYXQgc2hvd3MgYWxsIGNvZGVcclxuICAgICAgICAgICAgdmFyIHRoZUhlaWdodD1zY3JpcHRUZXh0QXJlYVswXS5zY3JvbGxIZWlnaHQrMlxyXG4gICAgICAgICAgICBzY3JpcHRUZXh0QXJlYS5jc3MoXCJoZWlnaHRcIix0aGVIZWlnaHQrXCJweFwiKVxyXG4gICAgICAgICAgICBzY3JpcHRUZXh0QXJlYS5oaWdobGlnaHRXaXRoaW5UZXh0YXJlYShcclxuICAgICAgICAgICAgICAgIHsgaGlnaGxpZ2h0OiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyBcImhpZ2hsaWdodFwiOiBcIl9zZWxmXCIsIFwiY2xhc3NOYW1lXCI6IFwiR3JheVwifSxcclxuICAgICAgICAgICAgICAgICAgICB7IFwiaGlnaGxpZ2h0XCI6IFwiX3R3aW5WYWxcIiwgXCJjbGFzc05hbWVcIjogXCJrZXl3b3JkXCJ9LFxyXG4gICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaG9sZGVyRGl2LmNzcyhcImhlaWdodFwiLHRoZUhlaWdodCtcInB4XCIpXHJcbiAgICAgICAgICAgIGhvbGRlckRpdi5oaWRlKClcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXY9JCgnPGRpdiBjbGFzcz1cInczLWFtYmVyXCIgc3R5bGU9XCJmb250LXNpemU6NnB4O3RleHQtYWxpZ246Y2VudGVyXCI+PGkgY2xhc3M9XCJmYXMgZmEtZWxsaXBzaXMtaFwiPjwvaT48L2Rpdj4nKVxyXG4gICAgICAgICAgICB0aGlzLkRPTS5hcHBlbmQoZGl2KVxyXG4gICAgICAgICAgICBkaXYuZmFkZVRvKDQwMCwwLjMsXCJzd2luZ1wiLCgpPT57XHJcbiAgICAgICAgICAgICAgICBkaXYuZmFkZVRvKDQwMCwxLFwic3dpbmdcIiwoKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5mYWRlVG8oNDAwLDAuMyxcInN3aW5nXCIsKCk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmZhZGVUbyg0MDAsMSxcInN3aW5nXCIsKCk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlckRpdi5zbGlkZURvd24oXCJmYXN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pICAgIFxyXG4gICAgICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgZmxvYXRJbmZvV2luZG93KCk7IiwiY29uc3QgbW9kZWxBbmFseXplciA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEFuYWx5emVyXCIpO1xyXG5jb25zdCBzaW1wbGVDb25maXJtRGlhbG9nID0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUNvbmZpcm1EaWFsb2dcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuY29uc3QgbXNhbEhlbHBlciA9IHJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbmNvbnN0IGJhc2VJbmZvUGFuZWwgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvYmFzZUluZm9QYW5lbFwiKVxyXG5jb25zdCBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbj0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZUV4cGFuZGFibGVTZWN0aW9uXCIpXHJcbmNvbnN0IHNpbXBsZVNlbGVjdE1lbnU9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVTZWxlY3RNZW51XCIpXHJcbmNvbnN0IHNjcmlwdFRlc3REaWFsb2cgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2NyaXB0VGVzdERpYWxvZ1wiKVxyXG5jb25zdCBpbmZvUGFuZWxfbGl2ZU1vbml0b3I9cmVxdWlyZShcIi4vaW5mb1BhbmVsX2xpdmVNb25pdG9yXCIpXHJcblxyXG5jbGFzcyBpbmZvUGFuZWwgZXh0ZW5kcyBiYXNlSW5mb1BhbmVsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKClcclxuICAgICAgICB0aGlzLm9wZW5MaXZlQ2FsY3VsYXRpb25TZWN0aW9uPXRydWVcclxuICAgICAgICB0aGlzLm9wZW5Qcm9wZXJ0aWVzU2VjdGlvbj10cnVlXHJcbiAgICAgICAgdGhpcy5jb250YWluZXJET00gPSAkKCc8ZGl2IGNsYXNzPVwidzMtY2FyZFwiIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5MDtyaWdodDowcHg7dG9wOjUwJTtoZWlnaHQ6NzAlO3dpZHRoOjM1MHB4O3RyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcIj48L2Rpdj4nKVxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyRE9NLmhpZGUoKVxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyRE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjUwcHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48L2Rpdj4nKSlcclxuXHJcbiAgICAgICAgdGhpcy5jbG9zZUJ1dHRvbjEgPSAkKCc8YnV0dG9uIHN0eWxlPVwiaGVpZ2h0OjEwMCVcIiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvblwiPjxpIGNsYXNzPVwiZmEgZmEtaW5mby1jaXJjbGUgZmEtMnhcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICAgICAgdGhpcy5saXZlUGFuZUJ1dHRvbiA9ICQoJzxidXR0b24gc3R5bGU9XCJoZWlnaHQ6MTAwJTttYXJnaW4tcmlnaHQ6MTBweFwiIGNsYXNzPVwidzMtcmlnaHQgdzMtYW1iZXIgdzMtYmFyLWl0ZW0gdzMtYnV0dG9uXCI+U2hvdyBMaXZlIFBhbmU8L2J1dHRvbj4nKVxyXG4gICAgICAgIHRoaXMuY2xvc2VCdXR0b24yID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbVwiPsOXPC9idXR0b24+JylcclxuICAgICAgICB0aGlzLmNvbnRhaW5lckRPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKHRoaXMuY2xvc2VCdXR0b24xLCB0aGlzLmNsb3NlQnV0dG9uMix0aGlzLmxpdmVQYW5lQnV0dG9uKVxyXG5cclxuICAgICAgICB0aGlzLmlzTWluaW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGJ1dHRvbkFuaW0gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc01pbmltaXplZCkgdGhpcy5taW5pbWl6ZVdpbmRvdygpXHJcbiAgICAgICAgICAgIGVsc2UgdGhpcy5leHBhbmRXaW5kb3coKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsb3NlQnV0dG9uMS5vbihcImNsaWNrXCIsIGJ1dHRvbkFuaW0pXHJcbiAgICAgICAgdGhpcy5jbG9zZUJ1dHRvbjIub24oXCJjbGlja1wiLCBidXR0b25BbmltKVxyXG5cclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1jb250YWluZXJcIiBzdHlsZT1cInBhZGRpbmc6MHB4O3Bvc3Rpb246YWJzb2x1dGU7dG9wOjUwcHg7aGVpZ2h0OmNhbGMoMTAwJSAtIDUwcHgpO292ZXJmbG93OmhpZGRlblwiPjwvZGl2PicpXHJcbiAgICAgICAgdGhpcy5jb250YWluZXJET00uY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KVwiKVxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyRE9NLmhvdmVyKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJET00uY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIilcclxuICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRE9NLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOClcIilcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lckRPTS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICAgICAgJCgnYm9keScpLmFwcGVuZCh0aGlzLmNvbnRhaW5lckRPTSlcclxuXHJcbiAgICAgICAgdGhpcy5lbXB0eUNvbnRlbnRBbmREcmF3VGFiQ29udHJvbCgpXHJcbiAgICAgICAgdGhpcy5kcmF3QnV0dG9ucyhudWxsLHRoaXMuaW5mb0NvbnRlbnREaXYpXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE9iamVjdHMgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmxpdmVNb25pdG9yTWFuYWdlcj1uZXcgaW5mb1BhbmVsX2xpdmVNb25pdG9yKHRoaXMpXHJcbiAgICAgICAgdGhpcy5saXZlTW9uaXRvck1hbmFnZXIuc2hvd0JsYW5rKClcclxuICAgIH1cclxuXHJcbiAgICBtaW5pbWl6ZVdpbmRvdygpIHtcclxuICAgICAgICB2YXIgcG9zPXRoaXMuY29udGFpbmVyRE9NLndpZHRoKCktNjBcclxuICAgICAgICB0aGlzLmNvbnRhaW5lckRPTS5hbmltYXRlKHtcclxuICAgICAgICAgICAgcmlnaHQ6IGAtJHtwb3N9cHhgLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IFwiNTBweFwiXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLmlzTWluaW1pemVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBleHBhbmRXaW5kb3coKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXJET00uYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgIHJpZ2h0OiBcIjBweFwiLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IFwiNzAlXCJcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuaXNNaW5pbWl6ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByeE1lc3NhZ2UobXNnUGF5bG9hZCkge1xyXG4gICAgICAgIGlmIChtc2dQYXlsb2FkLm1lc3NhZ2UgPT0gXCJzdGFydFNlbGVjdGlvbkRpYWxvZ19jbG9zZWRcIikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyRE9NLmlzKFwiOnZpc2libGVcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRE9NLnNob3coKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJET00uYWRkQ2xhc3MoXCJ3My1hbmltYXRlLXJpZ2h0XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1zZ1BheWxvYWQubWVzc2FnZSA9PSBcIm1hcEZseWluZ1N0YXJ0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5taW5pbWl6ZVdpbmRvdygpXHJcbiAgICAgICAgfSBlbHNlIGlmIChtc2dQYXlsb2FkLm1lc3NhZ2UgPT0gXCJtYXBGbHlpbmdFbmRcIikge1xyXG4gICAgICAgICAgICB0aGlzLmV4cGFuZFdpbmRvdygpXHJcbiAgICAgICAgfSBlbHNlIGlmIChtc2dQYXlsb2FkLm1lc3NhZ2UgPT0gXCJtYXBTZWxlY3RGZWF0dXJlXCIpIHtcclxuICAgICAgICAgICAgaWYgKG1zZ1BheWxvYWQuREJUd2luICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0d2luSUQgPSBtc2dQYXlsb2FkLkRCVHdpbi5pZFxyXG4gICAgICAgICAgICAgICAgdmFyIGFkdFR3aW4gPSBnbG9iYWxDYWNoZS5zdG9yZWRUd2luc1t0d2luSURdXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dJbmZvT2ZOb2RlcyhbYWR0VHdpbl0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1zZ1BheWxvYWQubWVzc2FnZSA9PSBcInNob3dJbmZvU2VsZWN0ZWROb2Rlc1wiIHx8IG1zZ1BheWxvYWQubWVzc2FnZSA9PSBcInNob3dJbmZvSG92ZXJlZEVsZVwiKSB7XHJcbiAgICAgICAgICAgIGlmIChnbG9iYWxDYWNoZS5zaG93RmxvYXRJbmZvUGFuZWwgJiYgbXNnUGF5bG9hZC5tZXNzYWdlID09IFwic2hvd0luZm9Ib3ZlcmVkRWxlXCIpIHJldHVybjsgLy90aGUgZmxvYXRpbmcgaW5mbyB3aW5kb3cgd2lsbCBzaG93IG1vdXNlIG92ZXIgZWxlbWVudCBpbmZvcm1hdGlvbiwgZG8gbm90IGNoYW5nZSBpbmZvIHBhbmVsIGNvbnRlbnQgaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0luZm9PZk5vZGVzKG1zZ1BheWxvYWQuaW5mbylcclxuICAgICAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2UgPT0gXCJhZGRMaXZlTW9uaXRvclwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGl2ZU1vbml0b3JNYW5hZ2VyLmFkZENoYXJ0KG1zZ1BheWxvYWQudHdpbklELG1zZ1BheWxvYWQucHJvcGVydHlQYXRoKVxyXG4gICAgICAgIH1lbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJsaXZlRGF0YVwiKXtcclxuICAgICAgICAgICAgdmFyIG1zZ0JvZHk9bXNnUGF5bG9hZC5ib2R5XHJcbiAgICAgICAgICAgIHRoaXMubGl2ZU1vbml0b3JNYW5hZ2VyLmRyYXdOZXdEYXRhKG1zZ0JvZHkudHdpbklELG1zZ0JvZHkucHJvcGVydHlQYXRoLG1zZ0JvZHkudmFsdWUsbXNnQm9keS50aW1lKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBzaG93SW5mb09mTm9kZXMoYXJyKSB7XHJcbiAgICAgICAgdGhpcy5lbXB0eUNvbnRlbnRBbmREcmF3VGFiQ29udHJvbCgpXHJcbiAgICAgICAgaWYgKGFyciA9PSBudWxsIHx8IGFyci5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdCdXR0b25zKG51bGwsdGhpcy5pbmZvQ29udGVudERpdilcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9iamVjdHMgPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdGVkT2JqZWN0cyA9IGFycjtcclxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVFbGVtZW50SW5mbyA9IGFyclswXTtcclxuICAgICAgICAgICAgc2luZ2xlRWxlbWVudEluZm89dGhpcy5mZXRjaFJlYWxFbGVtZW50SW5mbyhzaW5nbGVFbGVtZW50SW5mbylcclxuICAgICAgICAgICAgaWYgKHNpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHsvLyBzZWxlY3QgYSBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdCdXR0b25zKFwic2luZ2xlTm9kZVwiLHRoaXMuaW5mb0NvbnRlbnREaXYpXHJcbiAgICAgICAgICAgIH1lbHNlIGlmIChzaW5nbGVFbGVtZW50SW5mb1tcIiRzb3VyY2VJZFwiXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3QnV0dG9ucyhcInNpbmdsZVJlbGF0aW9uc2hpcFwiLHRoaXMuaW5mb0NvbnRlbnREaXYpXHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHNpbmdsZUVsZW1lbnRJbmZvW1wic2ltTm9kZU5hbWVcIl0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2ltRGF0YXNvdXJjZUluZm8oc2luZ2xlRWxlbWVudEluZm8sdGhpcy5pbmZvQ29udGVudERpdilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXNTZWN0aW9uPSBuZXcgc2ltcGxlRXhwYW5kYWJsZVNlY3Rpb24oXCJQcm9wZXJ0aWVzIFNlY3Rpb25cIix0aGlzLmluZm9Db250ZW50RGl2LHtcIm1hcmdpblRvcFwiOlwiMnB4XCJ9KVxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzU2VjdGlvbi5jYWxsQmFja19jaGFuZ2U9KHN0YXR1cyk9Pnt0aGlzLm9wZW5Qcm9wZXJ0aWVzU2VjdGlvbj1zdGF0dXN9XHJcbiAgICAgICAgICAgIGlmKHRoaXMub3BlblByb3BlcnRpZXNTZWN0aW9uKSBwcm9wZXJ0aWVzU2VjdGlvbi5leHBhbmQoKVxyXG5cclxuICAgICAgICAgICAgaWYgKHNpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHsvLyBzZWxlY3QgYSBub2RlXHJcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlREJUd2luSW5mbz1nbG9iYWxDYWNoZS5EQlR3aW5zW3NpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl1dXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaW5nbGVOb2RlUHJvcGVydGllcyhzaW5nbGVEQlR3aW5JbmZvLHNpbmdsZUVsZW1lbnRJbmZvLHByb3BlcnRpZXNTZWN0aW9uLmxpc3RET00pXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlRWxlbWVudEluZm9bXCIkc291cmNlSWRcIl0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NpbmdsZVJlbGF0aW9uUHJvcGVydGllcyhzaW5nbGVFbGVtZW50SW5mbyxwcm9wZXJ0aWVzU2VjdGlvbi5saXN0RE9NKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2luZ2xlRWxlbWVudEluZm9bXCIkZHRJZFwiXSkgdGhpcy5kcmF3Rm9ybXVsYVNlY3Rpb24oc2luZ2xlRWxlbWVudEluZm9bXCIkZHRJZFwiXSxzaW5nbGVFbGVtZW50SW5mb1tcIiRtZXRhZGF0YVwiXVtcIiRtb2RlbFwiXSlcclxuICAgICAgICB9IGVsc2UgaWYgKGFyci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0J1dHRvbnMoXCJtdWx0aXBsZVwiLHRoaXMuaW5mb0NvbnRlbnREaXYpXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd011bHRpcGxlT2JqKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZW1wdHlDb250ZW50QW5kRHJhd1RhYkNvbnRyb2woKXtcclxuICAgICAgICBpZih0aGlzLmluZm9Db250ZW50RGl2KSB0aGlzLmluZm9Db250ZW50RGl2LmVtcHR5KClcclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLkRPTS5lbXB0eSgpXHJcblxyXG4gICAgICAgICAgICB0aGlzLmluZm9Db250ZW50RGl2PSQoJzxkaXYgY2xhc3M9XCJ3My1hbmltYXRlLW9wYWNpdHlcIiBzdHlsZT1cIndpZHRoOjEwMCU7ZmxvYXQ6bGVmdDtoZWlnaHQ6Y2FsYygxMDAlIC0gMXB4KTtvdmVyZmxvdzphdXRvXCI+PC9kaXY+JylcclxuICAgICAgICAgICAgdGhpcy5saXZlQ29udGVudERpdj0kKCc8ZGl2IGlkPVwibXlDaGFydFwiIGNsYXNzPVwidzMtYW5pbWF0ZS1vcGFjaXR5IHczLWJvcmRlci1sZWZ0XCIgc3R5bGU9XCJmbG9hdDpsZWZ0O3BhZGRpbmctdG9wOjVweDtkaXNwbGF5Om5vbmU7aGVpZ2h0OmNhbGMoMTAwJSAtIDFweCk7b3ZlcmZsb3c6YXV0b1wiPjwvZGl2PicpXHJcbiAgICAgICAgICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmluZm9Db250ZW50RGl2LHRoaXMubGl2ZUNvbnRlbnREaXYpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMubGl2ZVBhbmVCdXR0b24ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgICAgICAgICBpZighdGhpcy5saXZlQ29udGVudERpdi5pcyhcIjp2aXNpYmxlXCIpKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpdmVDb250ZW50RGl2LnNob3coKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRE9NLmNzcyhcIndpZHRoXCIsXCI2MDBweFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mb0NvbnRlbnREaXYuY3NzKFwid2lkdGhcIixcIjUwJVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGl2ZUNvbnRlbnREaXYuY3NzKFwid2lkdGhcIixcIjUwJVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGl2ZVBhbmVCdXR0b24udGV4dChcIkhpZGUgTGl2ZSBQYW5lXCIpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpdmVDb250ZW50RGl2LmhpZGUoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRE9NLmNzcyhcIndpZHRoXCIsXCIzNTBweFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mb0NvbnRlbnREaXYuY3NzKFwid2lkdGhcIixcIjEwMCVcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpdmVQYW5lQnV0dG9uLnRleHQoXCJTaG93IExpdmUgUGFuZVwiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdCdXR0b25zKHNlbGVjdFR5cGUscGFyZW50RE9NKSB7XHJcbiAgICAgICAgaWYoc2VsZWN0VHlwZT09bnVsbCl7XHJcbiAgICAgICAgICAgIHZhciBkaXY9JChcIjxkaXYgc3R5bGU9J3BhZGRpbmc6OHB4Jz48YSBzdHlsZT0nZGlzcGxheTpibG9jaztmb250LXN0eWxlOml0YWxpYztjb2xvcjpncmF5Jz5SaWdodCBjbGljayB0d2lucyBvciByZWxhdGlvbnNoaXBzIHRvIG9wZXJhdGU8L2E+PGEgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7Zm9udC1zdHlsZTppdGFsaWM7Y29sb3I6Z3JheTtwYWRkaW5nLXRvcDoyMHB4Jz5QcmVzcyBzaGlmdCBrZXkgdG8gZHJhdyBib3ggYW5kIHNlbGVjdCBtdWx0aXBsZSB0d2lucyBpbiB0b3BvbG9neSB2aWV3PC9hPjxhIHN0eWxlPSdkaXNwbGF5OmJsb2NrO2ZvbnQtc3R5bGU6aXRhbGljO2NvbG9yOmdyYXk7cGFkZGluZy10b3A6MjBweCc+UHJlc3MgY3RybCt6IGFuZCBjdHJsK3kgdG8gdW5kby9yZWRvIGluIHRvcG9sb2d5IHZpZXc7IGN0cmwrcyB0byBzYXZlIGxheW91dDwvYT48YSBzdHlsZT0nZGlzcGxheTpibG9jaztmb250LXN0eWxlOml0YWxpYztjb2xvcjpncmF5O3BhZGRpbmctdG9wOjIwcHg7cGFkZGluZy1ib3R0b206MjBweCc+UHJlc3Mgc2hpZnQgb3IgY3RybCBrZXkgdG8gc2VsZWN0IG11bHRpcGxlIHR3aW5zIGluIHRyZWUgdmlldzwvYT48YSBzdHlsZT0nZGlzcGxheTpibG9jaztmb250LXN0eWxlOml0YWxpYztjb2xvcjpncmF5O3BhZGRpbmctdG9wOjEycHg7cGFkZGluZy1ib3R0b206NXB4Jz5JbXBvcnQgdHdpbnMgZGF0YSBieSBjbGlja2luZyBidXR0b24gYmVsb3c8L2E+PC9kaXY+XCIpXHJcbiAgICAgICAgICAgIHBhcmVudERPTS5hcHBlbmQoZGl2KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJ1dHRvbkhvbGRlckRPTT1wYXJlbnRET01cclxuXHJcbiAgICAgICAgdmFyIGltcEJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtYmx1ZVwiPjxpIGNsYXNzPVwiZmFzIGZhLWNsb3VkLXVwbG9hZC1hbHRcIj48L2k+PC9idXR0b24+JylcclxuICAgICAgICB2YXIgYWN0dWFsSW1wb3J0VHdpbnNCdG4gPSAkKCc8aW5wdXQgdHlwZT1cImZpbGVcIiBuYW1lPVwibW9kZWxGaWxlc1wiIG11bHRpcGxlPVwibXVsdGlwbGVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPjwvaW5wdXQ+JylcclxuICAgICAgICBpZiAoc2VsZWN0VHlwZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciByZWZyZXNoQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1iYXItaXRlbSB3My1idXR0b24gdzMtYmxhY2tcIj48aSBjbGFzcz1cImZhcyBmYS1zeW5jLWFsdFwiPjwvaT48L2J1dHRvbj4nKVxyXG4gICAgICAgICAgICB2YXIgZXhwQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1iYXItaXRlbSB3My1idXR0b24gdzMtZ3JlZW5cIj48aSBjbGFzcz1cImZhcyBmYS1jbG91ZC1kb3dubG9hZC1hbHRcIj48L2k+PC9idXR0b24+JylcclxuICAgICAgICAgICAgYnV0dG9uSG9sZGVyRE9NLmFwcGVuZChyZWZyZXNoQnRuLCBleHBCdG4sIGltcEJ0biwgYWN0dWFsSW1wb3J0VHdpbnNCdG4pXHJcbiAgICAgICAgICAgIHJlZnJlc2hCdG4ub24oXCJjbGlja1wiLCAoKSA9PiB7IHRoaXMucmVmcmVzaEluZm9tYXRpb24oKSB9KVxyXG4gICAgICAgICAgICBleHBCdG4ub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgb3V0IHRoZSB0d2lucyBpbiBzZWxlY3Rpb24gYW5kIHRoZWlyIGNvbm5lY3Rpb25zIChmaWx0ZXIgYm90aCBzcmMgYW5kIHRhcmdldCB3aXRoaW4gdGhlIHNlbGVjdGVkIHR3aW5zKVxyXG4gICAgICAgICAgICAgICAgLy9hbmQgZXhwb3J0IHRoZW1cclxuICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0U2VsZWN0ZWQoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbkhvbGRlckRPTS5hcHBlbmQoaW1wQnRuLCBhY3R1YWxJbXBvcnRUd2luc0J0bilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGltcEJ0bi5vbihcImNsaWNrXCIsICgpID0+IHsgYWN0dWFsSW1wb3J0VHdpbnNCdG4udHJpZ2dlcignY2xpY2snKTsgfSlcclxuICAgICAgICBhY3R1YWxJbXBvcnRUd2luc0J0bi5jaGFuZ2UoYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBldnQudGFyZ2V0LmZpbGVzOyAvLyBGaWxlTGlzdCBvYmplY3RcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWFkVHdpbnNGaWxlc0NvbnRlbnRBbmRJbXBvcnQoZmlsZXMpXHJcbiAgICAgICAgICAgIGFjdHVhbEltcG9ydFR3aW5zQnRuLnZhbChcIlwiKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgaWYgKHNlbGVjdFR5cGUgPT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgbnVtT2ZOb2RlID0gMDtcclxuICAgICAgICB2YXIgYXJyID0gdGhpcy5zZWxlY3RlZE9iamVjdHM7XHJcbiAgICAgICAgYXJyLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50WyckZHRJZCddKSBudW1PZk5vZGUrK1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChudW1PZk5vZGUgPiAxKSB7XHJcbiAgICAgICAgICAgIC8vc29tZSBhZGRpdGlvbmFsIGJ1dHRvbnMgd2hlbiBzZWxlY3QgbXVsdGlwbGUgaXRlbXNcclxuICAgICAgICAgICAgdGhpcy5kcmF3QWR2YW5jZUFsaWdubWVudEJ1dHRvbnMoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBkcmF3QWR2YW5jZUFsaWdubWVudEJ1dHRvbnMoKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gJChcIjxsYWJlbCBjbGFzcz0ndzMtZ3JheScgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDo1cHg7d2lkdGg6MjAlO3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZToxZW07cGFkZGluZzoycHggNHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtib3JkZXItcmFkaXVzOiAycHg7Jz5BcnJhbmdlPC9sYWJlbD5cIilcclxuICAgICAgICB0aGlzLmluZm9Db250ZW50RGl2LmFwcGVuZChsYWJlbClcclxuICAgICAgICB2YXIgYWxpZ25CdXR0b25zVGFibGUgPSAkKFwiPHRhYmxlIHN0eWxlPSdtYXJnaW46MCBhdXRvJz48dHI+PHRkPjwvdGQ+PHRkPjwvdGQ+PHRkPjwvdGQ+PC90cj48dHI+PHRkPjwvdGQ+PHRkIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjtmb250LXdlaWdodDpib2xkO2NvbG9yOmRhcmtHcmF5Jz5BTElHTjwvdGQ+PHRkPjwvdGQ+PC90cj48dHI+PHRkPjwvdGQ+PHRkPjwvdGQ+PHRkPjwvdGQ+PC90cj48L3RhYmxlPlwiKVxyXG4gICAgICAgIHRoaXMuaW5mb0NvbnRlbnREaXYuYXBwZW5kKGFsaWduQnV0dG9uc1RhYmxlKVxyXG4gICAgICAgIHZhciBhbGlnblRvcEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWJvcmRlclwiPjxpIGNsYXNzPVwiZmFzIGZhLWNoZXZyb24tdXBcIj48L2k+PC9idXR0b24+JylcclxuICAgICAgICB2YXIgYWxpZ25MZWZ0QnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtYm9yZGVyXCI+PGkgY2xhc3M9XCJmYXMgZmEtY2hldnJvbi1sZWZ0XCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICAgICAgdmFyIGFsaWduUmlnaHRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1ib3JkZXJcIj48aSBjbGFzcz1cImZhcyBmYS1jaGV2cm9uLXJpZ2h0XCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICAgICAgdmFyIGFsaWduQm90dG9tQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtYm9yZGVyXCI+PGkgY2xhc3M9XCJmYXMgZmEtY2hldnJvbi1kb3duXCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICAgICAgYWxpZ25CdXR0b25zVGFibGUuZmluZChcInRkXCIpLmVxKDEpLmFwcGVuZChhbGlnblRvcEJ1dHRvbilcclxuICAgICAgICBhbGlnbkJ1dHRvbnNUYWJsZS5maW5kKFwidGRcIikuZXEoMykuYXBwZW5kKGFsaWduTGVmdEJ1dHRvbilcclxuICAgICAgICBhbGlnbkJ1dHRvbnNUYWJsZS5maW5kKFwidGRcIikuZXEoNSkuYXBwZW5kKGFsaWduUmlnaHRCdXR0b24pXHJcbiAgICAgICAgYWxpZ25CdXR0b25zVGFibGUuZmluZChcInRkXCIpLmVxKDcpLmFwcGVuZChhbGlnbkJvdHRvbUJ1dHRvbilcclxuXHJcblxyXG4gICAgICAgIHZhciBhcnJhbmdlVGFibGUgPSAkKFwiPHRhYmxlIHN0eWxlPSdtYXJnaW46MCBhdXRvJz48dHI+PHRkPjwvdGQ+PHRkPjwvdGQ+PHRkPjwvdGQ+PHRkPjwvdGQ+PC90cj48dHI+PHRkPjwvdGQ+PHRkPjwvdGQ+PHRkPjwvdGQ+PHRkPjwvdGQ+PC90cj48L3RhYmxlPlwiKVxyXG4gICAgICAgIHRoaXMuaW5mb0NvbnRlbnREaXYuYXBwZW5kKGFycmFuZ2VUYWJsZSlcclxuXHJcbiAgICAgICAgdmFyIGRpc3RyaWJ1dGVIQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtYm9yZGVyXCI+PGkgY2xhc3M9XCJmYXMgZmEtZWxsaXBzaXMtaCBmYS1sZ1wiPjwvaT48L2J1dHRvbj4nKVxyXG4gICAgICAgIHZhciBkaXN0cmlidXRlVkJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWJvcmRlclwiPjxpIGNsYXNzPVwiZmFzIGZhLWVsbGlwc2lzLXYgZmEtbGdcIj48L2k+PC9idXR0b24+JylcclxuICAgICAgICB2YXIgbGVmdFJvdGF0ZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWJvcmRlclwiPjxpIGNsYXNzPVwiZmFzIGZhLXVuZG8tYWx0IGZhLWxnXCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICAgICAgdmFyIHJpZ2h0Um90YXRlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtYm9yZGVyXCI+PGkgY2xhc3M9XCJmYXMgZmEtcmVkby1hbHQgZmEtbGdcIj48L2k+PC9idXR0b24+JylcclxuICAgICAgICB2YXIgbWlycm9ySEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWJvcmRlclwiIHN0eWxlPVwid2lkdGg6MTAwJVwiPjxpIGNsYXNzPVwiZmFzIGZhLWFycm93cy1hbHQtaFwiPjwvaT48L2J1dHRvbj4nKVxyXG4gICAgICAgIHZhciBtaXJyb3JWQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtYm9yZGVyXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCI+PGkgY2xhc3M9XCJmYXMgZmEtYXJyb3dzLWFsdC12XCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICAgICAgdmFyIGV4cGFuZEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWJvcmRlclwiIHN0eWxlPVwid2lkdGg6MTAwJVwiPjxpIGNsYXNzPVwiZmFzIGZhLWV4cGFuZC1hcnJvd3MtYWx0XCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICAgICAgdmFyIGNvbXByZXNzQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtYm9yZGVyXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29tcHJlc3MtYXJyb3dzLWFsdFwiPjwvaT48L2J1dHRvbj4nKVxyXG5cclxuICAgICAgICBhcnJhbmdlVGFibGUuZmluZChcInRkXCIpLmVxKDApLmFwcGVuZChkaXN0cmlidXRlSEJ1dHRvbilcclxuICAgICAgICBhcnJhbmdlVGFibGUuZmluZChcInRkXCIpLmVxKDEpLmFwcGVuZChkaXN0cmlidXRlVkJ1dHRvbilcclxuICAgICAgICBhcnJhbmdlVGFibGUuZmluZChcInRkXCIpLmVxKDIpLmFwcGVuZChsZWZ0Um90YXRlQnV0dG9uKVxyXG4gICAgICAgIGFycmFuZ2VUYWJsZS5maW5kKFwidGRcIikuZXEoMykuYXBwZW5kKHJpZ2h0Um90YXRlQnV0dG9uKVxyXG4gICAgICAgIGFycmFuZ2VUYWJsZS5maW5kKFwidGRcIikuZXEoNCkuYXBwZW5kKG1pcnJvckhCdXR0b24pXHJcbiAgICAgICAgYXJyYW5nZVRhYmxlLmZpbmQoXCJ0ZFwiKS5lcSg1KS5hcHBlbmQobWlycm9yVkJ1dHRvbilcclxuICAgICAgICBhcnJhbmdlVGFibGUuZmluZChcInRkXCIpLmVxKDYpLmFwcGVuZChleHBhbmRCdXR0b24pXHJcbiAgICAgICAgYXJyYW5nZVRhYmxlLmZpbmQoXCJ0ZFwiKS5lcSg3KS5hcHBlbmQoY29tcHJlc3NCdXR0b24pXHJcblxyXG5cclxuICAgICAgICBhbGlnblRvcEJ1dHRvbi5vbihcImNsaWNrXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcImFsaWduU2VsZWN0ZWROb2RlXCIsIGRpcmVjdGlvbjogXCJ0b3BcIiB9KVxyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmJsdXIoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgYWxpZ25MZWZ0QnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJhbGlnblNlbGVjdGVkTm9kZVwiLCBkaXJlY3Rpb246IFwibGVmdFwiIH0pXHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuYmx1cigpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBhbGlnblJpZ2h0QnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJhbGlnblNlbGVjdGVkTm9kZVwiLCBkaXJlY3Rpb246IFwicmlnaHRcIiB9KVxyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmJsdXIoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgYWxpZ25Cb3R0b21CdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcImFsaWduU2VsZWN0ZWROb2RlXCIsIGRpcmVjdGlvbjogXCJib3R0b21cIiB9KVxyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmJsdXIoKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGRpc3RyaWJ1dGVIQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJkaXN0cmlidXRlU2VsZWN0ZWROb2RlXCIsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgfSlcclxuICAgICAgICAgICAgJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5ibHVyKClcclxuICAgICAgICB9KVxyXG4gICAgICAgIGRpc3RyaWJ1dGVWQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJkaXN0cmlidXRlU2VsZWN0ZWROb2RlXCIsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiIH0pXHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuYmx1cigpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBsZWZ0Um90YXRlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJyb3RhdGVTZWxlY3RlZE5vZGVcIiwgZGlyZWN0aW9uOiBcImxlZnRcIiB9KVxyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmJsdXIoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmlnaHRSb3RhdGVCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInJvdGF0ZVNlbGVjdGVkTm9kZVwiLCBkaXJlY3Rpb246IFwicmlnaHRcIiB9KVxyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmJsdXIoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgbWlycm9ySEJ1dHRvbi5vbihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwibWlycm9yU2VsZWN0ZWROb2RlXCIsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgfSlcclxuICAgICAgICAgICAgJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5ibHVyKClcclxuICAgICAgICB9KVxyXG4gICAgICAgIG1pcnJvclZCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcIm1pcnJvclNlbGVjdGVkTm9kZVwiLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiB9KVxyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmJsdXIoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgZXhwYW5kQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJkaW1lbnNpb25TZWxlY3RlZE5vZGVcIiwgZGlyZWN0aW9uOiBcImV4cGFuZFwiIH0pXHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuYmx1cigpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBjb21wcmVzc0J1dHRvbi5vbihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiZGltZW5zaW9uU2VsZWN0ZWROb2RlXCIsIGRpcmVjdGlvbjogXCJjb21wcmVzc1wiIH0pXHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuYmx1cigpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcblxyXG4gICAgYXN5bmMgZXhwb3J0U2VsZWN0ZWQoKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzO1xyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09IDApIHJldHVybjtcclxuICAgICAgICB2YXIgdHdpbklEQXJyID0gW11cclxuICAgICAgICB2YXIgdHdpblRvQmVTdG9yZWQgPSBbXVxyXG4gICAgICAgIHZhciB0d2luSURzID0ge31cclxuICAgICAgICBhcnIuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRbJyRzb3VyY2VJZCddKSByZXR1cm5cclxuICAgICAgICAgICAgdHdpbklEQXJyLnB1c2goZWxlbWVudFsnJGR0SWQnXSlcclxuICAgICAgICAgICAgdmFyIGFuRXhwVHdpbiA9IHt9XHJcbiAgICAgICAgICAgIGFuRXhwVHdpbltcIiRtZXRhZGF0YVwiXSA9IHsgXCIkbW9kZWxcIjogZWxlbWVudFtcIiRtZXRhZGF0YVwiXVtcIiRtb2RlbFwiXSB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZCBpbiBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kID09IFwiJG1ldGFkYXRhXCIgfHwgaW5kID09IFwiJGV0YWdcIikgY29udGludWVcclxuICAgICAgICAgICAgICAgIGVsc2UgYW5FeHBUd2luW2luZF0gPSBlbGVtZW50W2luZF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0d2luVG9CZVN0b3JlZC5wdXNoKGFuRXhwVHdpbilcclxuICAgICAgICAgICAgdHdpbklEc1tlbGVtZW50WyckZHRJZCddXSA9IDFcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVsYXRpb25zVG9CZVN0b3JlZCA9IFtdXHJcbiAgICAgICAgdHdpbklEQXJyLmZvckVhY2gob25lSUQgPT4ge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpb25zID0gZ2xvYmFsQ2FjaGUuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW29uZUlEXVxyXG4gICAgICAgICAgICBpZiAoIXJlbGF0aW9ucykgcmV0dXJuO1xyXG4gICAgICAgICAgICByZWxhdGlvbnMuZm9yRWFjaChvbmVSZWxhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SUQgPSBvbmVSZWxhdGlvbltcIiR0YXJnZXRJZFwiXVxyXG4gICAgICAgICAgICAgICAgaWYgKHR3aW5JRHNbdGFyZ2V0SURdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kIGluIG9uZVJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmQgPT0gXCIkZXRhZ1wiIHx8IGluZCA9PSBcIiRyZWxhdGlvbnNoaXBJZFwiIHx8IGluZCA9PSBcIiRzb3VyY2VJZFwiIHx8IGluZCA9PSBcInNvdXJjZU1vZGVsXCIpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtpbmRdID0gb25lUmVsYXRpb25baW5kXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25lQWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiRzcmNJZFwiOiBvbmVJRCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIkcmVsYXRpb25zaGlwSWRcIjogb25lUmVsYXRpb25bXCIkcmVsYXRpb25zaGlwSWRcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib2JqXCI6IG9ialxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNUb0JlU3RvcmVkLnB1c2gob25lQWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdmFyIGZpbmFsSlNPTiA9IHsgXCJ0d2luc1wiOiB0d2luVG9CZVN0b3JlZCwgXCJyZWxhdGlvbnNcIjogcmVsYXRpb25zVG9CZVN0b3JlZCB9XHJcbiAgICAgICAgdmFyIHBvbSA9ICQoXCI8YT48L2E+XCIpXHJcbiAgICAgICAgcG9tLmF0dHIoJ2hyZWYnLCAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShmaW5hbEpTT04pKSk7XHJcbiAgICAgICAgcG9tLmF0dHIoJ2Rvd25sb2FkJywgXCJleHBvcnRUd2luc0RhdGEuanNvblwiKTtcclxuICAgICAgICBwb21bMF0uY2xpY2soKVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHJlYWRPbmVGaWxlKGFGaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYUZpbGUpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgcmVhZFR3aW5zRmlsZXNDb250ZW50QW5kSW1wb3J0KGZpbGVzKSB7XHJcbiAgICAgICAgdmFyIGltcG9ydFR3aW5zID0gW11cclxuICAgICAgICB2YXIgaW1wb3J0UmVsYXRpb25zID0gW11cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaTwgZmlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGY9ZmlsZXNbaV1cclxuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGpzb24gZmlsZXMuXHJcbiAgICAgICAgICAgIGlmIChmLnR5cGUgIT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IGF3YWl0IHRoaXMucmVhZE9uZUZpbGUoZilcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBKU09OLnBhcnNlKHN0cilcclxuICAgICAgICAgICAgICAgIGlmIChvYmoudHdpbnMpIGltcG9ydFR3aW5zID0gaW1wb3J0VHdpbnMuY29uY2F0KG9iai50d2lucylcclxuICAgICAgICAgICAgICAgIGlmIChvYmoucmVsYXRpb25zKSBpbXBvcnRSZWxhdGlvbnMgPSBpbXBvcnRSZWxhdGlvbnMuY29uY2F0KG9iai5yZWxhdGlvbnMpXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZXJyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb2xkVHdpbklEMk5ld0lEID0ge31cclxuICAgICAgICBpbXBvcnRUd2lucy5mb3JFYWNoKG9uZVR3aW4gPT4ge1xyXG4gICAgICAgICAgICB2YXIgb2xkSUQgPSBvbmVUd2luW1wiJGR0SWRcIl1cclxuICAgICAgICAgICAgdmFyIG5ld0lEID0gZ2xvYmFsQ2FjaGUudXVpZHY0KCk7XHJcbiAgICAgICAgICAgIG9sZFR3aW5JRDJOZXdJRFtvbGRJRF0gPSBuZXdJRFxyXG4gICAgICAgICAgICBvbmVUd2luW1wiJGR0SWRcIl0gPSBuZXdJRFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBpbXBvcnRSZWxhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIG9uZVJlbCA9IGltcG9ydFJlbGF0aW9uc1tpXVxyXG4gICAgICAgICAgICBpZiAob2xkVHdpbklEMk5ld0lEW29uZVJlbFtcIiRzcmNJZFwiXV0gPT0gbnVsbCB8fCBvbGRUd2luSUQyTmV3SURbb25lUmVsW1wib2JqXCJdW1wiJHRhcmdldElkXCJdXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnRSZWxhdGlvbnMuc3BsaWNlKGksIDEpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvbmVSZWxbXCIkc3JjSWRcIl0gPSBvbGRUd2luSUQyTmV3SURbb25lUmVsW1wiJHNyY0lkXCJdXVxyXG4gICAgICAgICAgICAgICAgb25lUmVsW1wib2JqXCJdW1wiJHRhcmdldElkXCJdID0gb2xkVHdpbklEMk5ld0lEW29uZVJlbFtcIm9ialwiXVtcIiR0YXJnZXRJZFwiXV1cclxuICAgICAgICAgICAgICAgIG9uZVJlbFtcIiRyZWxhdGlvbnNoaXBJZFwiXSA9IGdsb2JhbENhY2hlLnV1aWR2NCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHJlID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vYmF0Y2hJbXBvcnRUd2luc1wiLCBcIlBPU1RcIiwgeyBcInR3aW5zXCI6IEpTT04uc3RyaW5naWZ5KGltcG9ydFR3aW5zKSB9LCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlLkRCVHdpbnMgPSBKU09OLnBhcnNlKHJlLkRCVHdpbnMpXHJcbiAgICAgICAgcmUuQURUVHdpbnMgPSBKU09OLnBhcnNlKHJlLkFEVFR3aW5zKVxyXG4gICAgICAgIHJlLkRCVHdpbnMuZm9yRWFjaChEQlR3aW4gPT4geyBnbG9iYWxDYWNoZS5zdG9yZVNpbmdsZURCVHdpbihEQlR3aW4pIH0pXHJcbiAgICAgICAgdmFyIGFkdFR3aW5zID0gW11cclxuICAgICAgICByZS5BRFRUd2lucy5mb3JFYWNoKEFEVFR3aW4gPT4ge1xyXG4gICAgICAgICAgICBnbG9iYWxDYWNoZS5zdG9yZVNpbmdsZUFEVFR3aW4oQURUVHdpbilcclxuICAgICAgICAgICAgYWR0VHdpbnMucHVzaChBRFRUd2luKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcImFkZE5ld1R3aW5zXCIsIFwidHdpbnNJbmZvXCI6IGFkdFR3aW5zIH0pXHJcblxyXG4gICAgICAgIC8vY29udGludWUgdG8gaW1wb3J0IHJlbGF0aW9uc1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGlvbnNJbXBvcnRlZCA9IGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2NyZWF0ZVJlbGF0aW9uc1wiLCBcIlBPU1RcIiwgeyBhY3Rpb25zOiBKU09OLnN0cmluZ2lmeShpbXBvcnRSZWxhdGlvbnMpIH0pXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBnbG9iYWxDYWNoZS5zdG9yZVR3aW5SZWxhdGlvbnNoaXBzX2FwcGVuZChyZWxhdGlvbnNJbXBvcnRlZClcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJkcmF3QWxsUmVsYXRpb25zXCIsIGluZm86IHJlbGF0aW9uc0ltcG9ydGVkIH0pXHJcblxyXG4gICAgICAgIHZhciBudW1PZlR3aW5zID0gYWR0VHdpbnMubGVuZ3RoXHJcbiAgICAgICAgdmFyIG51bU9mUmVsYXRpb25zID0gcmVsYXRpb25zSW1wb3J0ZWQubGVuZ3RoXHJcbiAgICAgICAgdmFyIHN0ciA9IFwiQWRkIFwiICsgbnVtT2ZUd2lucyArIFwiIG5vZGVcIiArICgobnVtT2ZUd2lucyA8PSAxKSA/IFwiXCIgOiBcInNcIikgKyBgIChmcm9tICR7aW1wb3J0VHdpbnMubGVuZ3RofSlgXHJcbiAgICAgICAgc3RyICs9IFwiIGFuZCBcIiArIG51bU9mUmVsYXRpb25zICsgXCIgcmVsYXRpb25zaGlwXCIgKyAoKG51bU9mUmVsYXRpb25zIDw9IDEpID8gXCJcIiA6IFwic1wiKSArIGAgKGZyb20gJHtpbXBvcnRSZWxhdGlvbnMubGVuZ3RofSlgXHJcbiAgICAgICAgdmFyIGNvbmZpcm1EaWFsb2dEaXYgPSBuZXcgc2ltcGxlQ29uZmlybURpYWxvZygpXHJcbiAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5zaG93KFxyXG4gICAgICAgICAgICB7IHdpZHRoOiBcIjQwMHB4XCIgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiSW1wb3J0IFJlc3VsdFwiXHJcbiAgICAgICAgICAgICAgICAsIGNvbnRlbnQ6IHN0clxyXG4gICAgICAgICAgICAgICAgLCBidXR0b25zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLWdyYXlcIiwgdGV4dDogXCJPa1wiLCBcImNsaWNrRnVuY1wiOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIClcclxuXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgcmVmcmVzaEluZm9tYXRpb24oKSB7XHJcbiAgICAgICAgdmFyIHR3aW5JRHMgPSBbXVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRPYmplY3RzLmZvckVhY2gob25lSXRlbSA9PiB7IGlmIChvbmVJdGVtWyckZHRJZCddKSB0d2luSURzLnB1c2gob25lSXRlbVsnJGR0SWQnXSkgfSlcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgdHdpbnNkYXRhID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vbGlzdFR3aW5zRm9ySURzXCIsIFwiUE9TVFwiLCB0d2luSURzKVxyXG4gICAgICAgICAgICB0d2luc2RhdGEuZm9yRWFjaChvbmVSZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHdpbklEID0gb25lUmVbJyRkdElkJ11cclxuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxDYWNoZS5zdG9yZWRUd2luc1t0d2luSURdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxDYWNoZS5zdG9yZVNpbmdsZUFEVFR3aW4ob25lUmUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUgKHR3aW5JRHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgc21hbGxBcnIgPSB0d2luSURzLnNwbGljZSgwLCAxMDApO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9nZXRSZWxhdGlvbnNoaXBzRnJvbVR3aW5JRHNcIiwgXCJQT1NUXCIsIHNtYWxsQXJyKVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT0gXCJcIikgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBnbG9iYWxDYWNoZS5zdG9yZVR3aW5SZWxhdGlvbnNoaXBzKGRhdGEpIC8vc3RvcmUgdGhlbSBpbiBnbG9iYWwgYXZhaWxhYmxlIGFycmF5XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJkcmF3QWxsUmVsYXRpb25zXCIsIGluZm86IGRhdGEgfSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9yZWRyYXcgaW5mb3BhbmVsIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkT2JqZWN0cy5sZW5ndGggPT0gMSkgdGhpcy5yeE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJzaG93SW5mb1NlbGVjdGVkTm9kZXNcIiwgaW5mbzogdGhpcy5zZWxlY3RlZE9iamVjdHMgfSlcclxuICAgIH1cclxuXHJcbiAgICBkcmF3Rm9ybXVsYVNlY3Rpb24oZm9ybXVsYVR3aW5JRCxmb3JtdWxhVHdpbk1vZGVsSUQpe1xyXG4gICAgICAgIHZhciBmb3JtdWxhU2VjdGlvbj0gbmV3IHNpbXBsZUV4cGFuZGFibGVTZWN0aW9uKFwiTGl2ZSBDYWxjdWxhdGlvbiBTZWN0aW9uXCIsdGhpcy5pbmZvQ29udGVudERpdilcclxuICAgICAgICBmb3JtdWxhU2VjdGlvbi5jYWxsQmFja19jaGFuZ2U9KHN0YXR1cyk9Pnt0aGlzLm9wZW5MaXZlQ2FsY3VsYXRpb25TZWN0aW9uPXN0YXR1c31cclxuICAgICAgICBpZih0aGlzLm9wZW5MaXZlQ2FsY3VsYXRpb25TZWN0aW9uKSBmb3JtdWxhU2VjdGlvbi5leHBhbmQoKVxyXG5cclxuICAgICAgICAvL2xpc3QgYWxsIGluY29taW5nIHR3aW5zXHJcbiAgICAgICAgdmFyIGluY29taW5nTmVpZ2hib3VyTGJsPXRoaXMuZ2VuZXJhdGVTbWFsbEtleURpdihcIkluY29taW5nIFR3aW5zIEFuZCBTZWxmXCIsXCIycHhcIilcclxuICAgICAgICB2YXIgbGJsMT0kKCc8bGJsIHN0eWxlPVwiZm9udC1zaXplOjEwcHg7Y29sb3I6Z3JheVwiPihDbGljayB0byBhZGQgdHdpbiBuYW1lIHRvIHNjcmlwdCk8L2xibD4nKVxyXG4gICAgICAgIGluY29taW5nTmVpZ2hib3VyTGJsLmFwcGVuZChsYmwxKVxyXG4gICAgICAgIGZvcm11bGFTZWN0aW9uLmxpc3RET00uYXBwZW5kKGluY29taW5nTmVpZ2hib3VyTGJsKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpbmNvbWluZ1R3aW5zPWdsb2JhbENhY2hlLmdldFN0b3JlZEFsbEluYm91bmRSZWxhdGlvbnNTb3VyY2VzKGZvcm11bGFUd2luSUQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNjcmlwdExibD10aGlzLmdlbmVyYXRlU21hbGxLZXlEaXYoXCJDYWxjdWxhdGlvbiBTY3JpcHRcIixcIjJweFwiKVxyXG4gICAgICAgIHNjcmlwdExibC5jc3MoXCJtYXJnaW4tdG9wXCIsXCIxMHB4XCIpXHJcblxyXG4gICAgICAgIHZhciBsYmwyPSQoJzxsYmwgc3R5bGU9XCJmb250LXNpemU6MTBweDtjb2xvcjpncmF5XCI+KEJ1aWxkIGluIHZhcmlhYmxlczpfc2VsZiBfdHdpblZhbCk8L2xibD4nKVxyXG4gICAgICAgIHNjcmlwdExibC5hcHBlbmQobGJsMilcclxuXHJcbiAgICAgICAgdmFyIHBsYWNlSG9sZGVyU3RyPSdTYW1wbGUmIzE2MDtTY3JpcHQmIzU4OyYjMTA7JiMxMDtpZihfdHdpblZhbFtcImludHdpbjFcIl1bXCJwMVwiXVtcImNoaWxkUHJvcFwiXSl7JiMxMDsmIzk7X3NlbGZbXCJvdXRQcm9wXCJdPV90d2luVmFsW1wiaW50d2luMVwiXVtcInAyXCJdJiMxMDt9ZWxzZXsmIzEwOyYjOTtfc2VsZltcIm91dFByb3BcIl09X3R3aW5WYWxbXCJpbnR3aW4xXCJdW1wicDJcIl0mIzMyOysmIzMyOyYjMTA7JiM5OyYjOTtfdHdpblZhbFtcImludHdpbjJcIl1bXCJwM1wiXVtcInA0XCJdJiMxMDt9J1xyXG4gICAgICAgIHZhciBzY3JpcHRUZXh0QXJlYT0kKCc8dGV4dGFyZWEgY2xhc3M9XCJ3My1ib3JkZXJcIiBzcGVsbGNoZWNrPVwiZmFsc2VcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtmb250LXNpemU6MTFweDtoZWlnaHQ6MjQwcHg7d2lkdGg6MTAwJTtmb250LWZhbWlseTpWZXJkYW5hXCIgcGxhY2Vob2xkZXI9JytwbGFjZUhvbGRlclN0cisnPjwvdGV4dGFyZWE+JylcclxuICAgICAgICBzY3JpcHRUZXh0QXJlYS5vbihcImtleWRvd25cIiwgKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSA5KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0VG9UZXh0QXJlYSgnXFx0JyxzY3JpcHRUZXh0QXJlYSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdmFyIERCRm9ybXVsYVR3aW49Z2xvYmFsQ2FjaGUuREJUd2luc1tmb3JtdWxhVHdpbklEXVxyXG4gICAgICAgIGlmKERCRm9ybXVsYVR3aW4gJiYgREJGb3JtdWxhVHdpbltcIm9yaWdpbmFsU2NyaXB0XCJdKSBzY3JpcHRUZXh0QXJlYS52YWwoREJGb3JtdWxhVHdpbltcIm9yaWdpbmFsU2NyaXB0XCJdKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBoaWdobGlnaHRDb2xvcnM9W1xyXG4gICAgICAgICAgICBbXCJQdXJwbGVcIixcIiNkMGJmZmZcIl0sW1wiQ3lhblwiLFwiIzAwYmNkNFwiXSxbXCJBbWJlclwiLFwiI2ZmYzEwN1wiXSxbXCJMaW1lXCIsXCIjY2RkYzM5XCJdLFtcIlBpbmtcIixcIiNlOTFlNjNcIl1cclxuICAgICAgICBdXHJcbiAgICAgICAgLy9bXCJHcmF5XCIsXCIjOWU5ZTllXCJdXHJcbiAgICAgICAgdmFyIGhhc0luY29taW5nVHdpbnM9ZmFsc2VcclxuICAgICAgICB2YXIgdHdpbk5hbWVzRm9ySGlnaGxpZ2h0PVtdXHJcbiAgICAgICAgLy9idWlsZCBpbiBrZXkgd29yZFxyXG4gICAgICAgIHR3aW5OYW1lc0ZvckhpZ2hsaWdodC5wdXNoKHsgXCJoaWdobGlnaHRcIjogXCJfc2VsZlwiLCBcImNsYXNzTmFtZVwiOiBcIkdyYXlcIn0pXHJcbiAgICAgICAgdHdpbk5hbWVzRm9ySGlnaGxpZ2h0LnB1c2goeyBcImhpZ2hsaWdodFwiOiBcIl90d2luVmFsXCIsIFwiY2xhc3NOYW1lXCI6IFwia2V5d29yZFwifSlcclxuICAgICAgICB2YXIgY29sb3JJbmRleD0wO1xyXG4gICAgICAgIGZvcih2YXIgdHdpbklEIGluIGluY29taW5nVHdpbnMpe1xyXG4gICAgICAgICAgICBoYXNJbmNvbWluZ1R3aW5zPXRydWVcclxuICAgICAgICAgICAgdmFyIHR3aW5OYW1lPWdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbdHdpbklEXVxyXG4gICAgICAgICAgICB0d2luTmFtZXNGb3JIaWdobGlnaHQucHVzaCh7IFwiaGlnaGxpZ2h0XCI6IHR3aW5OYW1lLCBcImNsYXNzTmFtZVwiOiBoaWdobGlnaHRDb2xvcnNbY29sb3JJbmRleF1bMF19KVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVRdWlja0J0bkZvclR3aW4odHdpbk5hbWUsaGlnaGxpZ2h0Q29sb3JzW2NvbG9ySW5kZXhdWzFdLGZvcm11bGFTZWN0aW9uLmxpc3RET00sc2NyaXB0VGV4dEFyZWEpXHJcbiAgICAgICAgICAgIGNvbG9ySW5kZXgrK1xyXG4gICAgICAgICAgICBpZihjb2xvckluZGV4Pj1oaWdobGlnaHRDb2xvcnMubGVuZ3RoKWNvbG9ySW5kZXg9MFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jcmVhdGVRdWlja0J0bkZvclR3aW4oXCJTZWxmXCIsXCIjOWU5ZTllXCIsZm9ybXVsYVNlY3Rpb24ubGlzdERPTSxzY3JpcHRUZXh0QXJlYSxmb3JtdWxhVHdpbk1vZGVsSUQpXHJcblxyXG4gICAgICAgIGlmKCFoYXNJbmNvbWluZ1R3aW5zKWZvcm11bGFTZWN0aW9uLmxpc3RET00uYXBwZW5kKCQoJzxsYWJlbD5ObyBpbmNvbWluZyB0d2luczwvbGFiZWw+JykpXHJcbiAgICAgICAgZm9ybXVsYVNlY3Rpb24ubGlzdERPTS5hcHBlbmQoc2NyaXB0TGJsKVxyXG4gICAgICAgIGZvcm11bGFTZWN0aW9uLmxpc3RET00uYXBwZW5kKHNjcmlwdFRleHRBcmVhKVxyXG4gICAgICAgIHNjcmlwdFRleHRBcmVhLmhpZ2hsaWdodFdpdGhpblRleHRhcmVhKHtoaWdobGlnaHQ6IHR3aW5OYW1lc0ZvckhpZ2hsaWdodH0pO1xyXG5cclxuICAgICAgICB2YXIgdGVzdFNjcmlwdEJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWxpZ2h0LWdyYXkgdzMtaG92ZXItYW1iZXJcIj5UZXN0PC9idXR0b24+JylcclxuICAgICAgICB2YXIgY29uZmlybVNjcmlwdEJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWdyZWVuICB3My1ob3Zlci1hbWJlclwiPkNvbmZpcm08L2J1dHRvbj4nKVxyXG4gICAgICAgIGZvcm11bGFTZWN0aW9uLmxpc3RET00uYXBwZW5kKHRlc3RTY3JpcHRCdG4sIGNvbmZpcm1TY3JpcHRCdG4pXHJcblxyXG5cclxuICAgICAgICBzY3JpcHRUZXh0QXJlYS5vbihcImtleXVwXCIsKCk9PntcclxuICAgICAgICAgICAgc2NyaXB0VGVzdERpYWxvZy5zY3JpcHRDb250ZW50PXNjcmlwdFRleHRBcmVhLnZhbCgpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGVzdFNjcmlwdEJ0bi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICAgICAgdmFyIHZhbHVlVGVtcGxhdGU9e31cclxuICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlVGVtcGxhdGUobW9kZWxBbmFseXplci5EVERMTW9kZWxzW2Zvcm11bGFUd2luTW9kZWxJRF0uZWRpdGFibGVQcm9wZXJ0aWVzLFtdLHZhbHVlVGVtcGxhdGUpXHJcbiAgICAgICAgICAgIHZhciBpbnB1dEFyciA9IGdsb2JhbENhY2hlLmZpbmRBbGxJbnB1dHNJblNjcmlwdChzY3JpcHRUZXh0QXJlYS52YWwoKSxEQkZvcm11bGFUd2luW1wiZGlzcGxheU5hbWVcIl0pXHJcbiAgICAgICAgICAgIHNjcmlwdFRlc3REaWFsb2cucG9wdXAoaW5wdXRBcnIsREJGb3JtdWxhVHdpbltcImRpc3BsYXlOYW1lXCJdLGZvcm11bGFUd2luTW9kZWxJRCx2YWx1ZVRlbXBsYXRlKVxyXG4gICAgICAgICAgICBzY3JpcHRUZXN0RGlhbG9nLnNjcmlwdENvbnRlbnQ9c2NyaXB0VGV4dEFyZWEudmFsKClcclxuICAgICAgICB9KVxyXG4gICAgICAgIGNvbmZpcm1TY3JpcHRCdG4ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlybVNjcmlwdChzY3JpcHRUZXh0QXJlYS52YWwoKSxmb3JtdWxhVHdpbklELGZvcm11bGFUd2luTW9kZWxJRCxEQkZvcm11bGFUd2luW1wiZGlzcGxheU5hbWVcIl0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBjb25maXJtU2NyaXB0KHNjcmlwdENvbnRlbnQsZm9ybXVsYVR3aW5JRCxmb3JtdWxhVHdpbk1vZGVsSUQsZm9ybXVsYVR3aW5OYW1lKXtcclxuICAgICAgICAvL2RldGVjdCBpZiB0aGVyZSBpcyBwcm9oaWJpdHRlZCB3b3JkcywgaWYgc28sIHJlamVjdCB0aGUgc3VibWl0IHJlcXVlc3RcclxuICAgICAgICBzY3JpcHRDb250ZW50PXNjcmlwdENvbnRlbnQucmVwbGFjZUFsbChgX3R3aW5WYWxbXCIke2Zvcm11bGFUd2luTmFtZX1cIl1bYCxcIl9zZWxmW1wiKVxyXG4gICAgICAgIHNjcmlwdENvbnRlbnQ9c2NyaXB0Q29udGVudC5yZXBsYWNlQWxsKGBfdHdpblZhbFsnJHtmb3JtdWxhVHdpbk5hbWV9J11bYCxcIl9zZWxmW1wiKVxyXG4gICAgICAgIC8vdHJhbnNsYXRlIHNjcmlwdCwgcmVwbGFjZSB0d2lucyBuYW1lIHRvIHR3aW5zIElEXHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVJlc3VsdD10aGlzLmNvbnZlcnRUb0FjdHVhbFNjcmlwdChzY3JpcHRDb250ZW50LGZvcm11bGFUd2luSUQpXHJcblxyXG4gICAgICAgIHZhciB2YWx1ZVRlbXBsYXRlPXt9XHJcbiAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlVGVtcGxhdGUobW9kZWxBbmFseXplci5EVERMTW9kZWxzW2Zvcm11bGFUd2luTW9kZWxJRF0uZWRpdGFibGVQcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICxbXSx2YWx1ZVRlbXBsYXRlKVxyXG5cclxuICAgICAgICB2YXIgaW5wdXRWYWx1ZUFycj1bXVxyXG4gICAgICAgIHZhciBpbnB1dEFuYWx5c2lzUmVzdWx0PSBnbG9iYWxDYWNoZS5maW5kQWxsSW5wdXRzSW5TY3JpcHQoc2NyaXB0Q29udGVudCxmb3JtdWxhVHdpbk5hbWUpXHJcbiAgICAgICAgaW5wdXRBbmFseXNpc1Jlc3VsdC5mb3JFYWNoKGVsZT0+e1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgXCJ0d2luSURcIjpnbG9iYWxDYWNoZS50d2luRGlzcGxheU5hbWVNYXBUb0lEW2VsZS50d2luTmFtZV9vcmlnaW5dLFxyXG4gICAgICAgICAgICAgICAgXCJwYXRoXCI6ZWxlLnBhdGgsXHJcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6ZWxlLnZhbHVlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIHRoZUJvZHk9e1xyXG4gICAgICAgICAgICBcInR3aW5JRFwiOiBmb3JtdWxhVHdpbklELFxyXG4gICAgICAgICAgICBcIm9yaWdpbmFsU2NyaXB0XCI6c2NyaXB0Q29udGVudCxcclxuICAgICAgICAgICAgXCJhY3R1YWxTY3JpcHRcIjp0cmFuc2xhdGVSZXN1bHQsXHJcbiAgICAgICAgICAgIFwiYmFzZVZhbHVlVGVtcGxhdGVcIjp2YWx1ZVRlbXBsYXRlLFxyXG4gICAgICAgICAgICBcInByb2plY3RJRFwiOmdsb2JhbENhY2hlLmN1cnJlbnRQcm9qZWN0SUQsXHJcbiAgICAgICAgICAgIFwiY3VycmVudElucHV0VmFsdWVcIjppbnB1dFZhbHVlQXJyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKHtcInBheWxvYWRcIjpKU09OLnN0cmluZ2lmeSh0aGVCb2R5KSB9KVxyXG4gICAgICAgIC8vYnkgdXNpbmcgd2l0aFByb2plY3RJRCBpdCB3aWxsIGVuc3VyZSBpdCBpcyB0aGUgYXV0aG9yaXplZCBwZXJzb24gc2VuZCB0aGUgY29tbWFuZFxyXG4gICAgICAgIHRyeXsgXHJcbiAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3VwZGF0ZUZvcm11bGFcIiwgXCJQT1NUXCIsIHtcInBheWxvYWRcIjpKU09OLnN0cmluZ2lmeSh0aGVCb2R5KSB9LCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgZ2xvYmFsQ2FjaGUuREJUd2luc1tmb3JtdWxhVHdpbklEXVtcIm9yaWdpbmFsU2NyaXB0XCJdPXNjcmlwdENvbnRlbnRcclxuICAgICAgICB9Y2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldFByb3BlcnR5VmFsdWVUZW1wbGF0ZShqc29uSW5mbyxwYXRoQXJyLHZhbHVlVGVtcGxhdGVSb290KXtcclxuICAgICAgICBmb3IodmFyIGluZCBpbiBqc29uSW5mbyl7XHJcbiAgICAgICAgICAgIHZhciBuZXdQYXRoPXBhdGhBcnIuY29uY2F0KFtpbmRdKVxyXG4gICAgICAgICAgICBpZighQXJyYXkuaXNBcnJheShqc29uSW5mb1tpbmRdKSAmJiB0eXBlb2YoanNvbkluZm9baW5kXSk9PT1cIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZVRlbXBsYXRlUm9vdFtpbmRdPXt9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldFByb3BlcnR5VmFsdWVUZW1wbGF0ZShqc29uSW5mb1tpbmRdLG5ld1BhdGgsdmFsdWVUZW1wbGF0ZVJvb3RbaW5kXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb252ZXJ0VG9BY3R1YWxTY3JpcHQoc2NyaXB0Q29udGVudCxmb3JtdWxhVHdpbklEKXtcclxuICAgICAgICAvL2NoYW5nZSBhbGwgdGhlIHR3aW4gbmFtZSB0byB0d2luIElEXHJcbiAgICAgICAgdmFyIHBhdHQgPSAvKD88PV90d2luVmFsXFxbXFxcIikuKj8oPz1cXFwiXFxdKS9nO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBzY3JpcHRDb250ZW50LnJlcGxhY2UocGF0dCwoYVR3aW5OYW1lKT0+e1xyXG4gICAgICAgICAgICB2YXIgYVR3aW5JRD1nbG9iYWxDYWNoZS50d2luRGlzcGxheU5hbWVNYXBUb0lEW2FUd2luTmFtZV1cclxuICAgICAgICAgICAgcmV0dXJuIGFUd2luSURcclxuICAgICAgICB9ICk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0VHdpblByb3BlcnR5T3B0aW9uc0Fycihqc29uSW5mbyxwYXRoQXJyLG9wdGlvbnNBcnIpe1xyXG4gICAgICAgIGZvcih2YXIgaW5kIGluIGpzb25JbmZvKXtcclxuICAgICAgICAgICAgdmFyIG5ld1BhdGg9cGF0aEFyci5jb25jYXQoW2luZF0pXHJcbiAgICAgICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGpzb25JbmZvW2luZF0pICYmIHR5cGVvZihqc29uSW5mb1tpbmRdKT09PVwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHdpblByb3BlcnR5T3B0aW9uc0Fycihqc29uSW5mb1tpbmRdLG5ld1BhdGgsb3B0aW9uc0FycilcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uc0Fyci5wdXNoKCdbXCInK25ld1BhdGguam9pbignXCJdW1wiJykrJ1wiXScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNyZWF0ZVF1aWNrQnRuRm9yVHdpbih0d2luTmFtZSxjb2xvckNvZGUscGFyZW50RE9NLHRleHRBcmVhRG9tLHNlbGZNb2RlbElEKSB7XHJcbiAgICAgICAgdmFyIGFTZWxlY3RNZW51PW5ldyBzaW1wbGVTZWxlY3RNZW51KHR3aW5OYW1lLHtcIm9wdGlvbkxpc3RIZWlnaHRcIjoyMDAsXCJidXR0b25DU1NcIjp7XCJiYWNrZ3JvdW5kLWNvbG9yXCI6Y29sb3JDb2RlLFwicGFkZGluZ1wiOlwiMnB4IDVweFwiLFwibWFyZ2luLXJpZ2h0XCI6XCIxcHhcIn19KVxyXG5cclxuICAgICAgICBpZih0d2luTmFtZSE9XCJTZWxmXCIpe1xyXG4gICAgICAgICAgICB2YXIgYURCVHdpbj1nbG9iYWxDYWNoZS5nZXRTaW5nbGVEQlR3aW5CeU5hbWUodHdpbk5hbWUpXHJcbiAgICAgICAgICAgIHZhciBtb2RlbElEPWFEQlR3aW5bXCJtb2RlbElEXCJdXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIG1vZGVsSUQ9c2VsZk1vZGVsSURcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXM9bW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdLmVkaXRhYmxlUHJvcGVydGllc1xyXG4gICAgICAgIHZhciBvcHRpb25zQXJyPVtdXHJcbiAgICAgICAgdmFyIHBhdGhBcnI9W11cclxuICAgICAgICB0aGlzLmdldFR3aW5Qcm9wZXJ0eU9wdGlvbnNBcnIocHJvcGVydGllcyxwYXRoQXJyLG9wdGlvbnNBcnIpXHJcbiAgICAgICAgb3B0aW9uc0Fyci5mb3JFYWNoKChvbmVPcHRpb24pPT57XHJcbiAgICAgICAgICAgIGFTZWxlY3RNZW51LmFkZE9wdGlvbihvbmVPcHRpb24pXHJcbiAgICAgICAgfSlcclxuICAgICAgICBwYXJlbnRET00uYXBwZW5kKGFTZWxlY3RNZW51LkRPTSkgXHJcbiAgICAgICAgYVNlbGVjdE1lbnUuY2FsbEJhY2tfY2xpY2tPcHRpb249KG9wdGlvblRleHQsb3B0aW9uVmFsdWUscmVhbE1vdXNlQ2xpY2spPT57XHJcbiAgICAgICAgICAgIGlmKHR3aW5OYW1lPT1cIlNlbGZcIikgdmFyIHN0cj0nX3NlbGYnK29wdGlvblRleHRcclxuICAgICAgICAgICAgZWxzZSBzdHI9J190d2luVmFsW1wiJyt0d2luTmFtZSsnXCJdJytvcHRpb25UZXh0XHJcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0VG9UZXh0QXJlYShzdHIsdGV4dEFyZWFEb20pXHJcbiAgICAgICAgICAgIHRleHRBcmVhRG9tLmhpZ2hsaWdodFdpdGhpblRleHRhcmVhKCd1cGRhdGUnKTtcclxuICAgICAgICAgICAgdGV4dEFyZWFEb20uZm9jdXMoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRUb1RleHRBcmVhKHN0cix0ZXh0QXJlYURvbSl7XHJcbiAgICAgICAgdGV4dEFyZWFEb20uZm9jdXMoKTtcclxuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0ZXh0QXJlYURvbVswXS5zZWxlY3Rpb25TdGFydDtcclxuICAgICAgICB2YXIgZW5kUG9zID0gdGV4dEFyZWFEb21bMF0uc2VsZWN0aW9uRW5kO1xyXG4gICAgICAgIC8vdmFyIG5ld0NvbnRlbnQ9dGV4dEFyZWFEb20udmFsKClcclxuICAgICAgICAvL25ld0NvbnRlbnQ9bmV3Q29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRQb3MpKyBzdHIgKyBuZXdDb250ZW50LnN1YnN0cmluZyhlbmRQb3MsIG5ld0NvbnRlbnQubGVuZ3RoKTtcclxuICAgICAgICAvL3RleHRBcmVhRG9tLnZhbChuZXdDb250ZW50KVxyXG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRUZXh0JywgZmFsc2UsIHN0cik7IC8vdGhpcyB3YXkgd2lsbCBhbGxvdyB1bmRvIHN0aWxsIHdvcmtzXHJcbiAgICAgICAgdGV4dEFyZWFEb21bMF0uc2VsZWN0aW9uU3RhcnQ9c3RhcnRQb3Mrc3RyLmxlbmd0aDtcclxuICAgICAgICB0ZXh0QXJlYURvbVswXS5zZWxlY3Rpb25FbmQ9c3RhcnRQb3Mrc3RyLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3TXVsdGlwbGVPYmooKSB7XHJcbiAgICAgICAgdmFyIG51bU9mRWRnZSA9IDA7XHJcbiAgICAgICAgdmFyIG51bU9mTm9kZSA9IDA7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzO1xyXG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIGFyci5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudFsnJHNvdXJjZUlkJ10pIG51bU9mRWRnZSsrXHJcbiAgICAgICAgICAgIGVsc2UgbnVtT2ZOb2RlKytcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgdGV4dERpdiA9ICQoXCI8bGFiZWwgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDoxMHB4O21hcmdpbi1sZWZ0OjE2cHgnPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgdGV4dERpdi50ZXh0KG51bU9mTm9kZSArIFwiIG5vZGVcIiArICgobnVtT2ZOb2RlIDw9IDEpID8gXCJcIiA6IFwic1wiKSArIFwiLCBcIiArIG51bU9mRWRnZSArIFwiIHJlbGF0aW9uc2hpcFwiICsgKChudW1PZkVkZ2UgPD0gMSkgPyBcIlwiIDogXCJzXCIpKVxyXG4gICAgICAgIHRoaXMuaW5mb0NvbnRlbnREaXYuYXBwZW5kKHRleHREaXYpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IGluZm9QYW5lbCgpOyIsImNvbnN0IHNpbXBsZUNoYXJ0PSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlQ2hhcnRcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuZnVuY3Rpb24gaW5mb1BhbmVsX2xpdmVNb25pdG9yKHBhcmVudEluZm9QYW5lbCl7XHJcbiAgICB0aGlzLmxpdmVNb25pdG9yQ2hhcnRzPXt9XHJcbiAgICB0aGlzLmxpdmVDb250ZW50RGl2ID0gcGFyZW50SW5mb1BhbmVsLmxpdmVDb250ZW50RGl2XHJcbiAgICB0aGlzLnBhcmVudEluZm9QYW5lbD1wYXJlbnRJbmZvUGFuZWxcclxufVxyXG5cclxuaW5mb1BhbmVsX2xpdmVNb25pdG9yLnByb3RvdHlwZS5zaG93Qmxhbms9ZnVuY3Rpb24oKXtcclxuICAgIGlmKE9iamVjdC5rZXlzKHRoaXMubGl2ZU1vbml0b3JDaGFydHMpLmxlbmd0aD09MCl7XHJcbiAgICAgICAgdGhpcy5saXZlQ29udGVudERpdi5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cInczLXRleHQtZ3JheSB3My1wYWRkaW5nXCI+Tm8gdHdpbiBpcyBtb25pdG9yZWQuPC9kaXY+JykpXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5pbmZvUGFuZWxfbGl2ZU1vbml0b3IucHJvdG90eXBlLmFkZENoYXJ0PWZ1bmN0aW9uKHR3aW5JRCxwcm9wZXJ0eVBhdGgpe1xyXG4gICAgaWYoT2JqZWN0LmtleXModGhpcy5saXZlTW9uaXRvckNoYXJ0cykubGVuZ3RoPT0wKSB0aGlzLmxpdmVDb250ZW50RGl2LmVtcHR5KCkgLy9yZW1vdmUgdGhlIGxhYmVsIGluZGljYXRlIHRoZXJlIGlzIG5vIHR3aW4gXHJcbiAgICB2YXIgaWQ9dGhpcy5nZXRDaGFydElEKHR3aW5JRCxwcm9wZXJ0eVBhdGgpXHJcbiAgICBpZih0aGlzLmxpdmVNb25pdG9yQ2hhcnRzW2lkXSE9bnVsbCkgcmV0dXJuICAvL3RoZSBjaGFydCBpcyBhbHJlYWR5IHRoZXJlXHJcbiAgICB2YXIgY3VzdG9tRHJhd2luZz0oY2hhcnRET00pPT57XHJcbiAgICAgICAgdmFyIHR3aW5OYW1lPWdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbdHdpbklEXVxyXG4gICAgICAgIHZhciB0d2luTGFiZWw9JChcIjxsYWJlbCBjbGFzcz0ndzMtbGltZScgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtc2l6ZTo5cHg7cGFkZGluZzoycHggNHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtib3JkZXItcmFkaXVzOiAycHg7Jz5cIit0d2luTmFtZStcIjwvbGFiZWw+XCIpXHJcbiAgICAgICAgdmFyIHByb3BlcnR5TGFiZWw9JChcIjxsYWJlbCBjbGFzcz0ndzMtZ3JheScgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtc2l6ZTo5cHg7cGFkZGluZzoycHggNHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtib3JkZXItcmFkaXVzOiAycHg7Jz5cIitwcm9wZXJ0eVBhdGguam9pbihcIi5cIikrXCI8L2xhYmVsPlwiKVxyXG5cclxuICAgICAgICB2YXIgcmVtb3ZlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLXJpZ2h0IHczLWJ1dHRvbiB3My10ZXh0LXJlZCB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OjEzcHg7cGFkZGluZzoycHhcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoIGZhLWxnXCI+PC9pPjwvYnV0dG9uPicpXHJcblxyXG4gICAgICAgIHJlbW92ZUJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICAgICAgdGhpcy5saXZlTW9uaXRvckNoYXJ0c1tpZF0uZGVzdHJveSgpXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpdmVNb25pdG9yQ2hhcnRzW2lkXVxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudEluZm9QYW5lbC5icm9hZGNhc3RNZXNzYWdlKHtcIm1lc3NhZ2VcIjogXCJyZW1vdmVMaXZlTW9uaXRvclwiLFwidHdpbklEXCI6dHdpbklELFwicHJvcGVydHlQYXRoXCI6cHJvcGVydHlQYXRofSlcclxuICAgICAgICAgICAgdGhpcy5zaG93QmxhbmsoKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNoYXJ0RE9NLmFwcGVuZCh0d2luTGFiZWwscHJvcGVydHlMYWJlbCxyZW1vdmVCdXR0b24pIFxyXG4gICAgfVxyXG4gICAgdGhpcy5saXZlTW9uaXRvckNoYXJ0c1tpZF09bmV3IHNpbXBsZUNoYXJ0KHRoaXMubGl2ZUNvbnRlbnREaXYsNjAse3dpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMHB4XCJ9LGN1c3RvbURyYXdpbmcpXHJcbn1cclxuXHJcbmluZm9QYW5lbF9saXZlTW9uaXRvci5wcm90b3R5cGUuZHJhd05ld0RhdGE9ZnVuY3Rpb24odHdpbklELHByb3BlcnR5UGF0aCx2YWx1ZSx0aW1lKXtcclxuICAgIHZhciBpZD10aGlzLmdldENoYXJ0SUQodHdpbklELHByb3BlcnR5UGF0aClcclxuICAgIGlmKCF0aGlzLmxpdmVNb25pdG9yQ2hhcnRzW2lkXSkgcmV0dXJuO1xyXG4gICAgdmFyIHRzPXBhcnNlSW50KERhdGUucGFyc2UodGltZSkvMTAwMClcclxuICAgIHZhciB0aGVDaGFydD10aGlzLmxpdmVNb25pdG9yQ2hhcnRzW2lkXVxyXG4gICAgdGhlQ2hhcnQuYWRkRGF0YVZhbHVlKHRzLHZhbHVlKVxyXG59XHJcblxyXG5pbmZvUGFuZWxfbGl2ZU1vbml0b3IucHJvdG90eXBlLmdldENoYXJ0SUQ9ZnVuY3Rpb24odHdpbklELHByb3BlcnR5UGF0aCl7XHJcbiAgICByZXR1cm4gdHdpbklEK1wiLlwiK3Byb3BlcnR5UGF0aC5qb2luKFwiLlwiKVxyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5mb1BhbmVsX2xpdmVNb25pdG9yOyIsImNvbnN0IHN0YXJ0U2VsZWN0aW9uRGlhbG9nID0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3N0YXJ0U2VsZWN0aW9uRGlhbG9nXCIpXHJcbmNvbnN0IG1vZGVsTWFuYWdlckRpYWxvZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbE1hbmFnZXJEaWFsb2dcIilcclxuY29uc3QgZWRpdExheW91dERpYWxvZz0gcmVxdWlyZShcIi4vZWRpdExheW91dERpYWxvZ1wiKVxyXG5jb25zdCBzaW1wbGVTZWxlY3RNZW51PSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlU2VsZWN0TWVudVwiKVxyXG5jb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBtb2R1bGVTd2l0Y2hEaWFsb2c9cmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL21vZHVsZVN3aXRjaERpYWxvZ1wiKVxyXG5jb25zdCBwcm9qZWN0U2V0dGluZ0RpYWxvZz1yZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvcHJvamVjdFNldHRpbmdEaWFsb2dcIilcclxuXHJcbmZ1bmN0aW9uIG1haW5Ub29sYmFyKCkge1xyXG59XHJcblxyXG5tYWluVG9vbGJhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJChcIiNtYWluVG9vbEJhclwiKS5hZGRDbGFzcyhcInczLWJhciB3My1yZWRcIilcclxuICAgICQoXCIjbWFpblRvb2xCYXJcIikuY3NzKHtcInotaW5kZXhcIjoxMDAsXCJvdmVyZmxvd1wiOlwidmlzaWJsZVwifSlcclxuXHJcbiAgICB0aGlzLnN3aXRjaFByb2plY3RCdG49JCgnPGEgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b25cIiBocmVmPVwiI1wiPlByb2plY3Q8L2E+JylcclxuICAgIHRoaXMubW9kZWxJT0J0bj0kKCc8YSBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvblwiIGhyZWY9XCIjXCI+TW9kZWxzPC9hPicpXHJcbiAgICAvL3RoaXMuc2hvd0ZvcmdlVmlld0J0bj0kKCc8YSBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1ob3Zlci1ub25lIHczLXRleHQtbGlnaHQtZ3JleSB3My1ob3Zlci10ZXh0LWxpZ2h0LWdyZXlcIiBzdHlsZT1cIm9wYWNpdHk6LjM1XCIgaHJlZj1cIiNcIj5Gb3JnZVZpZXc8L2E+JylcclxuICAgIC8vdGhpcy5zaG93R0lTVmlld0J0bj0kKCc8YSBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvblwiIGhyZWY9XCIjXCI+R0lTVmlldzwvYT4nKVxyXG4gICAgdGhpcy5lZGl0TGF5b3V0QnRuPSQoJzxhIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uXCIgaHJlZj1cIiNcIj48aSBjbGFzcz1cImZhIGZhLWVkaXRcIj48L2k+PC9hPicpXHJcbiAgICB0aGlzLmZsb2F0SW5mb0J0bj0kKCc8YSBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1hbWJlclwiIHN0eWxlPVwiaGVpZ2h0OjEwMCU7Zm9udC1zaXplOjgwJVwiIGhyZWY9XCIjXCI+PHNwYW4gY2xhc3M9XCJmYS1zdGFjayBmYS14c1wiPjxpIGNsYXNzPVwiZmFzIGZhLWNpcmNsZSBmYS1zdGFjay0yeCBmYS1pbnZlcnNlXCI+PC9pPjxpIGNsYXNzPVwiZmFzIGZhLWluZm8gZmEtc3RhY2stMXggdzMtdGV4dC1hbWJlclwiPjwvaT48L3NwYW4+PC9hPicpXHJcblxyXG5cclxuICAgIHRoaXMudGVzdFNpZ25hbFJCdG49JCgnPGEgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtYW1iZXJcIiBocmVmPVwiI1wiPlRlc3QgU2lnbmFsUjwvYT4nKVxyXG4gICAgdGhpcy50ZXN0U2VuZFNpZ25hbFJCdG49JCgnPGEgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtYW1iZXJcIiBocmVmPVwiI1wiPnNlbmQgU2lnbmFsUiBtZXNzYWdlPC9hPicpXHJcblxyXG4gICAgdGhpcy5zZXR0aW5nQnRuPSQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmlnaHRcIj48aSBjbGFzcz1cImZhIGZhLWNvZyBmYS1sZ1wiPjwvaT48L2J1dHRvbj4nKVxyXG5cclxuICAgIHRoaXMudmlld1R5cGVTZWxlY3Rvcj1uZXcgc2ltcGxlU2VsZWN0TWVudShcIlwiKVxyXG4gICAgdGhpcy5zd2l0Y2hMYXlvdXRTZWxlY3Rvcj1uZXcgc2ltcGxlU2VsZWN0TWVudShcIkxheW91dFwiKVxyXG5cclxuICAgICQoXCIjbWFpblRvb2xCYXJcIikuZW1wdHkoKVxyXG4gICAgJChcIiNtYWluVG9vbEJhclwiKS5hcHBlbmQobW9kdWxlU3dpdGNoRGlhbG9nLm1vZHVsZXNTaWRlYmFyKVxyXG4gICAgJChcIiNtYWluVG9vbEJhclwiKS5hcHBlbmQobW9kdWxlU3dpdGNoRGlhbG9nLm1vZHVsZXNTd2l0Y2hCdXR0b24sIHRoaXMuc3dpdGNoUHJvamVjdEJ0bix0aGlzLm1vZGVsSU9CdG4sdGhpcy52aWV3VHlwZVNlbGVjdG9yLiAgRE9NLHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IuRE9NLHRoaXMuZWRpdExheW91dEJ0bix0aGlzLmZsb2F0SW5mb0J0blxyXG4gICAgICAgIC8vLHRoaXMudGVzdFNpZ25hbFJCdG4sdGhpcy50ZXN0U2VuZFNpZ25hbFJCdG5cclxuICAgICAgICAsdGhpcy5zZXR0aW5nQnRuXHJcbiAgICApXHJcblxyXG4gICAgdGhpcy5zd2l0Y2hQcm9qZWN0QnRuLm9uKFwiY2xpY2tcIiwoKT0+eyBzdGFydFNlbGVjdGlvbkRpYWxvZy5wb3B1cCgpIH0pXHJcbiAgICB0aGlzLm1vZGVsSU9CdG4ub24oXCJjbGlja1wiLCgpPT57IG1vZGVsTWFuYWdlckRpYWxvZy5wb3B1cCgpIH0pXHJcbiAgICB0aGlzLnNldHRpbmdCdG4ub24oXCJjbGlja1wiLCgpPT57IHByb2plY3RTZXR0aW5nRGlhbG9nLnBvcHVwKCkgfSlcclxuICAgIHRoaXMuZWRpdExheW91dEJ0bi5vbihcImNsaWNrXCIsKCk9PnsgZWRpdExheW91dERpYWxvZy5wb3B1cCgpIH0pXHJcbiAgICB0aGlzLmZsb2F0SW5mb0J0bi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICBpZihnbG9iYWxDYWNoZS5zaG93RmxvYXRJbmZvUGFuZWwpIGdsb2JhbENhY2hlLnNob3dGbG9hdEluZm9QYW5lbD1mYWxzZVxyXG4gICAgICAgIGVsc2UgZ2xvYmFsQ2FjaGUuc2hvd0Zsb2F0SW5mb1BhbmVsPXRydWVcclxuICAgICAgICBpZighZ2xvYmFsQ2FjaGUuc2hvd0Zsb2F0SW5mb1BhbmVsKXtcclxuICAgICAgICAgICAgdGhpcy5mbG9hdEluZm9CdG4ucmVtb3ZlQ2xhc3MoXCJ3My1hbWJlclwiKVxyXG4gICAgICAgICAgICB0aGlzLmZsb2F0SW5mb0J0bi5odG1sKCc8c3BhbiBjbGFzcz1cImZhLXN0YWNrIGZhLXhzXCI+PGkgY2xhc3M9XCJmYXMgZmEtYmFuIGZhLXN0YWNrLTJ4IGZhLWludmVyc2VcIj48L2k+PGkgY2xhc3M9XCJmYXMgZmEtaW5mbyBmYS1zdGFjay0xeCBmYS1pbnZlcnNlXCI+PC9pPjwvc3Bhbj4nKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLmZsb2F0SW5mb0J0bi5hZGRDbGFzcyhcInczLWFtYmVyXCIpXHJcbiAgICAgICAgICAgIHRoaXMuZmxvYXRJbmZvQnRuLmh0bWwoJzxzcGFuIGNsYXNzPVwiZmEtc3RhY2sgZmEteHNcIj48aSBjbGFzcz1cImZhcyBmYS1jaXJjbGUgZmEtc3RhY2stMnggZmEtaW52ZXJzZVwiPjwvaT48aSBjbGFzcz1cImZhcyBmYS1pbmZvIGZhLXN0YWNrLTF4IHczLXRleHQtYW1iZXJcIj48L2k+PC9zcGFuPicpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLnRlc3RTZW5kU2lnbmFsUkJ0bi5vbihcImNsaWNrXCIsYXN5bmMgKCk9PntcclxuICAgICAgICBjb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbiAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQXp1cmVGdW5jdGlvbnNTZXJ2aWNlKFwibWVzc2FnZXNcIixcIlBPU1RcIix7XHJcbiAgICAgICAgICAgIHJlY2lwaWVudDogXCI1ZWI4MWY1Zi1mZDllLTQ4MWQtOTk2Yi00ZDBiOTUzNmY0NzdcIixcclxuICAgICAgICAgICAgdGV4dDogXCJob3cgZG8geW91IGRvXCJcclxuICAgICAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgdGhpcy50ZXN0U2lnbmFsUkJ0bi5vbihcImNsaWNrXCIsYXN5bmMgKCk9PntcclxuICAgICAgICBjb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbiAgICAgICAgdmFyIHNpZ25hbFJJbmZvID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQXp1cmVGdW5jdGlvbnNTZXJ2aWNlKFwibmVnb3RpYXRlP25hbWU9ZmZcIixcIkdFVFwiKVxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgc2lnbmFsUi5IdWJDb25uZWN0aW9uQnVpbGRlcigpXHJcbiAgICAgICAgLndpdGhVcmwoc2lnbmFsUkluZm8udXJsLCB7YWNjZXNzVG9rZW5GYWN0b3J5OiAoKSA9PiBzaWduYWxSSW5mby5hY2Nlc3NUb2tlbn0pXHJcbiAgICAgICAgLy8uY29uZmlndXJlTG9nZ2luZyhzaWduYWxSLkxvZ0xldmVsLkluZm9ybWF0aW9uKVxyXG4gICAgICAgIC5jb25maWd1cmVMb2dnaW5nKHNpZ25hbFIuTG9nTGV2ZWwuV2FybmluZylcclxuICAgICAgICAuYnVpbGQoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhzaWduYWxSSW5mby5hY2Nlc3NUb2tlbilcclxuXHJcbiAgICAgICAgY29ubmVjdGlvbi5vbignbmV3TWVzc2FnZScsIChtZXNzYWdlKT0+e1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbm5lY3Rpb24ub25jbG9zZSgoKSA9PiBjb25zb2xlLmxvZygnZGlzY29ubmVjdGVkJykpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0aW5nLi4uJyk7XHJcbiAgICAgICAgY29ubmVjdGlvbi5zdGFydCgpXHJcbiAgICAgICAgICAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnY29ubmVjdGVkIScpKVxyXG4gICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLnZpZXdUeXBlU2VsZWN0b3IuYWRkT3B0aW9uKCdUb3BvbG9neScpXHJcbiAgICB0aGlzLnZpZXdUeXBlU2VsZWN0b3IuYWRkT3B0aW9uKCdHSVMnKVxyXG4gICAgdGhpcy52aWV3VHlwZVNlbGVjdG9yLmNhbGxCYWNrX2NsaWNrT3B0aW9uPShvcHRpb25UZXh0LG9wdGlvblZhbHVlLHJlYWxNb3VzZUNsaWNrKT0+e1xyXG4gICAgICAgIHRoaXMudmlld1R5cGVTZWxlY3Rvci5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgaWYocmVhbE1vdXNlQ2xpY2spe1xyXG4gICAgICAgICAgICBpZihnbG9iYWxDYWNoZS5jdXJyZW50Vmlld1R5cGUgPT0gb3B0aW9uVGV4dCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aWV3VHlwZUNoYW5nZVwiLFwidmlld1R5cGVcIjpvcHRpb25UZXh0fSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuY3VycmVudFZpZXdUeXBlPW9wdGlvblRleHRcclxuICAgIH1cclxuICAgIHRoaXMudmlld1R5cGVTZWxlY3Rvci50cmlnZ2VyT3B0aW9uVmFsdWUoXCJUb3BvbG9neVwiKVxyXG5cclxuICAgIHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IuY2FsbEJhY2tfY2xpY2tPcHRpb249KG9wdGlvblRleHQsb3B0aW9uVmFsdWUpPT57XHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuY3VycmVudExheW91dE5hbWU9b3B0aW9uVmFsdWVcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJsYXlvdXRDaGFuZ2VcIn0pXHJcbiAgICAgICAgaWYob3B0aW9uVmFsdWU9PVwiW05BXVwiKSB0aGlzLnN3aXRjaExheW91dFNlbGVjdG9yLmNoYW5nZU5hbWUoXCJMYXlvdXRcIixcIlwiKVxyXG4gICAgICAgIGVsc2UgdGhpcy5zd2l0Y2hMYXlvdXRTZWxlY3Rvci5jaGFuZ2VOYW1lKFwiTGF5b3V0OlwiLG9wdGlvblRleHQpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1haW5Ub29sYmFyLnByb3RvdHlwZS51cGRhdGVMYXlvdXRTZWxlY3RvciA9IGZ1bmN0aW9uIChjaG9vc2VMYXlvdXROYW1lKSB7XHJcbiAgICB2YXIgY3VyU2VsZWN0PWNob29zZUxheW91dE5hbWV8fHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IuY3VyU2VsZWN0VmFsXHJcbiAgICB0aGlzLnN3aXRjaExheW91dFNlbGVjdG9yLmNsZWFyT3B0aW9ucygpXHJcbiAgICB0aGlzLnN3aXRjaExheW91dFNlbGVjdG9yLmFkZE9wdGlvbignW05vIExheW91dCBTcGVjaWZpZWRdJywnW05BXScpXHJcblxyXG4gICAgZm9yICh2YXIgaW5kIGluIGdsb2JhbENhY2hlLmxheW91dEpTT04pIHtcclxuICAgICAgICB2YXIgb25lTGF5b3V0T2JqPWdsb2JhbENhY2hlLmxheW91dEpTT05baW5kXVxyXG4gICAgICAgIGlmKG9uZUxheW91dE9iai5vd25lcj09Z2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uaWQpIHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IuYWRkT3B0aW9uKGluZClcclxuICAgIH1cclxuXHJcbiAgICBpZihjdXJTZWxlY3QhPW51bGwpe1xyXG4gICAgICAgIGlmKHRoaXMuc3dpdGNoTGF5b3V0U2VsZWN0b3IuZmluZE9wdGlvbihjdXJTZWxlY3QpPT1udWxsKSB0aGlzLnN3aXRjaExheW91dFNlbGVjdG9yLmNoYW5nZU5hbWUoXCJMYXlvdXRcIixcIlwiKVxyXG4gICAgICAgIGVsc2UgdGhpcy5zd2l0Y2hMYXlvdXRTZWxlY3Rvci5jaGFuZ2VOYW1lKFwiTGF5b3V0OlwiLGN1clNlbGVjdClcclxuICAgIH1cclxufVxyXG5cclxubWFpblRvb2xiYXIucHJvdG90eXBlLnJ4TWVzc2FnZT1mdW5jdGlvbihtc2dQYXlsb2FkKXtcclxuICAgIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJsYXlvdXRzVXBkYXRlZFwiKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMYXlvdXRTZWxlY3Rvcihtc2dQYXlsb2FkLnNlbGVjdExheW91dClcclxuICAgIH1lbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJwb3B1cExheW91dEVkaXRpbmdcIil7XHJcbiAgICAgICAgZWRpdExheW91dERpYWxvZy5wb3B1cCgpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IG1haW5Ub29sYmFyKCk7IiwiY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuXHJcbmZ1bmN0aW9uIG1hcERPTShjb250YWluZXJET00pe1xyXG4gICAgdGhpcy5ET009JChcIjxkaXYgc3R5bGU9J2hlaWdodDoxMDAlO3dpZHRoOjEwMCUnPjwvZGl2PlwiKVxyXG4gICAgY29udGFpbmVyRE9NLmFwcGVuZCh0aGlzLkRPTSlcclxuICAgIHRoaXMuRE9NLmhpZGUoKVxyXG5cclxuICAgIHRoaXMuc3Vic2NyaXB0aW9uS2V5PVwiam1RYl9jampncEVYcTF3QjZlUmpzUUhvalVmSTJYeGdVcGJBaGlGcUJ0Y1wiXHJcbiAgICB0aGlzLmRhdGFTZXRJZD0gXCJlNmZjYmY4My1hYzMzLWNjYWItZjI3Ny0zODhhNDkyNTRlOGRcIlxyXG4gICAgdGhpcy50aWxlU2V0SWQ9XCI4YTliMDJlOS1kYjA0LTI3ODQtZGMzOC05YjMxYzUyMTYwZjJcIlxyXG5cclxuICAgIHRoaXMubWFwID0gbmV3IGF0bGFzLk1hcCh0aGlzLkRPTVswXSwge1xyXG4gICAgICAgIGNlbnRlcjogIFsxMDMuODM5NDI2NiwgMS4zMTQ0ODA1M10sXHJcbiAgICAgICAgem9vbTogMTUsXHJcbiAgICAgICAgc3R5bGU6ICdyb2FkX3NoYWRlZF9yZWxpZWYnLFxyXG4gICAgICAgIHZpZXc6ICdBdXRvJyxcclxuICAgICAgICBhdXRoT3B0aW9uczoge1xyXG4gICAgICAgICAgICBhdXRoVHlwZTogJ3N1YnNjcmlwdGlvbktleScsXHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbktleTogdGhpcy5zdWJzY3JpcHRpb25LZXlcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1hcC5ldmVudHMuYWRkKCdyZWFkeScsICgpPT4ge3RoaXMuaW5pdE1hcCgpfSlcclxufVxyXG5cclxubWFwRE9NLnByb3RvdHlwZS5pbml0TWFwPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLm1hcERhdGFTb3VyY2UgPSBuZXcgYXRsYXMuc291cmNlLkRhdGFTb3VyY2UoXCJ0d2luUG9seWdvblwiKTtcclxuXHJcbiAgICAvL0FkZCBhIG1hcCBzdHlsZSBzZWxlY3Rpb24gY29udHJvbC5cclxuICAgIHRoaXMubWFwLmNvbnRyb2xzLmFkZChuZXcgYXRsYXMuY29udHJvbC5TdHlsZUNvbnRyb2woeyBtYXBTdHlsZXM6IFwiYWxsXCIgfSksIHsgcG9zaXRpb246IFwidG9wLXJpZ2h0XCIgfSk7XHJcbiAgICAvL0NyZWF0ZSBhbiBpbmRvb3IgbWFwcyBtYW5hZ2VyLlxyXG4gICAgdGhpcy5pbmRvb3JNYW5hZ2VyID0gbmV3IGF0bGFzLmluZG9vci5JbmRvb3JNYW5hZ2VyKHRoaXMubWFwLCB7dGlsZXNldElkOiB0aGlzLnRpbGVTZXRJZH0pO1xyXG4gICAgdGhpcy5pbmRvb3JNYW5hZ2VyLnNldE9wdGlvbnMoe2xldmVsQ29udHJvbDogbmV3IGF0bGFzLmNvbnRyb2wuTGV2ZWxDb250cm9sKHsgcG9zaXRpb246ICd0b3AtcmlnaHQnIH0pIH0pO1xyXG4gICAgdGhpcy5pbmRvb3JNYW5hZ2VyLnNldER5bmFtaWNTdHlsaW5nKGZhbHNlKVxyXG5cclxuICAgIHRoaXMubWFwLmV2ZW50cy5hZGQoXCJjbGlja1wiLCAgKGUpPT4ge1xyXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMubWFwLmxheWVycy5nZXRSZW5kZXJlZFNoYXBlcyhlLnBvc2l0aW9uLCAndW5pdCcpO1xyXG4gICAgICAgIGlmKGZlYXR1cmVzLmxlbmd0aD09MCkgcmV0dXJuO1xyXG4gICAgICAgIHZhciByZXN1bHREQlR3aW49Z2xvYmFsQ2FjaGUuZ2V0U2luZ2xlREJUd2luQnlJbmRvb3JGZWF0dXJlSUQoZmVhdHVyZXNbMF0ucHJvcGVydGllcy5mZWF0dXJlSWQpXHJcbiAgICAgICAgaWYocmVzdWx0REJUd2luIT1udWxsKXtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRUd2lucyhbcmVzdWx0REJUd2luXSlcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwibWFwU2VsZWN0RmVhdHVyZVwiLFwiREJUd2luXCI6cmVzdWx0REJUd2lufSlcclxuICAgICAgICB9IFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1hcERPTS5wcm90b3R5cGUuY29tcGxldGVVUkw9ZnVuY3Rpb24oYXBpUGFydCl7XHJcbiAgICByZXR1cm4gJ2h0dHBzOi8vdXMuYXRsYXMubWljcm9zb2Z0LmNvbS8nK2FwaVBhcnQrJ2FwaS12ZXJzaW9uPTIuMCZzdWJzY3JpcHRpb24ta2V5PScrdGhpcy5zdWJzY3JpcHRpb25LZXlcclxufVxyXG5cclxubWFwRE9NLnByb3RvdHlwZS5yeE1lc3NhZ2U9ZnVuY3Rpb24obXNnUGF5bG9hZCl7XHJcbiAgICBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwidmlld1R5cGVDaGFuZ2VcIil7XHJcbiAgICAgICAgaWYobXNnUGF5bG9hZC52aWV3VHlwZT09XCJHSVNcIikgdGhpcy5zaG93U2VsZigpXHJcbiAgICAgICAgZWxzZSB0aGlzLmhpZGVTZWxmKClcclxuICAgIH1lbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJzaG93SW5mb1NlbGVjdGVkTm9kZXNcIil7XHJcbiAgICAgICAgaWYoZ2xvYmFsQ2FjaGUuY3VycmVudFZpZXdUeXBlIT1cIkdJU1wiKSByZXR1cm47XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkVHdpbnNBcnI9bXNnUGF5bG9hZC5pbmZvIC8vdGhlIGxhc3QgaXRlbSBpcyB0aGUgbGF0ZXN0IHNlbGVjdGVkIGl0ZW1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2VsZWN0ZWREQlR3aW5zPVtdXHJcbiAgICAgICAgc2VsZWN0ZWRUd2luc0Fyci5mb3JFYWNoKGFUd2luPT57XHJcbiAgICAgICAgICAgIHZhciB0d2luSUQ9YVR3aW5bJyRkdElkJ11cclxuICAgICAgICAgICAgaWYoIXR3aW5JRCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgdGhlREJUd2luPWdsb2JhbENhY2hlLkRCVHdpbnNbdHdpbklEXVxyXG4gICAgICAgICAgICBzZWxlY3RlZERCVHdpbnMucHVzaCh0aGVEQlR3aW4pXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodFR3aW5zKHNlbGVjdGVkREJUd2lucylcclxuICAgIH1cclxufVxyXG5cclxubWFwRE9NLnByb3RvdHlwZS5oaWdobGlnaHRUd2lucyA9IGZ1bmN0aW9uIChkYlR3aW5zKSB7XHJcbiAgICBpZihkYlR3aW5zLmxlbmd0aD09MCkgcmV0dXJuO1xyXG4gICAgdmFyIGxhdGVzdERCVHdpbj0gZGJUd2luc1tkYlR3aW5zLmxlbmd0aC0xXVxyXG4gICAgXHJcbiAgICAvL2hpZGUgYWxsIHR3aW5zIGhpZ2hsaWdodCBpbiBHSVNcclxuICAgIHRoaXMubWFwRGF0YVNvdXJjZS5jbGVhcigpXHJcbiAgICBpZighbGF0ZXN0REJUd2luLkdJUykgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAvL2lmIHRoZXJlIGlzIGEgZmFjaWxpdHkgY2hhbmdlLCB0aGVyZSBpcyBhbiBhbmltYXRpb24gdG8gcGFuIG1hcCwgb3RoZXJ3aXNlLCBkb25vdCBwYW4gbWFwXHJcbiAgICB2YXIgaW5mbz10aGlzLmluZG9vck1hbmFnZXIuZ2V0Q3VycmVudEZhY2lsaXR5KClcclxuICAgIHZhciBjdXJGYWNpbGl0eT1pbmZvWzBdXHJcbiAgICB2YXIgY3VyTGV2ZWxOdW1iZXI9IGluZm9bMV1cclxuICAgIHZhciBkZXN0RmFjaWxpdHk9bGF0ZXN0REJUd2luLkdJUy5pbmRvb3IuZmFjaWxpdHlJRFxyXG4gICAgaWYoY3VyRmFjaWxpdHkhPWRlc3RGYWNpbGl0eSl7XHJcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzPSBsYXRlc3REQlR3aW4uR0lTLmluZG9vci5jb29yZGluYXRlc1xyXG4gICAgICAgIHZhciBkZXN0TEw9Y29vcmRpbmF0ZXNbMF1bMF1cclxuICAgICAgICB0aGlzLmZseVRvKGRlc3RMTClcclxuICAgIH1cclxuICAgIC8vY2hvb3NlIHRoZSBmYWNpbGl0eSBhbmQgbGV2ZWwgbnVtYmVyXHJcbiAgICBpZihkZXN0RmFjaWxpdHkhPWN1ckZhY2lsaXR5IHx8IGN1ckxldmVsTnVtYmVyIT1sYXRlc3REQlR3aW4uR0lTLmluZG9vci5sZXZlbE9yZGluYWwpe1xyXG4gICAgICAgIHRoaXMuaW5kb29yTWFuYWdlci5zZXRGYWNpbGl0eShkZXN0RmFjaWxpdHksbGF0ZXN0REJUd2luLkdJUy5pbmRvb3IubGV2ZWxPcmRpbmFsIClcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy9oaWdobGlnaHQgYWxsIHNlbGVjdGVkIHR3aW5zIGluIEdJU1xyXG4gICAgZGJUd2lucy5mb3JFYWNoKG9uZURCVHdpbj0+e1xyXG4gICAgICAgIHRoaXMuZHJhd09uZVR3aW5JbmRvb3JQb2x5Z29uKG9uZURCVHdpbi5HSVMuaW5kb29yLmNvb3JkaW5hdGVzKVxyXG4gICAgfSlcclxufVxyXG5cclxubWFwRE9NLnByb3RvdHlwZS5kcmF3T25lVHdpbkluZG9vclBvbHlnb24gPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcclxuICAgIGlmKCF0aGlzLm1hcC5zb3VyY2VzLmdldEJ5SWQoXCJ0d2luUG9seWdvblwiKSl7XHJcbiAgICAgICAgdGhpcy5tYXAuc291cmNlcy5hZGQodGhpcy5tYXBEYXRhU291cmNlKTtcclxuICAgICAgICB0aGlzLm1hcC5sYXllcnMuYWRkKG5ldyBhdGxhcy5sYXllci5Qb2x5Z29uTGF5ZXIodGhpcy5tYXBEYXRhU291cmNlLCBudWxsLCB7XHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogXCJyZWRcIixcclxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuN1xyXG4gICAgICAgIH0pKVxyXG4gICAgfSBcclxuICAgIHRoaXMubWFwRGF0YVNvdXJjZS5hZGQobmV3IGF0bGFzLlNoYXBlKG5ldyBhdGxhcy5kYXRhLkZlYXR1cmUoXHJcbiAgICAgICAgbmV3IGF0bGFzLmRhdGEuUG9seWdvbihjb29yZGluYXRlcylcclxuICAgICkpKTtcclxufVxyXG5cclxubWFwRE9NLnByb3RvdHlwZS5mbHlUbyA9IGZ1bmN0aW9uIChkZXN0TEwpIHtcclxuICAgIHZhciBjdXJMb2M9dGhpcy5tYXAuZ2V0Q2FtZXJhKCkuY2VudGVyXHJcblxyXG4gICAgaWYoZGVzdExMWzBdPGN1ckxvY1swXSkgdmFyIHRhcmdldEJvdW5kcz1bZGVzdExMWzBdLGRlc3RMTFsxXSxjdXJMb2NbMF0sY3VyTG9jWzFdXVxyXG4gICAgZWxzZSB0YXJnZXRCb3VuZHM9W2N1ckxvY1swXSxjdXJMb2NbMV0sIGRlc3RMTFswXSxkZXN0TExbMV1dXHJcblxyXG4gICAgdGhpcy5tYXAuc2V0Q2FtZXJhKHtcImJvdW5kc1wiOnRhcmdldEJvdW5kcyxcclxuICAgICAgICBcInBhZGRpbmdcIjp7dG9wOiA4MCwgYm90dG9tOiA4MCwgbGVmdDogODAsIHJpZ2h0OiA4MH0sXHJcbiAgICB9KVxyXG4gICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwibWFwRmx5aW5nU3RhcnRcIn0pXHJcblxyXG4gICAgdmFyIG1hcmtlciA9IG5ldyBhdGxhcy5IdG1sTWFya2VyKHtjb2xvcjogJ0RvZGdlckJsdWUnLHRleHQ6ICcnLHBvc2l0aW9uOmN1ckxvY30pO1xyXG4gICAgdGhpcy5tYXAubWFya2Vycy5hZGQobWFya2VyKTtcclxuICAgIHZhciBwYXRoID0gW1xyXG4gICAgICAgIGN1ckxvYyxkZXN0TExcclxuICAgIF07XHJcbiAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgYXRsYXMuYW5pbWF0aW9ucy5tb3ZlQWxvbmdQYXRoKHBhdGgsIG1hcmtlciwgeyBkdXJhdGlvbjogMTAwMCwgY2FwdHVyZU1ldGFkYXRhOiB0cnVlLCBhdXRvUGxheTogdHJ1ZSB9KTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcIm1hcEZseWluZ0VuZFwifSlcclxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0Q2FtZXJhKHtcclxuICAgICAgICAgICAgICAgIFwiY2VudGVyXCI6IGRlc3RMTCxcclxuICAgICAgICAgICAgICAgIFwiem9vbVwiOiAxOSxcclxuICAgICAgICAgICAgICAgIFwiZHVyYXRpb25cIjogMjAwMCxcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZseVwiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9Pnt0aGlzLm1hcC5tYXJrZXJzLmNsZWFyKCl9LDM1MDApXHJcbiAgICAgICAgfSwxMDAwKVxyXG4gICAgICAgIFxyXG4gICAgfSwxMDAwKSBcclxufVxyXG5cclxubWFwRE9NLnByb3RvdHlwZS5nZXREaXN0YW5jZUZyb21MYXRMb25JbkttID0gZnVuY3Rpb24gKGxvbmxhdDEsIGxvbmxhdDIpIHtcclxuICAgIHZhciBsb24xPWxvbmxhdDFbMF1cclxuICAgIHZhciBsYXQxPWxvbmxhdDFbMV1cclxuICAgIHZhciBsb24yPWxvbmxhdDJbMF1cclxuICAgIHZhciBsYXQyPWxvbmxhdDJbMV1cclxuXHJcbiAgICB2YXIgUiA9IDYzNzE7IC8vIFJhZGl1cyBvZiB0aGUgZWFydGggaW4ga21cclxuICAgIHZhciBkTGF0ID0gdGhpcy5kZWcycmFkKGxhdDIgLSBsYXQxKTsgIC8vIGRlZzJyYWQgYmVsb3dcclxuICAgIHZhciBkTG9uID0gdGhpcy5kZWcycmFkKGxvbjIgLSBsb24xKTtcclxuICAgIHZhciBhID1cclxuICAgICAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xyXG4gICAgICAgIE1hdGguY29zKHRoaXMuZGVnMnJhZChsYXQxKSkgKiBNYXRoLmNvcyh0aGlzLmRlZzJyYWQobGF0MikpICpcclxuICAgICAgICBNYXRoLnNpbihkTG9uIC8gMikgKiBNYXRoLnNpbihkTG9uIC8gMilcclxuICAgICAgICA7XHJcbiAgICB2YXIgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XHJcbiAgICB2YXIgZCA9IFIgKiBjOyAvLyBEaXN0YW5jZSBpbiBrbVxyXG4gICAgcmV0dXJuIGQ7XHJcbn1cclxuXHJcbm1hcERPTS5wcm90b3R5cGUuZGVnMnJhZCA9IGZ1bmN0aW9uIChkZWcpIHtcclxuICAgIHJldHVybiBkZWcgKiAoTWF0aC5QSSAvIDE4MClcclxufVxyXG5cclxubWFwRE9NLnByb3RvdHlwZS5zaG93U2VsZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgdGhpcy5ET00uYW5pbWF0ZSh7aGVpZ2h0OiBcIjEwMCVcIn0sKCk9Pnt0aGlzLm1hcC5yZXNpemUoKX0pO1xyXG59XHJcblxyXG5tYXBET00ucHJvdG90eXBlLmhpZGVTZWxmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5ET00uYW5pbWF0ZSh7aGVpZ2h0OiBcIjAlXCJ9LCgpPT57dGhpcy5ET00uaGlkZSgpfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbWFwRE9NOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IG1vZGVsQW5hbHl6ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvbW9kZWxBbmFseXplclwiKTtcclxuY29uc3Qgc2ltcGxlU2VsZWN0TWVudSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVTZWxlY3RNZW51XCIpXHJcbmNvbnN0IHNpbXBsZUNvbmZpcm1EaWFsb2cgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlQ29uZmlybURpYWxvZ1wiKVxyXG5jb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbmNvbnN0IHRvcG9sb2d5RE9NX3N0eWxlTWFuYWdlcj1yZXF1aXJlKFwiLi90b3BvbG9neURPTV9zdHlsZU1hbmFnZXJcIilcclxuY29uc3QgdG9wb2xvZ3lET01fbWVudT1yZXF1aXJlKFwiLi90b3BvbG9neURPTV9tZW51XCIpXHJcbmNvbnN0IHRvcG9sb2d5RE9NX3Zpc3VhbD1yZXF1aXJlKFwiLi90b3BvbG9neURPTV92aXN1YWxcIilcclxuY29uc3QgdG9wb2xvZ3lET01fc2ltRGF0YVNvdXJjZT1yZXF1aXJlKFwiLi90b3BvbG9neURPTV9zaW1EYXRhU291cmNlXCIpXHJcblxyXG5mdW5jdGlvbiB0b3BvbG9neURPTShjb250YWluZXJET00pe1xyXG4gICAgdGhpcy5ET009JChcIjxkaXYgc3R5bGU9J2hlaWdodDoxMDAlO3dpZHRoOjEwMCUnPjwvZGl2PlwiKVxyXG4gICAgY29udGFpbmVyRE9NLmFwcGVuZCh0aGlzLkRPTSlcclxuICAgIHRoaXMuZGVmYXVsdE5vZGVTaXplPTMwXHJcbiAgICBcclxuICAgIHRoaXMubGFzdENhbGNJbnB1dFN0eWxlTm9kZXM9W11cclxuICAgIHRoaXMubGFzdENhbGNPdXRwdXRTdHlsZU5vZGVzPVtdXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7XHJcbiAgICBjeXRvc2NhcGUud2FybmluZ3MoZmFsc2UpICBcclxuICAgIHRoaXMuY29yZSA9IGN5dG9zY2FwZSh7XHJcbiAgICAgICAgY29udGFpbmVyOiAgdGhpcy5ET01bMF0sIC8vIGNvbnRhaW5lciB0byByZW5kZXIgaW5cclxuXHJcbiAgICAgICAgLy8gaW5pdGlhbCB2aWV3cG9ydCBzdGF0ZTpcclxuICAgICAgICB6b29tOiAxLFxyXG4gICAgICAgIHBhbjogeyB4OiAwLCB5OiAwIH0sXHJcblxyXG4gICAgICAgIC8vIGludGVyYWN0aW9uIG9wdGlvbnM6XHJcbiAgICAgICAgbWluWm9vbTogMC4xLFxyXG4gICAgICAgIG1heFpvb206IDEwLFxyXG4gICAgICAgIHpvb21pbmdFbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIHVzZXJab29taW5nRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBwYW5uaW5nRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgYm94U2VsZWN0aW9uRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBzZWxlY3Rpb25UeXBlOiAnc2luZ2xlJyxcclxuICAgICAgICB0b3VjaFRhcFRocmVzaG9sZDogOCxcclxuICAgICAgICBkZXNrdG9wVGFwVGhyZXNob2xkOiA0LFxyXG4gICAgICAgIGF1dG9sb2NrOiBmYWxzZSxcclxuICAgICAgICBhdXRvdW5ncmFiaWZ5OiBmYWxzZSxcclxuICAgICAgICBhdXRvdW5zZWxlY3RpZnk6IGZhbHNlLFxyXG5cclxuICAgICAgICAvLyByZW5kZXJpbmcgb3B0aW9uczpcclxuICAgICAgICBoZWFkbGVzczogZmFsc2UsXHJcbiAgICAgICAgc3R5bGVFbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIGhpZGVFZGdlc09uVmlld3BvcnQ6IGZhbHNlLFxyXG4gICAgICAgIHRleHR1cmVPblZpZXdwb3J0OiBmYWxzZSxcclxuICAgICAgICBtb3Rpb25CbHVyOiBmYWxzZSxcclxuICAgICAgICBtb3Rpb25CbHVyT3BhY2l0eTogMC4yLFxyXG4gICAgICAgIHdoZWVsU2Vuc2l0aXZpdHk6IDAuMyxcclxuICAgICAgICBwaXhlbFJhdGlvOiAnYXV0bycsXHJcblxyXG4gICAgICAgIGVsZW1lbnRzOiBbXSwgLy8gbGlzdCBvZiBncmFwaCBlbGVtZW50cyB0byBzdGFydCB3aXRoXHJcblxyXG4gICAgICAgIHN0eWxlOiBbXVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zdHlsZU1hbmFnZXI9bmV3IHRvcG9sb2d5RE9NX3N0eWxlTWFuYWdlcih0aGlzLmNvcmUsdGhpcy5kZWZhdWx0Tm9kZVNpemUpXHJcbiAgICBcclxuXHJcbiAgICAvL2N5dG9zY2FwZSBlZGdlIGVkaXRpbmcgcGx1Zy1pblxyXG4gICAgdGhpcy5jb3JlLmVkZ2VFZGl0aW5nKHtcclxuICAgICAgICB1bmRvYWJsZTogdHJ1ZSxcclxuICAgICAgICBiZW5kUmVtb3ZhbFNlbnNpdGl2aXR5OiAxNixcclxuICAgICAgICBlbmFibGVNdWx0aXBsZUFuY2hvclJlbW92YWxPcHRpb246IHRydWUsXHJcbiAgICAgICAgc3RpY2t5QW5jaG9yVG9sZXJlbmNlOiAyMCxcclxuICAgICAgICBhbmNob3JTaGFwZVNpemVGYWN0b3I6IDIsXHJcbiAgICAgICAgZW5hYmxlQW5jaG9yU2l6ZU5vdEltcGFjdEJ5Wm9vbTogdHJ1ZSxcclxuICAgICAgICBlbmFibGVSZW1vdmVBbmNob3JNaWRPZk5lYXJMaW5lOiBmYWxzZSxcclxuICAgICAgICBlbmFibGVDcmVhdGVBbmNob3JPbkRyYWc6IGZhbHNlLFxyXG4gICAgICAgIGVuYWJsZUFuY2hvcnNBYnNvbHV0ZVBvc2l0aW9uOnRydWUsXHJcbiAgICAgICAgZGlzYWJsZVJlY29ubmVjdDp0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNvcmUuYm94U2VsZWN0aW9uRW5hYmxlZCh0cnVlKVxyXG5cclxuXHJcbiAgICB0aGlzLmNvcmUub24oJ3RhcHNlbGVjdCcsICgpPT57dGhpcy5zZWxlY3RGdW5jdGlvbigpfSk7XHJcbiAgICB0aGlzLmNvcmUub24oJ3RhcHVuc2VsZWN0JywgKCk9Pnt0aGlzLnNlbGVjdEZ1bmN0aW9uKCl9KTtcclxuXHJcbiAgICB0aGlzLmNvcmUub24oJ2JveGVuZCcsKGUpPT57Ly9wdXQgaW5zaWRlIGJveGVuZCBldmVudCB0byB0cmlnZ2VyIG9ubHkgb25lIHRpbWUsIGFuZCByZXBsZWF0bHkgYWZ0ZXIgZWFjaCBib3ggc2VsZWN0XHJcbiAgICAgICAgdGhpcy5jb3JlLm9uZSgnYm94c2VsZWN0JywoKT0+e3RoaXMuc2VsZWN0RnVuY3Rpb24oKX0pXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMuY29yZS5vbignbW91c2VvdmVyJyxlPT57XHJcbiAgICAgICAgdGhpcy5tb3VzZU92ZXJGdW5jdGlvbihlKVxyXG4gICAgfSlcclxuICAgIHRoaXMuY29yZS5vbignbW91c2VvdXQnLGU9PntcclxuICAgICAgICB0aGlzLm1vdXNlT3V0RnVuY3Rpb24oZSlcclxuICAgIH0pXHJcbiAgICBcclxuICAgIHRoaXMuY29yZS5vbihcInpvb21cIiwoZSk9PntcclxuICAgICAgICB0aGlzLnN0eWxlTWFuYWdlci5hZGp1c3RNb2RlbHNCYXNlRGltZW5zaW9uKClcclxuICAgIH0pXHJcbiAgICB0aGlzLnN0eWxlTWFuYWdlci5hZGp1c3RNb2RlbHNCYXNlRGltZW5zaW9uKClcclxuICAgIFxyXG4gICAgdGhpcy5zZXRLZXlEb3duRnVuYygpXHJcbiAgICBcclxuICAgIHZhciB0YXBkcmFnSGFuZGxlcj0oZSkgPT4geyBcclxuICAgICAgICB0aGlzLnNtYXJ0UG9zaXRpb25Ob2RlKGUucG9zaXRpb24pIFxyXG4gICAgfVxyXG4gICAgdmFyIHNldE9uZVRpbWVHcmFiID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY29yZS5vbmNlKFwiZ3JhYlwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZihlLnRhcmdldC5pc05vZGUgJiYgZS50YXJnZXQuaXNOb2RlKCkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGU9ZS50YXJnZXRcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgdGhpcy5jb3JlLm9uKFwidGFwZHJhZ1wiLHRhcGRyYWdIYW5kbGVyIClcclxuICAgICAgICAgICAgc2V0T25lVGltZUZyZWUoKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICB2YXIgc2V0T25lVGltZUZyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5jb3JlLm9uY2UoXCJmcmVlXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlPW51bGxcclxuICAgICAgICAgICAgc2V0T25lVGltZUdyYWIoKVxyXG4gICAgICAgICAgICB0aGlzLmNvcmUucmVtb3ZlTGlzdGVuZXIoXCJ0YXBkcmFnXCIsdGFwZHJhZ0hhbmRsZXIpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIHNldE9uZVRpbWVHcmFiKCkgXHJcblxyXG4gICAgdGhpcy5tZW51TWFuYWdlcj1uZXcgdG9wb2xvZ3lET01fbWVudSh0aGlzKVxyXG4gICAgdGhpcy5jb3JlLm9uKCdncmFiJywgKGUpPT57XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiaGlkZUZsb2F0SW5mb1BhbmVsXCJ9KVxyXG4gICAgfSkgXHJcbiAgICB0aGlzLmNvcmUub24oJ2N4dHRhcCcsIChlKT0+e1xyXG4gICAgICAgIC8vaGlkZSB0aGUgZmxvYXQgaW5mbyB3aW5kb3dcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJoaWRlRmxvYXRJbmZvUGFuZWxcIn0pXHJcbiAgICAgICAgdGhpcy5jYW5jZWxUYXJnZXROb2RlTW9kZSgpXHJcbiAgICAgICAgdGhpcy5tZW51TWFuYWdlci5kZWNpZGVWaXNpYmxlQ29udGV4dE1lbnUoZS50YXJnZXQpXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMudmlzdWFsTWFuYWdlcj1uZXcgdG9wb2xvZ3lET01fdmlzdWFsKHRoaXMuY29yZSlcclxuICAgIHRoaXMuc2ltRGF0YVNvdXJjZU1hbmFnZXI9IG5ldyB0b3BvbG9neURPTV9zaW1EYXRhU291cmNlKHRoaXMpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5oaWRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7IFxyXG4gICAgY29sbGVjdGlvbi5yZW1vdmUoKVxyXG4gICAgdmFyIHR3aW5JREFyciA9IFtdXHJcbiAgICBjb2xsZWN0aW9uLmZvckVhY2gob25lTm9kZSA9PiB7IHR3aW5JREFyci5wdXNoKG9uZU5vZGUuZGF0YShcIm9yaWdpbmFsSW5mb1wiKVsnJGR0SWQnXSkgfSlcclxuICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcImhpZGVTZWxlY3RlZE5vZGVzXCIsIFwidHdpbklEQXJyXCI6IHR3aW5JREFyciB9KVxyXG59XHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUuYWRkU2ltdWxhdG9yU291cmNlID0gZnVuY3Rpb24gKHR3aW5OYW1lKSB7XHJcbiAgICB0aGlzLnNpbURhdGFTb3VyY2VNYW5hZ2VyLm5ld1NpbXVsYXRvclNvdXJjZSh0d2luTmFtZSlcclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLmVuYWJsZUxpdmVEYXRhU3RyZWFtID0gZnVuY3Rpb24gKHR3aW5OYW1lKSB7XHJcbiAgICB2YXIgdHdpbklEPWdsb2JhbENhY2hlLnR3aW5EaXNwbGF5TmFtZU1hcFRvSURbdHdpbk5hbWVdXHJcbiAgICB2YXIgZGJ0d2luPWdsb2JhbENhY2hlLkRCVHdpbnNbdHdpbklEXVxyXG4gICAgdmFyIG1vZGVsSUQ9ZGJ0d2luLm1vZGVsSURcclxuICAgIHZhciBwcm9wZXJ0eVBhdGhzPW1vZGVsQW5hbHl6ZXIuZmV0Y2hQcm9wZXJ0eVBhdGhzT2ZNb2RlbChtb2RlbElEKVxyXG4gICAgdmFyIGNoZWNrQm94ZXM9W11cclxuICAgIFxyXG4gICAgdmFyIGRpYWxvZz1uZXcgc2ltcGxlQ29uZmlybURpYWxvZygpXHJcbiAgICBkaWFsb2cuc2hvdyh7XCJtYXgtd2lkdGhcIjpcIjQ1MHB4XCIsXCJtaW4td2lkdGhcIjpcIjMwMHB4XCJ9LHtcclxuICAgICAgICBcInRpdGxlXCI6XCJDaG9vc2UgTGl2ZSBNb25pdG9yIFByb3BlcnRpZXNcIixcclxuICAgICAgICBcImN1c3RvbURyYXdpbmdcIjoocGFyZW50RE9NKT0+e1xyXG4gICAgICAgICAgICBwcm9wZXJ0eVBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0lvVENoZWNrID0gJCgnPGlucHV0IGNsYXNzPVwidzMtY2hlY2tcIiBzdHlsZT1cIndpZHRoOjIwcHg7bWFyZ2luLWxlZnQ6MTZweDttYXJnaW4tcmlnaHQ6NXB4XCIgdHlwZT1cImNoZWNrYm94XCI+JylcclxuICAgICAgICAgICAgICAgIHZhciBpc0lvVFRleHQgPSAkKCc8bGFiZWwgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6MTJweFwiPicrcGF0aC5qb2luKFwiLlwiKSsnPC9sYWJlbD4nKVxyXG4gICAgICAgICAgICAgICAgcGFyZW50RE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiZmxvYXQ6bGVmdFwiLz4nKS5hcHBlbmQoaXNJb1RDaGVjaywgaXNJb1RUZXh0KSlcclxuICAgICAgICAgICAgICAgIGNoZWNrQm94ZXMucHVzaChpc0lvVENoZWNrKVxyXG4gICAgICAgICAgICAgICAgaXNJb1RDaGVjay5kYXRhKFwicGF0aFwiLHBhdGgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJ1dHRvbnNcIjpbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkxpdmVcIixcclxuICAgICAgICAgICAgICAgIFwiY29sb3JDbGFzc1wiOlwidzMtbGltZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJjbGlja0Z1bmNcIjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wO2k8Y2hlY2tCb3hlcy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFDaGtCb3g9Y2hlY2tCb3hlc1tpXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighYUNoa0JveC5wcm9wKCdjaGVja2VkJykpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhUGF0aD1hQ2hrQm94LmRhdGEoXCJwYXRoXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7XCJtZXNzYWdlXCI6IFwiYWRkTGl2ZU1vbml0b3JcIixcInR3aW5JRFwiOnR3aW5JRCxcInByb3BlcnR5UGF0aFwiOmFQYXRofSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1widGV4dFwiOlwiQ2FuY2VsXCIsXCJjb2xvckNsYXNzXCI6XCJ3My1saWdodC1ncmF5XCIsXCJjbGlja0Z1bmNcIjooKT0+e2RpYWxvZy5jbG9zZSgpfX1cclxuICAgICAgICBdXHJcbiAgICB9KVxyXG59XHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUubG9hZE91dEJvdW5kPWFzeW5jIGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcclxuICAgIHZhciB0d2luSURBcnIgPSBbXVxyXG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIHZhciBvcmlnaW5hbEluZm8gPSBlbGVtZW50LmRhdGEoXCJvcmlnaW5hbEluZm9cIilcclxuICAgICAgICBpZiAob3JpZ2luYWxJbmZvWyckc291cmNlSWQnXSkgcmV0dXJuO1xyXG4gICAgICAgIHR3aW5JREFyci5wdXNoKG9yaWdpbmFsSW5mb1snJGR0SWQnXSlcclxuICAgIH0pO1xyXG5cclxuICAgIHdoaWxlICh0d2luSURBcnIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhciBzbWFsbEFyciA9IHR3aW5JREFyci5zcGxpY2UoMCwgMTAwKTtcclxuXHJcbiAgICAgICAgdmFyIGtub3duVGFyZ2V0VHdpbnMgPSB7fVxyXG4gICAgICAgIHNtYWxsQXJyLmZvckVhY2gob25lSUQgPT4ge1xyXG4gICAgICAgICAgICBrbm93blRhcmdldFR3aW5zW29uZUlEXSA9IDEgLy9pdHNlbGYgYWxzbyBpcyBrbm93blxyXG4gICAgICAgICAgICB2YXIgb3V0Qm91bmRSZWxhdGlvbiA9IGdsb2JhbENhY2hlLnN0b3JlZE91dGJvdW5kUmVsYXRpb25zaGlwc1tvbmVJRF1cclxuICAgICAgICAgICAgaWYgKG91dEJvdW5kUmVsYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIG91dEJvdW5kUmVsYXRpb24uZm9yRWFjaChvbmVSZWxhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldElEID0gb25lUmVsYXRpb25bXCIkdGFyZ2V0SWRcIl1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbdGFyZ2V0SURdICE9IG51bGwpIGtub3duVGFyZ2V0VHdpbnNbdGFyZ2V0SURdID0gMVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vcXVlcnlPdXRCb3VuZFwiLCBcIlBPU1RcIiwgeyBhcnI6IHNtYWxsQXJyLCBcImtub3duVGFyZ2V0c1wiOiBrbm93blRhcmdldFR3aW5zIH0pXHJcbiAgICAgICAgICAgIC8vbmV3IHR3aW4ncyByZWxhdGlvbnNoaXAgc2hvdWxkIGJlIHN0b3JlZCBhcyB3ZWxsXHJcbiAgICAgICAgICAgIGdsb2JhbENhY2hlLnN0b3JlVHdpblJlbGF0aW9uc2hpcHMoZGF0YS5uZXdUd2luUmVsYXRpb25zKVxyXG4gICAgICAgICAgICBkYXRhLmNoaWxkVHdpbnNBbmRSZWxhdGlvbnMuZm9yRWFjaChvbmVTZXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kIGluIG9uZVNldC5jaGlsZFR3aW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uZVR3aW4gPSBvbmVTZXQuY2hpbGRUd2luc1tpbmRdXHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVTaW5nbGVBRFRUd2luKG9uZVR3aW4pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRoaXMudmlzdWFsTWFuYWdlci5kcmF3VHdpbnNBbmRSZWxhdGlvbnMoZGF0YSlcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiZHJhd1R3aW5zQW5kUmVsYXRpb25zXCIsIGluZm86IGRhdGEgfSlcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUubG9hZEluQm91bmQ9YXN5bmMgZnVuY3Rpb24oY29sbGVjdGlvbikge1xyXG4gICAgdmFyIHR3aW5JREFyciA9IFtdXHJcbiAgICBjb2xsZWN0aW9uLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsSW5mbyA9IGVsZW1lbnQuZGF0YShcIm9yaWdpbmFsSW5mb1wiKVxyXG4gICAgICAgIGlmIChvcmlnaW5hbEluZm9bJyRzb3VyY2VJZCddKSByZXR1cm47XHJcbiAgICAgICAgdHdpbklEQXJyLnB1c2gob3JpZ2luYWxJbmZvWyckZHRJZCddKVxyXG4gICAgfSk7XHJcblxyXG4gICAgd2hpbGUgKHR3aW5JREFyci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIHNtYWxsQXJyID0gdHdpbklEQXJyLnNwbGljZSgwLCAxMDApO1xyXG4gICAgICAgIHZhciBrbm93blNvdXJjZVR3aW5zID0ge31cclxuICAgICAgICB2YXIgSUREaWN0ID0ge31cclxuICAgICAgICBzbWFsbEFyci5mb3JFYWNoKG9uZUlEID0+IHtcclxuICAgICAgICAgICAgSUREaWN0W29uZUlEXSA9IDFcclxuICAgICAgICAgICAga25vd25Tb3VyY2VUd2luc1tvbmVJRF0gPSAxIC8vaXRzZWxmIGFsc28gaXMga25vd25cclxuICAgICAgICB9KVxyXG4gICAgICAgIGZvciAodmFyIHR3aW5JRCBpbiBnbG9iYWxDYWNoZS5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHMpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aW9ucyA9IGdsb2JhbENhY2hlLnN0b3JlZE91dGJvdW5kUmVsYXRpb25zaGlwc1t0d2luSURdXHJcbiAgICAgICAgICAgIHJlbGF0aW9ucy5mb3JFYWNoKG9uZVJlbGF0aW9uID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJRCA9IG9uZVJlbGF0aW9uWyckdGFyZ2V0SWQnXVxyXG4gICAgICAgICAgICAgICAgdmFyIHNyY0lEID0gb25lUmVsYXRpb25bJyRzb3VyY2VJZCddXHJcbiAgICAgICAgICAgICAgICBpZiAoSUREaWN0W3RhcmdldElEXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbENhY2hlLnN0b3JlZFR3aW5zW3NyY0lEXSAhPSBudWxsKSBrbm93blNvdXJjZVR3aW5zW3NyY0lEXSA9IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vcXVlcnlJbkJvdW5kXCIsIFwiUE9TVFwiLCB7IGFycjogc21hbGxBcnIsIFwia25vd25Tb3VyY2VzXCI6IGtub3duU291cmNlVHdpbnMgfSlcclxuICAgICAgICAgICAgLy9uZXcgdHdpbidzIHJlbGF0aW9uc2hpcCBzaG91bGQgYmUgc3RvcmVkIGFzIHdlbGxcclxuICAgICAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVUd2luUmVsYXRpb25zaGlwcyhkYXRhLm5ld1R3aW5SZWxhdGlvbnMpXHJcbiAgICAgICAgICAgIGRhdGEuY2hpbGRUd2luc0FuZFJlbGF0aW9ucy5mb3JFYWNoKG9uZVNldCA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmQgaW4gb25lU2V0LmNoaWxkVHdpbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25lVHdpbiA9IG9uZVNldC5jaGlsZFR3aW5zW2luZF1cclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxDYWNoZS5zdG9yZVNpbmdsZUFEVFR3aW4ob25lVHdpbilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdGhpcy52aXN1YWxNYW5hZ2VyLmRyYXdUd2luc0FuZFJlbGF0aW9ucyhkYXRhKVxyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJkcmF3VHdpbnNBbmRSZWxhdGlvbnNcIiwgaW5mbzogZGF0YSB9KVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5kZWxldGVTaW1Ob2RlPWZ1bmN0aW9uKGVsZSl7XHJcbiAgICB0aGlzLnNpbURhdGFTb3VyY2VNYW5hZ2VyLmRlbGV0ZVNpbU5vZGUoZWxlKVxyXG59XHJcblxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLmRlbGV0ZUVsZW1lbnRzQXJyYXk9YXN5bmMgZnVuY3Rpb24oYXJyKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICAvL2NsZWFyIHNpbXVsYXRpb24gbm9kZSBmaXJzdFxyXG4gICAgYXJyLmZvckVhY2goZWxlPT57XHJcbiAgICAgICAgdmFyIGRiVHdpbj1nbG9iYWxDYWNoZS5nZXRTaW5nbGVEQlR3aW5CeU5hbWUoZWxlLmlkKCkpXHJcbiAgICAgICAgZm9yKHZhciBzaW1Ob2RlSUQgaW4gZGJUd2luLnNpbXVsYXRlKXtcclxuICAgICAgICAgICAgdmFyIHNpbU5vZGU9dGhpcy5jb3JlLm5vZGVzKFwiI1wiK3NpbU5vZGVJRClcclxuICAgICAgICAgICAgaWYoc2ltTm9kZSkgdGhpcy5zaW1EYXRhU291cmNlTWFuYWdlci5kZWxldGVTaW1Ob2RlKHNpbU5vZGUpIFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy90aGVuIHN0YXJ0IGRlbGV0aW5nIHRoZSByZWFsIHR3aW5zXHJcbiAgICB2YXIgcmVsYXRpb25zQXJyID0gW11cclxuICAgIHZhciB0d2luSURBcnIgPSBbXVxyXG4gICAgdmFyIHR3aW5JRHMgPSB7fVxyXG4gICAgYXJyLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsSW5mbyA9IGVsZW1lbnQuZGF0YShcIm9yaWdpbmFsSW5mb1wiKVxyXG4gICAgICAgIGlmKCFvcmlnaW5hbEluZm8pIHJldHVybjtcclxuICAgICAgICBpZiAob3JpZ2luYWxJbmZvWyckc291cmNlSWQnXSkgcmVsYXRpb25zQXJyLnB1c2gob3JpZ2luYWxJbmZvKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHdpbklEQXJyLnB1c2gob3JpZ2luYWxJbmZvWyckZHRJZCddKVxyXG4gICAgICAgICAgICB0d2luSURzW29yaWdpbmFsSW5mb1snJGR0SWQnXV0gPSAxXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBmb3IgKHZhciBpID0gcmVsYXRpb25zQXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IC8vY2xlYXIgdGhvc2UgcmVsYXRpb25zaGlwcyB0aGF0IGFyZSBnb2luZyB0byBiZSBkZWxldGVkIGFmdGVyIHR3aW5zIGRlbGV0aW5nXHJcbiAgICAgICAgdmFyIHNyY0lkID0gcmVsYXRpb25zQXJyW2ldWyckc291cmNlSWQnXVxyXG4gICAgICAgIHZhciB0YXJnZXRJZCA9IHJlbGF0aW9uc0FycltpXVsnJHRhcmdldElkJ11cclxuICAgICAgICBpZiAodHdpbklEc1tzcmNJZF0gIT0gbnVsbCB8fCB0d2luSURzW3RhcmdldElkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlbGF0aW9uc0Fyci5zcGxpY2UoaSwgMSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgY29uZmlybURpYWxvZ0RpdiA9IG5ldyBzaW1wbGVDb25maXJtRGlhbG9nKClcclxuICAgIHZhciBkaWFsb2dTdHIgPSBcIlwiXHJcbiAgICB2YXIgdHdpbk51bWJlciA9IHR3aW5JREFyci5sZW5ndGg7XHJcbiAgICB2YXIgcmVsYXRpb25zTnVtYmVyID0gcmVsYXRpb25zQXJyLmxlbmd0aDtcclxuICAgIGlmICh0d2luTnVtYmVyID4gMCkgZGlhbG9nU3RyID0gdHdpbk51bWJlciArIFwiIHR3aW5cIiArICgodHdpbk51bWJlciA+IDEpID8gXCJzXCIgOiBcIlwiKSArIFwiICh3aXRoIGNvbm5lY3RlZCByZWxhdGlvbnMpXCJcclxuICAgIGlmICh0d2luTnVtYmVyID4gMCAmJiByZWxhdGlvbnNOdW1iZXIgPiAwKSBkaWFsb2dTdHIgKz0gXCIgYW5kIGFkZGl0aW9uYWwgXCJcclxuICAgIGlmIChyZWxhdGlvbnNOdW1iZXIgPiAwKSBkaWFsb2dTdHIgKz0gcmVsYXRpb25zTnVtYmVyICsgXCIgcmVsYXRpb25cIiArICgocmVsYXRpb25zTnVtYmVyID4gMSkgPyBcInNcIiA6IFwiXCIpXHJcbiAgICBkaWFsb2dTdHIgKz0gXCIgd2lsbCBiZSBkZWxldGVkLiBQbGVhc2UgY29uZmlybVwiXHJcbiAgICBjb25maXJtRGlhbG9nRGl2LnNob3coXHJcbiAgICAgICAgeyB3aWR0aDogXCIzNTBweFwiIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aXRsZTogXCJDb25maXJtXCJcclxuICAgICAgICAgICAgLCBjb250ZW50OiBkaWFsb2dTdHJcclxuICAgICAgICAgICAgLCBidXR0b25zOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JDbGFzczogXCJ3My1yZWQgdzMtaG92ZXItcGlua1wiLCB0ZXh0OiBcIkNvbmZpcm1cIiwgXCJjbGlja0Z1bmNcIjogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uc0Fyci5sZW5ndGggPiAwKSBhd2FpdCB0aGlzLmRlbGV0ZVJlbGF0aW9ucyhyZWxhdGlvbnNBcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0d2luSURBcnIubGVuZ3RoID4gMCkgYXdhaXQgdGhpcy5kZWxldGVUd2lucyh0d2luSURBcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLWdyYXlcIiwgdGV4dDogXCJDYW5jZWxcIiwgXCJjbGlja0Z1bmNcIjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcbiAgICApXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5kZWxldGVUd2lucz1hc3luYyBmdW5jdGlvbih0d2luSURBcnIpIHtcclxuICAgIHZhciBpb1REZXZpY2VzID0gW11cclxuICAgIHR3aW5JREFyci5mb3JFYWNoKG9uZVR3aW5JRCA9PiB7XHJcbiAgICAgICAgdmFyIGRiVHdpbkluZm8gPSBnbG9iYWxDYWNoZS5EQlR3aW5zW29uZVR3aW5JRF1cclxuICAgICAgICBpZiAoZGJUd2luSW5mby5Jb1REZXZpY2VJRCAhPSBudWxsICYmIGRiVHdpbkluZm8uSW9URGV2aWNlSUQgIT0gXCJcIikge1xyXG4gICAgICAgICAgICBpb1REZXZpY2VzLnB1c2goZGJUd2luSW5mby5Jb1REZXZpY2VJRClcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgaWYgKGlvVERldmljZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRldmljZW1hbmFnZW1lbnQvdW5yZWdpc3RlcklvVERldmljZXNcIiwgXCJQT1NUXCIsIHsgYXJyOiBpb1REZXZpY2VzIH0pXHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKHR3aW5JREFyci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIHNtYWxsQXJyID0gdHdpbklEQXJyLnNwbGljZSgwLCAxMDApO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vZGVsZXRlVHdpbnNcIiwgXCJQT1NUXCIsIHsgYXJyOiBzbWFsbEFyciB9LCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKG9uZUlEKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbb25lSURdXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsQ2FjaGUuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW29uZUlEXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHRoZU1lc3NhZ2U9eyBcIm1lc3NhZ2VcIjogXCJ0d2luc0RlbGV0ZWRcIiwgdHdpbklEQXJyOiByZXN1bHQgfVxyXG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCh0d2luSUQ9PntcclxuICAgICAgICAgICAgICAgIHZhciB0d2luRGlzcGxheU5hbWU9Z2xvYmFsQ2FjaGUudHdpbklETWFwVG9EaXNwbGF5TmFtZVt0d2luSURdXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvcmUuJCgnW2lkID0gXCInK3R3aW5EaXNwbGF5TmFtZSsnXCJdJykucmVtb3ZlKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHRoZU1lc3NhZ2UpXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLmRlbGV0ZVJlbGF0aW9ucz1hc3luYyBmdW5jdGlvbihyZWxhdGlvbnNBcnIpIHtcclxuICAgIHZhciBhcnIgPSBbXVxyXG4gICAgcmVsYXRpb25zQXJyLmZvckVhY2gob25lUmVsYXRpb24gPT4ge1xyXG4gICAgICAgIGFyci5wdXNoKHsgc3JjSUQ6IG9uZVJlbGF0aW9uWyckc291cmNlSWQnXSwgcmVsSUQ6IG9uZVJlbGF0aW9uWyckcmVsYXRpb25zaGlwSWQnXSB9KVxyXG4gICAgfSlcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9kZWxldGVSZWxhdGlvbnNcIiwgXCJQT1NUXCIsIHsgXCJyZWxhdGlvbnNcIjogYXJyIH0pXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVUd2luUmVsYXRpb25zaGlwc19yZW1vdmUoZGF0YSlcclxuICAgICAgICB0aGlzLnJ4TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInJlbGF0aW9uc0RlbGV0ZWRcIiwgXCJyZWxhdGlvbnNcIjogZGF0YSB9KVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgIH1cclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLnNtYXJ0UG9zaXRpb25Ob2RlID0gZnVuY3Rpb24gKG1vdXNlUG9zaXRpb24pIHtcclxuICAgIGlmKHRoaXMuY29yZS5ub2RlcygnOnNlbGVjdGVkJykubGVuZ3RoPjEpIHJldHVyblxyXG4gICAgdmFyIHpvb21MZXZlbD10aGlzLmNvcmUuem9vbSgpXHJcbiAgICBpZighdGhpcy5kcmFnZ2luZ05vZGUpIHJldHVyblxyXG4gICAgLy9jb25zaWRlciBsb2NrIG1vdXNlIG1vdmUgcG9zaXRpb24gZm9yIHRoZXNlIG5vZGVzOlxyXG4gICAgLy8gLSBpdHMgY29ubmVjdGZyb20gbm9kZXMgYW5kIHRoZWlyIGNvbm5lY3R0byBub2Rlc1xyXG4gICAgLy8gLSBpdHMgY29ubmVjdHRvIG5vZGVzIGFuZCB0aGVpciBjb25uZWN0ZnJvbSBub2Rlc1xyXG4gICAgdmFyIGluY29tZXJzPXRoaXMuZHJhZ2dpbmdOb2RlLmluY29tZXJzKClcclxuICAgIHZhciBvdXRlcj10aGlzLmRyYWdnaW5nTm9kZS5vdXRnb2VycygpXHJcblxyXG4gICAgLy9hbHNvIGZpbmQgdGhlIG5lYXJieSBub2RlIHdpdGhpbiBjZXJ0YWluIHggeSBvZmZzZXQgYXJlYVxyXG4gICAgdmFyIHJwb3M9dGhpcy5kcmFnZ2luZ05vZGUucmVuZGVyZWRQb3NpdGlvbigpXHJcbiAgICB2YXIgbmVhcmJ5Tm9kZXM9dGhpcy5jb3JlLmNvbGxlY3Rpb24oKVxyXG4gICAgdmFyIHRocmVzaG9sZD0xNTBcclxuICAgIHRoaXMuY29yZS5ub2RlcygpLmZvckVhY2goZWxlPT57XHJcbiAgICAgICAgdmFyIGVsZVJQb3M9ZWxlLnJlbmRlcmVkUG9zaXRpb24oKVxyXG4gICAgICAgIGlmKE1hdGguYWJzKGVsZVJQb3MueC1ycG9zLngpPHRocmVzaG9sZCAmJiBNYXRoLmFicyhlbGVSUG9zLnktcnBvcy55KTx0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgbmVhcmJ5Tm9kZXMubWVyZ2UoZWxlKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICBcclxuICAgIHZhciBtb25pdG9yU2V0PWluY29tZXJzLnVuaW9uKG91dGVyKS51bmlvbihuZWFyYnlOb2RlcykuZmlsdGVyKCdub2RlJykudW5tZXJnZSh0aGlzLmRyYWdnaW5nTm9kZSlcclxuXHJcbiAgICB2YXIgcmV0dXJuRXhwZWN0ZWRQb3M9KGRpZmZBcnIscG9zQXJyKT0+e1xyXG4gICAgICAgIHZhciBtaW5EaXN0YW5jZT1NYXRoLm1pbiguLi5kaWZmQXJyKVxyXG4gICAgICAgIGlmKG1pbkRpc3RhbmNlKnpvb21MZXZlbCA8IDEwKSAgcmV0dXJuIHBvc0FycltkaWZmQXJyLmluZGV4T2YobWluRGlzdGFuY2UpXVxyXG4gICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhEaWZmPVtdXHJcbiAgICB2YXIgeFBvcz1bXVxyXG4gICAgdmFyIHlEaWZmPVtdXHJcbiAgICB2YXIgeVBvcz1bXVxyXG4gICAgbW9uaXRvclNldC5mb3JFYWNoKChlbGUpPT57XHJcbiAgICAgICAgeERpZmYucHVzaChNYXRoLmFicyhlbGUucG9zaXRpb24oKS54LW1vdXNlUG9zaXRpb24ueCkpXHJcbiAgICAgICAgeFBvcy5wdXNoKGVsZS5wb3NpdGlvbigpLngpXHJcbiAgICAgICAgeURpZmYucHVzaChNYXRoLmFicyhlbGUucG9zaXRpb24oKS55LW1vdXNlUG9zaXRpb24ueSkpXHJcbiAgICAgICAgeVBvcy5wdXNoKGVsZS5wb3NpdGlvbigpLnkpXHJcbiAgICB9KVxyXG4gICAgdmFyIHByZWZYPXJldHVybkV4cGVjdGVkUG9zKHhEaWZmLHhQb3MpXHJcbiAgICB2YXIgcHJlZlk9cmV0dXJuRXhwZWN0ZWRQb3MoeURpZmYseVBvcylcclxuICAgIGlmKHByZWZYIT1udWxsKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUucG9zaXRpb24oJ3gnLCBwcmVmWCk7XHJcbiAgICB9XHJcbiAgICBpZihwcmVmWSE9bnVsbCkge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlLnBvc2l0aW9uKCd5JywgcHJlZlkpO1xyXG4gICAgfVxyXG4gICAgLy9jb25zb2xlLmxvZyhcIi0tLS1cIilcclxuICAgIC8vbW9uaXRvclNldC5mb3JFYWNoKChlbGUpPT57Y29uc29sZS5sb2coZWxlLmlkKCkpfSlcclxuICAgIC8vY29uc29sZS5sb2cobW9uaXRvclNldC5zaXplKCkpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5tb3VzZU92ZXJGdW5jdGlvbj0gZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmKCFlLnRhcmdldC5kYXRhKSByZXR1cm5cclxuICAgIFxyXG4gICAgdmFyIGluZm89ZS50YXJnZXQuZGF0YSgpLm9yaWdpbmFsSW5mb1xyXG5cclxuICAgIGlmKGluZm89PW51bGwpIHJldHVybjtcclxuXHJcbiAgICBpZih0aGlzLmxhc3RIb3ZlclRhcmdldCkgdGhpcy5sYXN0SG92ZXJUYXJnZXQucmVtb3ZlQ2xhc3MoXCJob3ZlclwiKVxyXG5cclxuICAgIHRoaXMubGFzdENhbGNJbnB1dFN0eWxlTm9kZXMuZm9yRWFjaChlbGU9PntlbGUucmVtb3ZlQ2xhc3MoXCJjYWxjSW5wdXRcIil9KVxyXG4gICAgdGhpcy5sYXN0Q2FsY0lucHV0U3R5bGVOb2Rlcy5sZW5ndGg9MFxyXG4gICAgdGhpcy5sYXN0Q2FsY091dHB1dFN0eWxlTm9kZXMuZm9yRWFjaChlbGU9PntlbGUucmVtb3ZlQ2xhc3MoXCJjYWxjT3V0cHV0XCIpfSlcclxuICAgIHRoaXMubGFzdENhbGNPdXRwdXRTdHlsZU5vZGVzLmxlbmd0aD0wXHJcbiAgICBcclxuXHJcbiAgICB0aGlzLmxhc3RIb3ZlclRhcmdldD1lLnRhcmdldFxyXG4gICAgZS50YXJnZXQuYWRkQ2xhc3MoXCJob3ZlclwiKVxyXG5cclxuICAgIC8vZGlnaXRhbCB0d2lucyBpbmZvXHJcbiAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJzaG93SW5mb0hvdmVyZWRFbGVcIiwgXCJpbmZvXCI6IFtpbmZvXSxcInNjcmVlblhZXCI6dGhpcy5jb252ZXJ0UG9zaXRpb24oZS5wb3NpdGlvbi54LGUucG9zaXRpb24ueSkgfSlcclxuXHJcbiAgICAvL2lmIHRoZXJlIGlzIGNhbGN1bGF0aW9uIHNjcmlwdCBpbiBob3ZlcmVkIG5vZGUsIGhpZ2hsaWdodCBpbnB1dCBub2RlcyBhbmQgdGhlIHByb3BlcnRpZXNcclxuICAgIGlmKGluZm9bXCIkZHRJZFwiXSl7XHJcbiAgICAgICAgdmFyIHR3aW5JRD1pbmZvW1wiJGR0SWRcIl1cclxuICAgICAgICB2YXIgZGJ0d2luPWdsb2JhbENhY2hlLkRCVHdpbnNbdHdpbklEXVxyXG4gICAgICAgIHZhciBpbnB1dEFyciA9IGRidHdpbltcImlucHV0c1wiXVxyXG4gICAgICAgIGlmKGlucHV0QXJyKSBpbnB1dEFyci5mb3JFYWNoKG9uZUlucHV0PT57dGhpcy52aXN1YWxpemVTaW5nbGVJbnB1dEluVHdpbkNhbGN1bGF0aW9uKG9uZUlucHV0LGUudGFyZ2V0KX0pXHJcblxyXG4gICAgICAgIHRoaXMuYW5hbHlzZVNpbmdsZU91dHB1dChlLnRhcmdldCxpbmZvW1wiJGR0SWRcIl0pXHJcbiAgICB9XHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5hbmFseXNlU2luZ2xlT3V0cHV0ID0gZnVuY3Rpb24gKHR3aW5Ub3BvTm9kZSx0d2luSUQpIHtcclxuICAgIC8vY2hlY2sgaWYgaXRzIG91dHB1dCBpcyBhbm90aGVyIG5vZGUncyBpbnB1dFxyXG4gICAgdmFyIGZ1cnRoZXJJbnB1dHNBcnI9W11cclxuICAgIGZvciAodmFyIGFUd2luSUQgaW4gZ2xvYmFsQ2FjaGUuREJUd2lucykge1xyXG4gICAgICAgIHZhciBjaGVja0RCVHdpbiA9IGdsb2JhbENhY2hlLkRCVHdpbnNbYVR3aW5JRF1cclxuICAgICAgICB2YXIgaW5wdXRBcnI9Y2hlY2tEQlR3aW5bXCJpbnB1dHNcIl1cclxuICAgICAgICBpZighaW5wdXRBcnIpIGNvbnRpbnVlO1xyXG4gICAgICAgIGZvcih2YXIgaT0wO2k8aW5wdXRBcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIHZhciBhRnVydGhlcklucHV0PWlucHV0QXJyW2ldXHJcbiAgICAgICAgICAgIGlmKGFGdXJ0aGVySW5wdXQudHdpbklEPT10d2luSUQpe1xyXG4gICAgICAgICAgICAgICAgZnVydGhlcklucHV0c0Fyci5wdXNoKHtcInBhdGhcIjphRnVydGhlcklucHV0LnBhdGgsXCJ0YXJnZXRUd2luTmFtZVwiOmNoZWNrREJUd2luLmRpc3BsYXlOYW1lfSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYoZnVydGhlcklucHV0c0FycikgZnVydGhlcklucHV0c0Fyci5mb3JFYWNoKG9uZUZ1cnRoZXJJbnB1dD0+e1xyXG4gICAgICAgIHRoaXMudmlzdWFsaXplU2luZ2xlSW5wdXRJblR3aW5DYWxjdWxhdGlvbihvbmVGdXJ0aGVySW5wdXQsdHdpblRvcG9Ob2RlKVxyXG4gICAgfSlcclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLnZpc3VhbGl6ZVNpbmdsZUlucHV0SW5Ud2luQ2FsY3VsYXRpb24gPSBmdW5jdGlvbiAob25lSW5wdXQsdHdpblRvcG9Ob2RlKSB7XHJcbiAgICB2YXIgdHdpbk5hbWUgPSBnbG9iYWxDYWNoZS50d2luSURNYXBUb0Rpc3BsYXlOYW1lW29uZUlucHV0LnR3aW5JRF1cclxuICAgIHZhciBlZGdlcz1udWxsO1xyXG4gICAgaWYob25lSW5wdXQudGFyZ2V0VHdpbk5hbWUpe1xyXG4gICAgICAgIHZhciB0YXJnZXRUd2luTm9kZSA9dGhpcy5jb3JlLm5vZGVzKGBbaWQ9XCIke29uZUlucHV0LnRhcmdldFR3aW5OYW1lfVwiXWApXHJcbiAgICAgICAgaWYgKHRhcmdldFR3aW5Ob2RlKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFR3aW5Ob2RlLmFkZENsYXNzKFwiY2FsY091dHB1dFwiKVxyXG4gICAgICAgICAgICB0aGlzLmxhc3RDYWxjT3V0cHV0U3R5bGVOb2Rlcy5wdXNoKHRhcmdldFR3aW5Ob2RlKVxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIGZpcnN0IHJlbGF0aW9uc2hpcCBsaW5rIGZyb20gdGhpcyBub2RlIHRvIGhvdmVyZWQgbm9kZVxyXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSB0d2luVG9wb05vZGUuZWRnZXNUbyh0YXJnZXRUd2luTm9kZSlcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBpbnB1dFR3aW5Ob2RlID10aGlzLmNvcmUubm9kZXMoYFtpZD1cIiR7dHdpbk5hbWV9XCJdYClcclxuICAgICAgICBpZiAoaW5wdXRUd2luTm9kZSkge1xyXG4gICAgICAgICAgICBpbnB1dFR3aW5Ob2RlLmFkZENsYXNzKFwiY2FsY0lucHV0XCIpXHJcbiAgICAgICAgICAgIHRoaXMubGFzdENhbGNJbnB1dFN0eWxlTm9kZXMucHVzaChpbnB1dFR3aW5Ob2RlKVxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIGZpcnN0IHJlbGF0aW9uc2hpcCBsaW5rIGZyb20gdGhpcyBub2RlIHRvIGhvdmVyZWQgbm9kZVxyXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSBpbnB1dFR3aW5Ob2RlLmVkZ2VzVG8odHdpblRvcG9Ob2RlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKGVkZ2VzICYmIGVkZ2VzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIGlmKG9uZUlucHV0LnRhcmdldFR3aW5OYW1lKSB7XHJcbiAgICAgICAgICAgIGVkZ2VzWzBdLmFkZENsYXNzKFwiY2FsY091dHB1dFwiKVxyXG4gICAgICAgICAgICB0aGlzLmxhc3RDYWxjT3V0cHV0U3R5bGVOb2Rlcy5wdXNoKGVkZ2VzWzBdKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBlZGdlc1swXS5hZGRDbGFzcyhcImNhbGNJbnB1dFwiKVxyXG4gICAgICAgICAgICB0aGlzLmxhc3RDYWxjSW5wdXRTdHlsZU5vZGVzLnB1c2goZWRnZXNbMF0pXHJcbiAgICAgICAgfSBcclxuICAgICAgICB2YXIgY3VycmVudFBQYXRoID0gZWRnZXNbMF0uZGF0YSgncHBhdGgnKSB8fCBcIlwiXHJcbiAgICAgICAgaWYgKGN1cnJlbnRQUGF0aCAhPSBcIlwiKSBjdXJyZW50UFBhdGggKz0gXCI7XCJcclxuICAgICAgICBjdXJyZW50UFBhdGggKz0gb25lSW5wdXQucGF0aC5qb2luKFwiL1wiKVxyXG4gICAgICAgIGVkZ2VzWzBdLmRhdGEoJ3BwYXRoJywgY3VycmVudFBQYXRoKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByYW5kT2Zmc2V0PSBwYXJzZUludChNYXRoLnJhbmRvbSgpKjQwKSsyMFxyXG4gICAgICAgIGVkZ2VzWzBdLmRhdGEoJ3BwYXRoT2Zmc2V0JywgcmFuZE9mZnNldCtcIiVcIilcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUuY29udmVydFBvc2l0aW9uPWZ1bmN0aW9uKHgseSl7XHJcbiAgICB2YXIgdnBFeHRlbnQ9dGhpcy5jb3JlLmV4dGVudCgpXHJcbiAgICB2YXIgc2NyZWVuVz10aGlzLkRPTS53aWR0aCgpXHJcbiAgICB2YXIgc2NyZWVuSD10aGlzLkRPTS5oZWlnaHQoKVxyXG4gICAgdmFyIHNjcmVlblggPSAoeC12cEV4dGVudC54MSkvKHZwRXh0ZW50LncpKnNjcmVlblcgKyB0aGlzLkRPTS5vZmZzZXQoKS5sZWZ0XHJcbiAgICB2YXIgc2NyZWVuWT0oeS12cEV4dGVudC55MSkvKHZwRXh0ZW50LmgpKnNjcmVlbkgrIHRoaXMuRE9NLm9mZnNldCgpLnRvcFxyXG4gICAgcmV0dXJuIHt4OnNjcmVlblgseTpzY3JlZW5ZfVxyXG59XHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUubW91c2VPdXRGdW5jdGlvbj0gZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmKCFnbG9iYWxDYWNoZS5zaG93RmxvYXRJbmZvUGFuZWwpeyAvL3NpbmNlIGZsb2F0aW5nIHdpbmRvdyBpcyB1c2VkIGZvciBtb3VzZSBob3ZlciBlbGVtZW50IGluZm8sIHNvIGluZm8gcGFuZWwgbmV2ZXIgY2hhZ25lIGJlZm9yZSwgdGhhdCBpcyB3aHkgdGhlcmUgaXMgbm8gbmVlZCB0byByZXN0b3JlIGJhY2sgdGhlIGluZm8gcGFuZWwgaW5mb3JtYXRpb24gYXQgbW91c2VvdXRcclxuICAgICAgICBpZihnbG9iYWxDYWNoZS5zaG93aW5nQ3JlYXRlVHdpbk1vZGVsSUQpe1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJzaG93SW5mb0dyb3VwTm9kZVwiLCBcImluZm9cIjoge1wiQGlkXCI6Z2xvYmFsQ2FjaGUuc2hvd2luZ0NyZWF0ZVR3aW5Nb2RlbElEfSB9KVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdEZ1bmN0aW9uKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcImhpZGVGbG9hdEluZm9QYW5lbFwifSlcclxuXHJcbiAgICBpZih0aGlzLmxhc3RIb3ZlclRhcmdldCl7XHJcbiAgICAgICAgdGhpcy5sYXN0SG92ZXJUYXJnZXQucmVtb3ZlQ2xhc3MoXCJob3ZlclwiKVxyXG4gICAgICAgIHRoaXMubGFzdEhvdmVyVGFyZ2V0PW51bGw7XHJcbiAgICB9IFxyXG4gICAgdGhpcy5sYXN0Q2FsY0lucHV0U3R5bGVOb2Rlcy5mb3JFYWNoKGVsZT0+e1xyXG4gICAgICAgIGVsZS5yZW1vdmVDbGFzcyhcImNhbGNJbnB1dFwiKVxyXG4gICAgICAgIGVsZS5kYXRhKCdwcGF0aCcsbnVsbClcclxuICAgIH0pXHJcbiAgICB0aGlzLmxhc3RDYWxjSW5wdXRTdHlsZU5vZGVzLmxlbmd0aD0wXHJcbiAgICB0aGlzLmxhc3RDYWxjT3V0cHV0U3R5bGVOb2Rlcy5mb3JFYWNoKGVsZT0+e1xyXG4gICAgICAgIGVsZS5yZW1vdmVDbGFzcyhcImNhbGNPdXRwdXRcIilcclxuICAgICAgICBlbGUuZGF0YSgncHBhdGgnLG51bGwpXHJcbiAgICB9KVxyXG4gICAgdGhpcy5sYXN0Q2FsY091dHB1dFN0eWxlTm9kZXMubGVuZ3RoPTBcclxuXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5zZWxlY3RGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcnIgPSB0aGlzLmNvcmUuJChcIjpzZWxlY3RlZFwiKVxyXG5cclxuICAgIHZhciByZSA9IFtdXHJcblxyXG4gICAgaWYoYXJyLmxlbmd0aD09MSl7XHJcbiAgICAgICAgdmFyIGVsZT1hcnJbMF1cclxuICAgICAgICBpZihlbGUuZGF0YSgpLm1vZGVsSUQ9PVwiX2ZpeGVkX3NpbXVsYXRpb25EYXRhU291cmNlXCIpe1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJzaG93SW5mb1NlbGVjdGVkTm9kZXNcIiwgaW5mbzogW2VsZS5kYXRhKCkub3JpZ2luYWxJbmZvXSB9KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFyci5mb3JFYWNoKChlbGUpID0+IHsgXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhlbGUucmVuZGVyZWRQb3NpdGlvbigpKVxyXG4gICAgICAgIC8vcmVtb3ZlIHRob3NlIHNwZWNpYWwgZWxlbWVudHNcclxuICAgICAgICBpZihlbGUuZGF0YSgpLm5vdFR3aW4pIHtcclxuICAgICAgICAgICAgZWxlLnVuc2VsZWN0KClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZS5wdXNoKGVsZS5kYXRhKCkub3JpZ2luYWxJbmZvKSBcclxuICAgIH0pXHJcbiAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJzaG93SW5mb1NlbGVjdGVkTm9kZXNcIiwgaW5mbzogcmUgfSlcclxuICAgIC8vZm9yIGRlYnVnZ2luZyBwdXJwb3NlXHJcbiAgICAvL2Fyci5mb3JFYWNoKChlbGUpPT57XHJcbiAgICAvLyAgY29uc29sZS5sb2coXCJcIilcclxuICAgIC8vfSlcclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5hcHBseVZpc3VhbERlZmluaXRpb249ZnVuY3Rpb24oKXtcclxuICAgIHZhciB2aXN1YWxKc29uPWdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFxyXG4gICAgaWYodmlzdWFsSnNvbj09bnVsbCkgcmV0dXJuO1xyXG4gICAgZm9yKHZhciBtb2RlbElEIGluIHZpc3VhbEpzb24pe1xyXG4gICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0uY29sb3IgfHx2aXN1YWxKc29uW21vZGVsSURdLnNlY29uZENvbG9yICApIHRoaXMuc3R5bGVNYW5hZ2VyLnVwZGF0ZU1vZGVsVHdpbkNvbG9yKG1vZGVsSUQsdmlzdWFsSnNvblttb2RlbElEXS5jb2xvcix2aXN1YWxKc29uW21vZGVsSURdLnNlY29uZENvbG9yKVxyXG4gICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0uc2hhcGUpIHRoaXMuc3R5bGVNYW5hZ2VyLnVwZGF0ZU1vZGVsVHdpblNoYXBlKG1vZGVsSUQsdmlzdWFsSnNvblttb2RlbElEXS5zaGFwZSlcclxuICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YSkgdGhpcy5zdHlsZU1hbmFnZXIudXBkYXRlTW9kZWxBdmFydGEobW9kZWxJRCx2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YSlcclxuICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdLmRpbWVuc2lvblJhdGlvKSB0aGlzLnN0eWxlTWFuYWdlci51cGRhdGVNb2RlbFR3aW5EaW1lbnNpb24obW9kZWxJRCx2aXN1YWxKc29uW21vZGVsSURdLmRpbWVuc2lvblJhdGlvKVxyXG4gICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0ubGFiZWxYIHx8IHZpc3VhbEpzb25bbW9kZWxJRF0ubGFiZWxZKXtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZU1hbmFnZXIudXBkYXRlTW9kZWxUd2luTGFiZWxPZmZzZXQobW9kZWxJRClcclxuICAgICAgICB9IFxyXG4gICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0ucmVscyl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgcmVsYXRpb25zaGlwTmFtZSBpbiB2aXN1YWxKc29uW21vZGVsSURdLnJlbHMpe1xyXG4gICAgICAgICAgICAgICAgaWYodmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpb25zaGlwTmFtZV0uY29sb3Ipe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYW5hZ2VyLnVwZGF0ZVJlbGF0aW9uc2hpcENvbG9yKG1vZGVsSUQscmVsYXRpb25zaGlwTmFtZSx2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGlvbnNoaXBOYW1lXS5jb2xvcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW9uc2hpcE5hbWVdLnNoYXBlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFuYWdlci51cGRhdGVSZWxhdGlvbnNoaXBTaGFwZShtb2RlbElELHJlbGF0aW9uc2hpcE5hbWUsdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpb25zaGlwTmFtZV0uc2hhcGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGlvbnNoaXBOYW1lXS5lZGdlV2lkdGgpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYW5hZ2VyLnVwZGF0ZVJlbGF0aW9uc2hpcFdpZHRoKG1vZGVsSUQscmVsYXRpb25zaGlwTmFtZSx2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGlvbnNoaXBOYW1lXS5lZGdlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5yeE1lc3NhZ2U9ZnVuY3Rpb24obXNnUGF5bG9hZCl7XHJcbiAgICBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwic3RhcnRTZWxlY3Rpb25fcmVwbGFjZVwiKXtcclxuICAgICAgICB0aGlzLmNvcmUubm9kZXMoKS5yZW1vdmUoKVxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cInJlcGxhY2VBbGxUd2luc1wiKSB7XHJcbiAgICAgICAgdGhpcy5jb3JlLm5vZGVzKCkucmVtb3ZlKClcclxuICAgICAgICB2YXIgZWxlcz0gdGhpcy52aXN1YWxNYW5hZ2VyLmRyYXdUd2lucyhtc2dQYXlsb2FkLmluZm8pXHJcbiAgICAgICAgdGhpcy52aXN1YWxNYW5hZ2VyLmFwcGx5Q3VycmVudExheW91dFdpdGhOb0FuaW10YWlvbigpXHJcbiAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwicHJvamVjdElzQ2hhbmdlZFwiKSB7XHJcbiAgICAgICAgdGhpcy5hcHBseVZpc3VhbERlZmluaXRpb24oKVxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImFwcGVuZEFsbFR3aW5zXCIpIHtcclxuICAgICAgICB2YXIgZWxlcz0gdGhpcy52aXN1YWxNYW5hZ2VyLmRyYXdUd2lucyhtc2dQYXlsb2FkLmluZm8sXCJhbmltYXRlXCIpXHJcbiAgICAgICAgdGhpcy52aXN1YWxNYW5hZ2VyLnJldmlld1N0b3JlZFJlbGF0aW9uc2hpcHNUb0RyYXcoKVxyXG4gICAgICAgIHRoaXMudmlzdWFsTWFuYWdlci5hcHBseUN1cnJlbnRMYXlvdXRXaXRoTm9BbmltdGFpb24oKVxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImRyYXdBbGxSZWxhdGlvbnNcIil7XHJcbiAgICAgICAgdmFyIGVkZ2VzPSB0aGlzLnZpc3VhbE1hbmFnZXIuZHJhd1JlbGF0aW9ucyhtc2dQYXlsb2FkLmluZm8pXHJcbiAgICAgICAgaWYoZWRnZXMhPW51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGxheW91dERldGFpbD1udWxsXHJcbiAgICAgICAgICAgIGlmKGdsb2JhbENhY2hlLmN1cnJlbnRMYXlvdXROYW1lIT1udWxsKSBsYXlvdXREZXRhaWwgPSBnbG9iYWxDYWNoZS5sYXlvdXRKU09OW2dsb2JhbENhY2hlLmN1cnJlbnRMYXlvdXROYW1lXS5kZXRhaWxcclxuICAgICAgICAgICAgaWYobGF5b3V0RGV0YWlsPT1udWxsKSAgdGhpcy52aXN1YWxNYW5hZ2VyLm5vUG9zaXRpb25fY29zZSgpXHJcbiAgICAgICAgICAgIGVsc2UgdGhpcy52aXN1YWxNYW5hZ2VyLmFwcGx5Q3VycmVudExheW91dFdpdGhOb0FuaW10YWlvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImFkZE5ld1R3aW5cIikge1xyXG4gICAgICAgIHRoaXMuY29yZS5ub2RlcygpLnVuc2VsZWN0KClcclxuICAgICAgICB0aGlzLmNvcmUuZWRnZXMoKS51bnNlbGVjdCgpXHJcbiAgICAgICAgdGhpcy52aXN1YWxNYW5hZ2VyLmRyYXdUd2lucyhbbXNnUGF5bG9hZC50d2luSW5mb10sXCJhbmltYXRpb25cIilcclxuICAgICAgICB2YXIgbm9kZUluZm89IG1zZ1BheWxvYWQudHdpbkluZm87XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lPSBnbG9iYWxDYWNoZS50d2luSURNYXBUb0Rpc3BsYXlOYW1lW25vZGVJbmZvW1wiJGR0SWRcIl1dXHJcbiAgICAgICAgdmFyIHRvcG9Ob2RlPSB0aGlzLmNvcmUubm9kZXMoYFtpZD1cIiR7bm9kZU5hbWV9XCJdYClcclxuICAgICAgICBpZih0b3BvTm9kZSl7XHJcbiAgICAgICAgICAgIHZhciB3PXRoaXMuY29yZS53aWR0aCgpXHJcbiAgICAgICAgICAgIHZhciBoPSB0aGlzLmNvcmUuaGVpZ2h0KClcclxuXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlUmVuZGVyUG9zWD0gdy8xMVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZVJlbmRlclBvc1k9aC8yKygoTWF0aC5yYW5kb20oKS0wLjUpKmgvNClcclxuICAgICAgICAgICAgdG9wb05vZGUucmVuZGVyZWRQb3NpdGlvbih7eDp0YXJnZXROb2RlUmVuZGVyUG9zWCx5OnRhcmdldE5vZGVSZW5kZXJQb3NZfSlcclxuICAgICAgICAgICAgdG9wb05vZGUuc2VsZWN0KClcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RGdW5jdGlvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImFkZE5ld1R3aW5zXCIpIHtcclxuICAgICAgICB0aGlzLnZpc3VhbE1hbmFnZXIuZHJhd1R3aW5zKG1zZ1BheWxvYWQudHdpbnNJbmZvLFwiYW5pbWF0aW9uXCIpXHJcbiAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwic2hvd0luZm9TZWxlY3RlZE5vZGVzXCIpeyAvL2Zyb20gc2VsZWN0aW5nIHR3aW5zIGluIHRoZSB0d2ludHJlZVxyXG4gICAgICAgIHRoaXMuY29yZS5ub2RlcygpLnVuc2VsZWN0KClcclxuICAgICAgICB0aGlzLmNvcmUuZWRnZXMoKS51bnNlbGVjdCgpXHJcbiAgICAgICAgdmFyIGFycj1tc2dQYXlsb2FkLmluZm87XHJcbiAgICAgICAgdmFyIG1vdXNlQ2xpY2tEZXRhaWw9bXNnUGF5bG9hZC5tb3VzZUNsaWNrRGV0YWlsO1xyXG4gICAgICAgIGFyci5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICB2YXIgYVR3aW49dGhpcy5jb3JlLm5vZGVzKGBbaWQ9XCIke2VsZW1lbnRbJ2Rpc3BsYXlOYW1lJ119XCJdYClcclxuICAgICAgICAgICAgYVR3aW4uc2VsZWN0KClcclxuICAgICAgICAgICAgaWYobW91c2VDbGlja0RldGFpbCE9MikgdGhpcy52aXN1YWxNYW5hZ2VyLmFuaW1hdGVBTm9kZShhVHdpbikgLy9pZ25vcmUgZG91YmxlIGNsaWNrIHNlY29uZCBjbGlja1xyXG4gICAgICAgIH0pO1xyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cIlBhblRvTm9kZVwiKXtcclxuICAgICAgICB2YXIgbm9kZUluZm89IG1zZ1BheWxvYWQuaW5mbztcclxuICAgICAgICB2YXIgbm9kZU5hbWU9IGdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbbm9kZUluZm9bXCIkZHRJZFwiXV1cclxuICAgICAgICB2YXIgdG9wb05vZGU9IHRoaXMuY29yZS5ub2RlcyhgW2lkPVwiJHtub2RlTmFtZX1cIl1gKVxyXG4gICAgICAgIGlmKHRvcG9Ob2RlKXtcclxuICAgICAgICAgICAgdGhpcy5jb3JlLmNlbnRlcih0b3BvTm9kZSlcclxuICAgICAgICB9XHJcbiAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwidmlzdWFsRGVmaW5pdGlvbkNoYW5nZVwiKXtcclxuICAgICAgICBpZihtc2dQYXlsb2FkLnNyY01vZGVsSUQpe1xyXG4gICAgICAgICAgICBpZihtc2dQYXlsb2FkLmNvbG9yKSB0aGlzLnN0eWxlTWFuYWdlci51cGRhdGVSZWxhdGlvbnNoaXBDb2xvcihtc2dQYXlsb2FkLnNyY01vZGVsSUQsbXNnUGF5bG9hZC5yZWxhdGlvbnNoaXBOYW1lLG1zZ1BheWxvYWQuY29sb3IpXHJcbiAgICAgICAgICAgIGVsc2UgaWYobXNnUGF5bG9hZC5zaGFwZSkgdGhpcy5zdHlsZU1hbmFnZXIudXBkYXRlUmVsYXRpb25zaGlwU2hhcGUobXNnUGF5bG9hZC5zcmNNb2RlbElELG1zZ1BheWxvYWQucmVsYXRpb25zaGlwTmFtZSxtc2dQYXlsb2FkLnNoYXBlKVxyXG4gICAgICAgICAgICBlbHNlIGlmKG1zZ1BheWxvYWQuZWRnZVdpZHRoKSB0aGlzLnN0eWxlTWFuYWdlci51cGRhdGVSZWxhdGlvbnNoaXBXaWR0aChtc2dQYXlsb2FkLnNyY01vZGVsSUQsbXNnUGF5bG9hZC5yZWxhdGlvbnNoaXBOYW1lLG1zZ1BheWxvYWQuZWRnZVdpZHRoKVxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgaWYobXNnUGF5bG9hZC5jb2xvcikgdGhpcy5zdHlsZU1hbmFnZXIudXBkYXRlTW9kZWxUd2luQ29sb3IobXNnUGF5bG9hZC5tb2RlbElELG1zZ1BheWxvYWQuY29sb3IsbXNnUGF5bG9hZC5zZWNvbmRDb2xvcilcclxuICAgICAgICAgICAgZWxzZSBpZihtc2dQYXlsb2FkLnNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFuYWdlci51cGRhdGVNb2RlbFR3aW5TaGFwZShtc2dQYXlsb2FkLm1vZGVsSUQsbXNnUGF5bG9hZC5zaGFwZSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYW5hZ2VyLmFkanVzdE1vZGVsc0Jhc2VEaW1lbnNpb24obXNnUGF5bG9hZC5tb2RlbElEKVxyXG4gICAgICAgICAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLmF2YXJ0YSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFuYWdlci5hZGp1c3RNb2RlbHNCYXNlRGltZW5zaW9uKG1zZ1BheWxvYWQubW9kZWxJRClcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYW5hZ2VyLnVwZGF0ZU1vZGVsQXZhcnRhKG1zZ1BheWxvYWQubW9kZWxJRCxtc2dQYXlsb2FkLmF2YXJ0YSlcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZihtc2dQYXlsb2FkLm5vQXZhcnRhKSAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZU1hbmFnZXIuYWRqdXN0TW9kZWxzQmFzZURpbWVuc2lvbihtc2dQYXlsb2FkLm1vZGVsSUQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFuYWdlci51cGRhdGVNb2RlbEF2YXJ0YShtc2dQYXlsb2FkLm1vZGVsSUQsbnVsbClcclxuICAgICAgICAgICAgfWVsc2UgaWYobXNnUGF5bG9hZC5kaW1lbnNpb25SYXRpbykgIHRoaXMuc3R5bGVNYW5hZ2VyLnVwZGF0ZU1vZGVsVHdpbkRpbWVuc2lvbihtc2dQYXlsb2FkLm1vZGVsSUQsbXNnUGF5bG9hZC5kaW1lbnNpb25SYXRpbylcclxuICAgICAgICAgICAgZWxzZSBpZihtc2dQYXlsb2FkLmxhYmVsUG9zaXRpb24pIHRoaXMuc3R5bGVNYW5hZ2VyLnVwZGF0ZU1vZGVsVHdpbkxhYmVsT2Zmc2V0KG1zZ1BheWxvYWQubW9kZWxJRClcclxuICAgICAgICB9IFxyXG4gICAgfWVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cInJlbGF0aW9uc0RlbGV0ZWRcIikgdGhpcy52aXN1YWxNYW5hZ2VyLmhpZGVSZWxhdGlvbnMobXNnUGF5bG9hZC5yZWxhdGlvbnMpXHJcbiAgICBlbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJzYXZlTGF5b3V0XCIpeyB0aGlzLnNhdmVMYXlvdXQobXNnUGF5bG9hZC5sYXlvdXROYW1lKSAgIH1cclxuICAgIGVsc2UgaWYgKG1zZ1BheWxvYWQubWVzc2FnZSA9PSBcImxheW91dENoYW5nZVwiKSB7XHJcbiAgICAgICAgdGhpcy52aXN1YWxNYW5hZ2VyLmNob29zZUxheW91dChnbG9iYWxDYWNoZS5jdXJyZW50TGF5b3V0TmFtZSlcclxuICAgIH1lbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJhbGlnblNlbGVjdGVkTm9kZVwiKSB0aGlzLnZpc3VhbE1hbmFnZXIuYWxpZ25TZWxlY3RlZE5vZGVzKG1zZ1BheWxvYWQuZGlyZWN0aW9uKVxyXG4gICAgZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwiZGlzdHJpYnV0ZVNlbGVjdGVkTm9kZVwiKSB0aGlzLnZpc3VhbE1hbmFnZXIuZGlzdHJpYnV0ZVNlbGVjdGVkTm9kZShtc2dQYXlsb2FkLmRpcmVjdGlvbilcclxuICAgIGVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cInJvdGF0ZVNlbGVjdGVkTm9kZVwiKSB0aGlzLnZpc3VhbE1hbmFnZXIucm90YXRlU2VsZWN0ZWROb2RlKG1zZ1BheWxvYWQuZGlyZWN0aW9uKVxyXG4gICAgZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwibWlycm9yU2VsZWN0ZWROb2RlXCIpIHRoaXMudmlzdWFsTWFuYWdlci5taXJyb3JTZWxlY3RlZE5vZGUobXNnUGF5bG9hZC5kaXJlY3Rpb24pXHJcbiAgICBlbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJkaW1lbnNpb25TZWxlY3RlZE5vZGVcIikgdGhpcy52aXN1YWxNYW5hZ2VyLmRpbWVuc2lvblNlbGVjdGVkTm9kZShtc2dQYXlsb2FkLmRpcmVjdGlvbilcclxuICAgIGVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cInZpZXdUeXBlQ2hhbmdlXCIpe1xyXG4gICAgICAgIGlmKG1zZ1BheWxvYWQudmlld1R5cGU9PVwiVG9wb2xvZ3lcIikgdGhpcy5zaG93U2VsZigpXHJcbiAgICAgICAgZWxzZSB0aGlzLmhpZGVTZWxmKClcclxuICAgIH1cclxufVxyXG5cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5zaG93U2VsZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgdGhpcy5ET00uYW5pbWF0ZSh7aGVpZ2h0OiBcIjEwMCVcIn0pO1xyXG59XHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUuaGlkZVNlbGYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLkRPTS5hbmltYXRlKHtoZWlnaHQ6IFwiMCVcIn0sKCk9Pnt0aGlzLkRPTS5oaWRlKCl9KTtcclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLmNvc2VTZWxlY3RlZD1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy52aXN1YWxNYW5hZ2VyLm5vUG9zaXRpb25fY29zZSh0aGlzLmNvcmUuJCgnOnNlbGVjdGVkJykpXHJcbn1cclxuXHJcblxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLnNhdmVMYXlvdXQgPSBhc3luYyBmdW5jdGlvbiAobGF5b3V0TmFtZSkge1xyXG4gICAgaWYoIWdsb2JhbENhY2hlLmxheW91dEpTT05bbGF5b3V0TmFtZV0pe1xyXG4gICAgICAgIHZhciBsYXlvdXREaWN0PXt9XHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUucmVjb3JkU2luZ2xlTGF5b3V0KGxheW91dERpY3QsZ2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uaWQsbGF5b3V0TmFtZSxmYWxzZSlcclxuICAgIH1lbHNlIGxheW91dERpY3Q9Z2xvYmFsQ2FjaGUubGF5b3V0SlNPTltsYXlvdXROYW1lXS5kZXRhaWxcclxuICAgIFxyXG4gICAgaWYobGF5b3V0RGljdFtcImVkZ2VzXCJdPT1udWxsKSBsYXlvdXREaWN0W1wiZWRnZXNcIl09e31cclxuICAgIFxyXG4gICAgdmFyIHNob3dpbmdMYXlvdXQ9dGhpcy52aXN1YWxNYW5hZ2VyLmdldEN1cnJlbnRMYXlvdXREZXRhaWwoKVxyXG4gICAgdmFyIHNob3dpbmdFZGdlc0xheW91dD0gc2hvd2luZ0xheW91dFtcImVkZ2VzXCJdXHJcbiAgICBkZWxldGUgc2hvd2luZ0xheW91dFtcImVkZ2VzXCJdXHJcbiAgICBmb3IodmFyIGluZCBpbiBzaG93aW5nTGF5b3V0KSBsYXlvdXREaWN0W2luZF09c2hvd2luZ0xheW91dFtpbmRdXHJcbiAgICBmb3IodmFyIGluZCBpbiBzaG93aW5nRWRnZXNMYXlvdXQpIGxheW91dERpY3RbXCJlZGdlc1wiXVtpbmRdPXNob3dpbmdFZGdlc0xheW91dFtpbmRdXHJcblxyXG4gICAgdmFyIHNhdmVMYXlvdXRPYmo9e1wibGF5b3V0c1wiOnt9fVxyXG4gICAgc2F2ZUxheW91dE9ialtcImxheW91dHNcIl1bbGF5b3V0TmFtZV09SlNPTi5zdHJpbmdpZnkobGF5b3V0RGljdCkgIFxyXG4gICAgdHJ5e1xyXG4gICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NhdmVMYXlvdXRcIiwgXCJQT1NUXCIsIHNhdmVMYXlvdXRPYmosXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwibGF5b3V0c1VwZGF0ZWRcIixcImxheW91dE5hbWVcIjpsYXlvdXROYW1lfSlcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUuc2VsZWN0SW5ib3VuZE5vZGVzID0gZnVuY3Rpb24gKHNlbGVjdGVkTm9kZXMpIHtcclxuICAgIHZhciBlbGVzPXRoaXMuY29yZS5ub2RlcygpLmVkZ2VzVG8oc2VsZWN0ZWROb2Rlcykuc291cmNlcygpXHJcbiAgICBlbGVzLmZvckVhY2goKGVsZSk9PnsgdGhpcy52aXN1YWxNYW5hZ2VyLmFuaW1hdGVBTm9kZShlbGUpIH0pXHJcbiAgICBlbGVzLnNlbGVjdCgpXHJcbiAgICB0aGlzLnNlbGVjdEZ1bmN0aW9uKClcclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLnNlbGVjdE91dGJvdW5kTm9kZXMgPSBmdW5jdGlvbiAoc2VsZWN0ZWROb2Rlcykge1xyXG4gICAgdmFyIGVsZXM9c2VsZWN0ZWROb2Rlcy5lZGdlc1RvKHRoaXMuY29yZS5ub2RlcygpKS50YXJnZXRzKClcclxuICAgIGVsZXMuZm9yRWFjaCgoZWxlKT0+eyB0aGlzLnZpc3VhbE1hbmFnZXIuYW5pbWF0ZUFOb2RlKGVsZSkgfSlcclxuICAgIGVsZXMuc2VsZWN0KClcclxuICAgIHRoaXMuc2VsZWN0RnVuY3Rpb24oKVxyXG59XHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUuYWRkQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiAodGFyZ2V0Tm9kZSxzcmNOb2RlQXJyKSB7XHJcbiAgICB2YXIgdGhlQ29ubmVjdE1vZGU9dGhpcy50YXJnZXROb2RlTW9kZVxyXG4gICAgdmFyIHByZXBhcmF0aW9uSW5mbz1bXVxyXG5cclxuICAgIHNyY05vZGVBcnIuZm9yRWFjaCh0aGVOb2RlPT57XHJcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25UeXBlc1xyXG4gICAgICAgIGlmKHRoZUNvbm5lY3RNb2RlPT1cImNvbm5lY3RUb1wiKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UeXBlcz10aGlzLmNoZWNrQXZhaWxhYmxlQ29ubmVjdGlvblR5cGUodGhlTm9kZS5kYXRhKFwibW9kZWxJRFwiKSx0YXJnZXROb2RlLmRhdGEoXCJtb2RlbElEXCIpKVxyXG4gICAgICAgICAgICBwcmVwYXJhdGlvbkluZm8ucHVzaCh7ZnJvbTp0aGVOb2RlLHRvOnRhcmdldE5vZGUsY29ubmVjdDpjb25uZWN0aW9uVHlwZXN9KVxyXG4gICAgICAgIH1lbHNlIGlmKHRoZUNvbm5lY3RNb2RlPT1cImNvbm5lY3RGcm9tXCIpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvblR5cGVzPXRoaXMuY2hlY2tBdmFpbGFibGVDb25uZWN0aW9uVHlwZSh0YXJnZXROb2RlLmRhdGEoXCJtb2RlbElEXCIpLHRoZU5vZGUuZGF0YShcIm1vZGVsSURcIikpXHJcbiAgICAgICAgICAgIHByZXBhcmF0aW9uSW5mby5wdXNoKHt0bzp0aGVOb2RlLGZyb206dGFyZ2V0Tm9kZSxjb25uZWN0OmNvbm5lY3Rpb25UeXBlc30pXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgIC8vVE9ETzogY2hlY2sgaWYgaXQgaXMgbmVlZGVkIHRvIHBvcHVwIGRpYWxvZywgaWYgYWxsIGNvbm5lY3Rpb24gaXMgZG9hYmxlIGFuZCBvbmx5IG9uZSB0eXBlIHRvIHVzZSwgbm8gbmVlZCB0byBzaG93IGRpYWxvZ1xyXG4gICAgdGhpcy5zaG93Q29ubmVjdGlvbkRpYWxvZyhwcmVwYXJhdGlvbkluZm8pXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5zaG93Q29ubmVjdGlvbkRpYWxvZyA9IGZ1bmN0aW9uIChwcmVwYXJhdGlvbkluZm8pIHtcclxuICAgIHZhciBjb25maXJtRGlhbG9nRGl2ID0gbmV3IHNpbXBsZUNvbmZpcm1EaWFsb2coKVxyXG4gICAgdmFyIHJlc3VsdEFjdGlvbnM9W11cclxuICAgIGNvbmZpcm1EaWFsb2dEaXYuc2hvdyhcclxuICAgICAgICB7IHdpZHRoOiBcIjQ1MHB4XCIgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRpdGxlOiBcIkFkZCBjb25uZWN0aW9uc1wiXHJcbiAgICAgICAgICAgICwgY29udGVudDogXCJcIlxyXG4gICAgICAgICAgICAsIGJ1dHRvbnM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLXJlZCB3My1ob3Zlci1waW5rXCIsIHRleHQ6IFwiQ29uZmlybVwiLCBcImNsaWNrRnVuY1wiOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1EaWFsb2dEaXYuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVDb25uZWN0aW9ucyhyZXN1bHRBY3Rpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JDbGFzczogXCJ3My1ncmF5XCIsIHRleHQ6IFwiQ2FuY2VsXCIsIFwiY2xpY2tGdW5jXCI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5jbG9zZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG4gICAgY29uZmlybURpYWxvZ0Rpdi5kaWFsb2dEaXYuZW1wdHkoKVxyXG4gICAgcHJlcGFyYXRpb25JbmZvLmZvckVhY2goKG9uZVJvdyxpbmRleCk9PntcclxuICAgICAgICByZXN1bHRBY3Rpb25zLnB1c2godGhpcy5jcmVhdGVPbmVDb25uZWN0aW9uQWRqdXN0Um93KG9uZVJvdyxjb25maXJtRGlhbG9nRGl2KSlcclxuICAgIH0pXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NLnByb3RvdHlwZS5jcmVhdGVPbmVDb25uZWN0aW9uQWRqdXN0Um93ID0gZnVuY3Rpb24gKG9uZVJvdyxjb25maXJtRGlhbG9nRGl2KSB7XHJcbiAgICB2YXIgcmV0dXJuT2JqPXt9XHJcbiAgICB2YXIgZnJvbU5vZGU9b25lUm93LmZyb21cclxuICAgIHZhciB0b05vZGU9b25lUm93LnRvXHJcbiAgICB2YXIgY29ubmVjdGlvblR5cGVzPW9uZVJvdy5jb25uZWN0XHJcbiAgICB2YXIgbGFiZWw9JCgnPGxhYmVsIHN0eWxlPVwiZGlzcGxheTpibG9jazttYXJnaW4tYm90dG9tOjJweFwiPjwvbGFiZWw+JylcclxuICAgIGlmKGNvbm5lY3Rpb25UeXBlcy5sZW5ndGg9PTApe1xyXG4gICAgICAgIGxhYmVsLmNzcyhcImNvbG9yXCIsXCJyZWRcIilcclxuICAgICAgICBsYWJlbC5odG1sKFwiTm8gdXNhYmxlIGNvbm5lY3Rpb24gdHlwZSBmcm9tIDxiPlwiK2Zyb21Ob2RlLmlkKCkrXCI8L2I+IHRvIDxiPlwiK3RvTm9kZS5pZCgpK1wiPC9iPlwiKVxyXG4gICAgfWVsc2UgaWYoY29ubmVjdGlvblR5cGVzLmxlbmd0aD4xKXsgXHJcbiAgICAgICAgbGFiZWwuaHRtbChcIkZyb20gPGI+XCIrZnJvbU5vZGUuaWQoKStcIjwvYj4gdG8gPGI+XCIrdG9Ob2RlLmlkKCkrXCI8L2I+XCIpIFxyXG4gICAgICAgIHZhciBzd2l0Y2hUeXBlU2VsZWN0b3I9bmV3IHNpbXBsZVNlbGVjdE1lbnUoXCIgXCIpXHJcbiAgICAgICAgbGFiZWwucHJlcGVuZChzd2l0Y2hUeXBlU2VsZWN0b3IuRE9NKVxyXG4gICAgICAgIGNvbm5lY3Rpb25UeXBlcy5mb3JFYWNoKG9uZVR5cGU9PntcclxuICAgICAgICAgICAgc3dpdGNoVHlwZVNlbGVjdG9yLmFkZE9wdGlvbihvbmVUeXBlKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuT2JqW1wiZnJvbVwiXT1mcm9tTm9kZS5kYXRhKCkub3JpZ2luYWxJbmZvW1wiJGR0SWRcIl1cclxuICAgICAgICByZXR1cm5PYmpbXCJ0b1wiXT10b05vZGUuZGF0YSgpLm9yaWdpbmFsSW5mb1tcIiRkdElkXCJdXHJcbiAgICAgICAgcmV0dXJuT2JqW1wiY29ubmVjdFwiXT1jb25uZWN0aW9uVHlwZXNbMF1cclxuICAgICAgICBzd2l0Y2hUeXBlU2VsZWN0b3IuY2FsbEJhY2tfY2xpY2tPcHRpb249KG9wdGlvblRleHQsb3B0aW9uVmFsdWUpPT57XHJcbiAgICAgICAgICAgIHJldHVybk9ialtcImNvbm5lY3RcIl09b3B0aW9uVGV4dFxyXG4gICAgICAgICAgICBzd2l0Y2hUeXBlU2VsZWN0b3IuY2hhbmdlTmFtZShvcHRpb25UZXh0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2hUeXBlU2VsZWN0b3IudHJpZ2dlck9wdGlvbkluZGV4KDApXHJcbiAgICB9ZWxzZSBpZihjb25uZWN0aW9uVHlwZXMubGVuZ3RoPT0xKXtcclxuICAgICAgICByZXR1cm5PYmpbXCJmcm9tXCJdPWZyb21Ob2RlLmRhdGEoKS5vcmlnaW5hbEluZm9bXCIkZHRJZFwiXVxyXG4gICAgICAgIHJldHVybk9ialtcInRvXCJdPXRvTm9kZS5kYXRhKCkub3JpZ2luYWxJbmZvW1wiJGR0SWRcIl1cclxuICAgICAgICByZXR1cm5PYmpbXCJjb25uZWN0XCJdPWNvbm5lY3Rpb25UeXBlc1swXVxyXG4gICAgICAgIGxhYmVsLmNzcyhcImNvbG9yXCIsXCJncmVlblwiKVxyXG4gICAgICAgIGxhYmVsLmh0bWwoXCJBZGQgPGI+XCIrY29ubmVjdGlvblR5cGVzWzBdK1wiPC9iPiBjb25uZWN0aW9uIGZyb20gPGI+XCIrZnJvbU5vZGUuaWQoKStcIjwvYj4gdG8gPGI+XCIrdG9Ob2RlLmlkKCkrXCI8L2I+XCIpIFxyXG4gICAgfVxyXG4gICAgY29uZmlybURpYWxvZ0Rpdi5kaWFsb2dEaXYuYXBwZW5kKGxhYmVsKVxyXG4gICAgcmV0dXJuIHJldHVybk9iajtcclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb25zID0gYXN5bmMgZnVuY3Rpb24gKHJlc3VsdEFjdGlvbnMpIHtcclxuICAgIHZhciBmaW5hbEFjdGlvbnM9W11cclxuICAgIHJlc3VsdEFjdGlvbnMuZm9yRWFjaChvbmVBY3Rpb249PntcclxuICAgICAgICB2YXIgb25lRmluYWxBY3Rpb249e31cclxuICAgICAgICBvbmVGaW5hbEFjdGlvbltcIiRzcmNJZFwiXT1vbmVBY3Rpb25bXCJmcm9tXCJdXHJcbiAgICAgICAgb25lRmluYWxBY3Rpb25bXCIkcmVsYXRpb25zaGlwSWRcIl09Z2xvYmFsQ2FjaGUudXVpZHY0KCk7XHJcbiAgICAgICAgb25lRmluYWxBY3Rpb25bXCJvYmpcIl09e1xyXG4gICAgICAgICAgICBcIiR0YXJnZXRJZFwiOiBvbmVBY3Rpb25bXCJ0b1wiXSxcclxuICAgICAgICAgICAgXCIkcmVsYXRpb25zaGlwTmFtZVwiOiBvbmVBY3Rpb25bXCJjb25uZWN0XCJdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsQWN0aW9ucy5wdXNoKG9uZUZpbmFsQWN0aW9uKVxyXG4gICAgfSlcclxuICAgIHRyeXtcclxuICAgICAgICB2YXIgZGF0YSA9IGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2NyZWF0ZVJlbGF0aW9uc1wiLCBcIlBPU1RcIiwgIHthY3Rpb25zOkpTT04uc3RyaW5naWZ5KGZpbmFsQWN0aW9ucyl9KVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgfVxyXG4gICAgZ2xvYmFsQ2FjaGUuc3RvcmVUd2luUmVsYXRpb25zaGlwc19hcHBlbmQoZGF0YSlcclxuICAgIHRoaXMudmlzdWFsTWFuYWdlci5kcmF3UmVsYXRpb25zKGRhdGEpXHJcbn1cclxuXHJcblxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLmNoZWNrQXZhaWxhYmxlQ29ubmVjdGlvblR5cGUgPSBmdW5jdGlvbiAoZnJvbU5vZGVNb2RlbCx0b05vZGVNb2RlbCkge1xyXG4gICAgdmFyIHJlPVtdXHJcbiAgICB2YXIgdmFsaWRSZWxhdGlvbnNoaXBzPW1vZGVsQW5hbHl6ZXIuRFRETE1vZGVsc1tmcm9tTm9kZU1vZGVsXS52YWxpZFJlbGF0aW9uc2hpcHNcclxuICAgIHZhciB0b05vZGVCYXNlQ2xhc3Nlcz1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbdG9Ob2RlTW9kZWxdLmFsbEJhc2VDbGFzc2VzXHJcbiAgICBpZih2YWxpZFJlbGF0aW9uc2hpcHMpe1xyXG4gICAgICAgIGZvcih2YXIgcmVsYXRpb25OYW1lIGluIHZhbGlkUmVsYXRpb25zaGlwcyl7XHJcbiAgICAgICAgICAgIHZhciB0aGVSZWxhdGlvblR5cGU9dmFsaWRSZWxhdGlvbnNoaXBzW3JlbGF0aW9uTmFtZV1cclxuICAgICAgICAgICAgaWYodGhlUmVsYXRpb25UeXBlLnRhcmdldD09bnVsbFxyXG4gICAgICAgICAgICAgICAgIHx8IHRoZVJlbGF0aW9uVHlwZS50YXJnZXQ9PXRvTm9kZU1vZGVsXHJcbiAgICAgICAgICAgICAgICAgfHx0b05vZGVCYXNlQ2xhc3Nlc1t0aGVSZWxhdGlvblR5cGUudGFyZ2V0XSE9bnVsbCkgcmUucHVzaChyZWxhdGlvbk5hbWUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlXHJcbn1cclxuXHJcblxyXG50b3BvbG9neURPTS5wcm90b3R5cGUuc2V0S2V5RG93bkZ1bmM9ZnVuY3Rpb24oaW5jbHVkZUNhbmNlbENvbm5lY3RPcGVyYXRpb24pe1xyXG4gICAgJChkb2N1bWVudCkub24oXCJrZXlkb3duXCIsICAoZSk9PntcclxuICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIGUudGFyZ2V0Lm5vZGVOYW1lID09PSAnQk9EWScpe1xyXG4gICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gOTApICAgdGhpcy52aXN1YWxNYW5hZ2VyLnVyLnVuZG8oKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZS53aGljaCA9PT0gODkpICAgIHRoaXMudmlzdWFsTWFuYWdlci51ci5yZWRvKCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZS53aGljaD09PTgzKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7XCJtZXNzYWdlXCI6XCJwb3B1cExheW91dEVkaXRpbmdcIn0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihpbmNsdWRlQ2FuY2VsQ29ubmVjdE9wZXJhdGlvbil7XHJcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHRoaXMuY2FuY2VsVGFyZ2V0Tm9kZU1vZGUoKSAgICBcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLnN0YXJ0VGFyZ2V0Tm9kZU1vZGUgPSBmdW5jdGlvbiAobW9kZSxzZWxlY3RlZE5vZGVzKSB7XHJcbiAgICB0aGlzLmNvcmUuYXV0b3Vuc2VsZWN0aWZ5KCB0cnVlICk7XHJcbiAgICB0aGlzLmNvcmUuY29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XHJcbiAgICB0aGlzLnRhcmdldE5vZGVNb2RlPW1vZGU7XHJcbiAgICB0aGlzLnNldEtleURvd25GdW5jKFwiaW5jbHVkZUNhbmNlbENvbm5lY3RPcGVyYXRpb25cIilcclxuXHJcbiAgICB0aGlzLmNvcmUubm9kZXMoKS5vbignY2xpY2snLCAoZSk9PntcclxuICAgICAgICB2YXIgY2xpY2tlZE5vZGUgPSBlLnRhcmdldDtcclxuICAgICAgICB0aGlzLmFkZENvbm5lY3Rpb25zKGNsaWNrZWROb2RlLHNlbGVjdGVkTm9kZXMpXHJcbiAgICAgICAgLy9kZWxheSBhIHNob3J0IHdoaWxlIHNvIG5vZGUgc2VsZWN0aW9uIHdpbGwgbm90IGJlIGNoYW5nZWQgdG8gdGhlIGNsaWNrZWQgdGFyZ2V0IG5vZGVcclxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57dGhpcy5jYW5jZWxUYXJnZXROb2RlTW9kZSgpfSw1MClcclxuXHJcbiAgICB9KTtcclxufVxyXG5cclxudG9wb2xvZ3lET00ucHJvdG90eXBlLmNhbmNlbFRhcmdldE5vZGVNb2RlPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnRhcmdldE5vZGVNb2RlPW51bGw7XHJcbiAgICB0aGlzLmNvcmUuY29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xyXG4gICAgJChkb2N1bWVudCkub2ZmKCdrZXlkb3duJyk7XHJcbiAgICB0aGlzLnNldEtleURvd25GdW5jKClcclxuICAgIHRoaXMuY29yZS5ub2RlcygpLm9mZihcImNsaWNrXCIpXHJcbiAgICB0aGlzLmNvcmUuYXV0b3Vuc2VsZWN0aWZ5KCBmYWxzZSApO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB0b3BvbG9neURPTTsiLCJjb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBuZXdUd2luRGlhbG9nPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9uZXdUd2luRGlhbG9nXCIpO1xyXG5jb25zdCBzaW1wbGVDb25maXJtRGlhbG9nPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9zaW1wbGVDb25maXJtRGlhbG9nXCIpXHJcbmNvbnN0IHNpbXBsZVNlbGVjdE1lbnU9cmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL3NpbXBsZVNlbGVjdE1lbnVcIilcclxuY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5cclxuZnVuY3Rpb24gdG9wb2xvZ3lET01fbWVudShwYXJlbnRUb3BvbG9neURPTSl7XHJcbiAgICB0aGlzLnBhcmVudFRvcG9sb2d5RE9NPXBhcmVudFRvcG9sb2d5RE9NXHJcbiAgICB0aGlzLmNvcmU9cGFyZW50VG9wb2xvZ3lET00uY29yZVxyXG4gICAgdGhpcy5jb250ZW54dE1lbnVJbnN0YW5jZSA9IHRoaXMuY29yZS5jb250ZXh0TWVudXMoJ2dldCcpXHJcbiAgICB0aGlzLmFkZE1lbnVJdGVtc0ZvckVkaXRpbmcoKVxyXG4gICAgdGhpcy5hZGRNZW51SXRlbXNGb3JPdGhlcnMoKVxyXG4gICAgdGhpcy5hZGRNZW51SXRlbXNGb3JMaXZlRGF0YSgpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX21lbnUucHJvdG90eXBlLmRlY2lkZVZpc2libGVDb250ZXh0TWVudT1mdW5jdGlvbihjbGlja0VsZSl7XHJcbiAgICAvL2hpZGUgYWxsIG1lbnUgaXRlbXNcclxuICAgIHZhciBhbGxJdGVtcz1bJ0Nvbm5lY3RUbycsJ0Nvbm5lY3RGcm9tJywnUXVlcnlPdXRib3VuZCcsJ1F1ZXJ5SW5ib3VuZCcsJ1NlbGVjdE91dGJvdW5kJywnU2VsZWN0SW5ib3VuZCcsJ2VuYWJsZUxpdmVEYXRhU3RyZWFtJywnQ09TRScsJ2FkZFNpbXVsYXRpbmdEYXRhU291cmNlJywnbGl2ZURhdGEnLCdIaWRlJywnT3RoZXJzJywnU2ltdWxhdGlvbicsICdzdGFydFNpbXVsYXRpbmdEYXRhU291cmNlJywgJ3N0b3BTaW11bGF0aW5nRGF0YVNvdXJjZScsICdlZGl0aW5nJywnRGVsZXRlQWxsJ11cclxuICAgIGFsbEl0ZW1zLmZvckVhY2goZWxlPT57dGhpcy5jb250ZW54dE1lbnVJbnN0YW5jZS5oaWRlTWVudUl0ZW0oZWxlKX0pXHJcbiAgICBcclxuICAgIHZhciBzZWxlY3RlZE5vZGVzPXRoaXMuY29yZS4kKCdub2RlOnNlbGVjdGVkJylcclxuICAgIHZhciBzZWxlY3RlZD10aGlzLmNvcmUuJCgnOnNlbGVjdGVkJylcclxuICAgIHZhciBpc0NsaWNraW5nTm9kZT0oY2xpY2tFbGUuaXNOb2RlICYmIGNsaWNrRWxlLmlzTm9kZSgpIClcclxuICAgIHZhciBoYXNOb2RlPWlzQ2xpY2tpbmdOb2RlIHx8IChzZWxlY3RlZE5vZGVzLmxlbmd0aD4wKVxyXG4gICAgaWYoY2xpY2tFbGUuaXNOb2RlICYmIGNsaWNrRWxlLmRhdGEoXCJvcmlnaW5hbEluZm9cIikgJiYgY2xpY2tFbGUuZGF0YShcIm9yaWdpbmFsSW5mb1wiKS5zaW1Ob2RlTmFtZSkgdmFyIGNsaWNrU2ltTm9kZT10cnVlXHJcbiAgICBcclxuICAgIHZhciBzaG93TWVudUFycj0oYXJyKT0+e1xyXG4gICAgICAgIGFyci5mb3JFYWNoKGVsZT0+e3RoaXMuY29udGVueHRNZW51SW5zdGFuY2Uuc2hvd01lbnVJdGVtKGVsZSl9KVxyXG4gICAgfVxyXG5cclxuICAgIGlmKGNsaWNrU2ltTm9kZSkge1xyXG4gICAgICAgIHZhciBzaW1Ob2RlTmFtZT1jbGlja0VsZS5kYXRhKCdvcmlnaW5hbEluZm8nKS5zaW1Ob2RlTmFtZVxyXG4gICAgICAgIHNob3dNZW51QXJyKFsnZWRpdGluZycsJ0RlbGV0ZUFsbCcsJ1NpbXVsYXRpb24nXSlcclxuICAgICAgICBpZih0aGlzLnBhcmVudFRvcG9sb2d5RE9NLnNpbURhdGFTb3VyY2VNYW5hZ2VyLnJ1bm5pbmdTaW1EYXRhU291cmNlW3NpbU5vZGVOYW1lXSl7XHJcbiAgICAgICAgICAgIHNob3dNZW51QXJyKFsnc3RvcFNpbXVsYXRpbmdEYXRhU291cmNlJ10pXHJcbiAgICAgICAgfWVsc2Ugc2hvd01lbnVBcnIoWydzdGFydFNpbXVsYXRpbmdEYXRhU291cmNlJ10pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBpZihoYXNOb2RlKXtcclxuICAgICAgICAgICAgc2hvd01lbnVBcnIoWydlZGl0aW5nJywnQ29ubmVjdFRvJywnQ29ubmVjdEZyb20nLCdPdGhlcnMnLCdRdWVyeU91dGJvdW5kJywnUXVlcnlJbmJvdW5kJywnU2VsZWN0T3V0Ym91bmQnLCdTZWxlY3RJbmJvdW5kJywnSGlkZScsJ0RlbGV0ZUFsbCddKVxyXG4gICAgICAgICAgICBpZihpc0NsaWNraW5nTm9kZSkgc2hvd01lbnVBcnIoWydsaXZlRGF0YScsJ2VuYWJsZUxpdmVEYXRhU3RyZWFtJywnYWRkU2ltdWxhdGluZ0RhdGFTb3VyY2UnXSlcclxuICAgICAgICAgICAgaWYoc2VsZWN0ZWQubGVuZ3RoPjEpIHNob3dNZW51QXJyKFsnQ09TRSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZighaGFzTm9kZSAmJiAhY2xpY2tFbGUuZGF0YSgpLm5vdFR3aW4pIHNob3dNZW51QXJyKFsnZWRpdGluZycsJ0RlbGV0ZUFsbCddKVxyXG4gICAgfVxyXG59XHJcblxyXG50b3BvbG9neURPTV9tZW51LnByb3RvdHlwZS5hZGRNZW51SXRlbXNGb3JMaXZlRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY29udGVueHRNZW51SW5zdGFuY2UuYXBwZW5kTWVudUl0ZW1zKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnbGl2ZURhdGEnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnTGl2ZSBEYXRhJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlJyxcclxuICAgICAgICAgICAgZGlzYWJsZWQ6dHJ1ZSxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoKT0+e30vL2VtcHR5IGZ1bmMsIGl0IGlzIG9ubHkgYSBtZW51IHRpdGxlIGl0ZW1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdTaW11bGF0aW9uJyxcclxuICAgICAgICAgICAgY29udGVudDogJ1NpbXVsYXRpb24nLFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25vZGVbbW9kZWxJRCA9IFwiX2ZpeGVkX3NpbXVsYXRpb25EYXRhU291cmNlXCJdJyxcclxuICAgICAgICAgICAgZGlzYWJsZWQ6dHJ1ZSxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoKT0+e30vL2VtcHR5IGZ1bmMsIGl0IGlzIG9ubHkgYSBtZW51IHRpdGxlIGl0ZW1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdzdGFydFNpbXVsYXRpbmdEYXRhU291cmNlJyxcclxuICAgICAgICAgICAgY29udGVudDogJ1N0YXJ0JyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlW21vZGVsSUQgPSBcIl9maXhlZF9zaW11bGF0aW9uRGF0YVNvdXJjZVwiXScsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2xpY2tlZEVsZShlLnRhcmdldClcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLmN5VGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb3BvbG9neURPTS5zaW1EYXRhU291cmNlTWFuYWdlci5zdGFydFNpbU5vZGUoZS50YXJnZXQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdzdG9wU2ltdWxhdGluZ0RhdGFTb3VyY2UnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnU3RvcCcsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZVttb2RlbElEID0gXCJfZml4ZWRfc2ltdWxhdGlvbkRhdGFTb3VyY2VcIl0nLFxyXG4gICAgICAgICAgICBvbkNsaWNrRnVuY3Rpb246IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdENsaWNrZWRFbGUoZS50YXJnZXQpXHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5jeVRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50VG9wb2xvZ3lET00uc2ltRGF0YVNvdXJjZU1hbmFnZXIuc3RvcFNpbU5vZGUoZS50YXJnZXQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdhZGRTaW11bGF0aW5nRGF0YVNvdXJjZScsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdBZGQgU2ltdWxhdG9yIFNvdXJjZScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZScsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Q2xpY2tlZEVsZShlLnRhcmdldClcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLmN5VGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb3BvbG9neURPTS5hZGRTaW11bGF0b3JTb3VyY2UodGFyZ2V0LmlkKCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdlbmFibGVMaXZlRGF0YVN0cmVhbScsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdNb25pdG9yIExpdmUgRGF0YScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZScsIFxyXG4gICAgICAgICAgICBvbkNsaWNrRnVuY3Rpb246IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdENsaWNrZWRFbGUoZS50YXJnZXQpXHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5jeVRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50VG9wb2xvZ3lET00uZW5hYmxlTGl2ZURhdGFTdHJlYW0odGFyZ2V0LmlkKCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9tZW51LnByb3RvdHlwZS5hZGRNZW51SXRlbXNGb3JFZGl0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5jb250ZW54dE1lbnVJbnN0YW5jZS5hcHBlbmRNZW51SXRlbXMoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdlZGl0aW5nJyxcclxuICAgICAgICAgICAgY29udGVudDogJ0VkaXQnLFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25vZGUsZWRnZScsXHJcbiAgICAgICAgICAgIGRpc2FibGVkOnRydWUsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKCk9Pnt9Ly9lbXB0eSBmdW5jLCBpdCBpcyBvbmx5IGEgbWVudSB0aXRsZSBpdGVtXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnQ29ubmVjdFRvJyxcclxuICAgICAgICAgICAgY29udGVudDogJ0Nvbm5lY3QgVG8nLFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25vZGUsZWRnZScsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50VG9wb2xvZ3lET00uc3RhcnRUYXJnZXROb2RlTW9kZShcImNvbm5lY3RUb1wiLHRoaXMubm9kZV9jaGFuZ2VTZWxlY3Rpb25XaGVuQ2xpY2tFbGVtZW50KGUudGFyZ2V0KSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ0Nvbm5lY3RGcm9tJyxcclxuICAgICAgICAgICAgY29udGVudDogJ0Nvbm5lY3QgRnJvbScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZSxlZGdlJyxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb3BvbG9neURPTS5zdGFydFRhcmdldE5vZGVNb2RlKFwiY29ubmVjdEZyb21cIix0aGlzLm5vZGVfY2hhbmdlU2VsZWN0aW9uV2hlbkNsaWNrRWxlbWVudChlLnRhcmdldCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdEZWxldGVBbGwnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnRGVsZXRlJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlLGVkZ2UnLFxyXG4gICAgICAgICAgICBvbkNsaWNrRnVuY3Rpb246IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbj10aGlzLm5vZGVvcmVkZ2VfY2hhbmdlU2VsZWN0aW9uV2hlbkNsaWNrRWxlbWVudChlLnRhcmdldClcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24udW5zZWxlY3QoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb3BvbG9neURPTS5zZWxlY3RGdW5jdGlvbigpXHJcbiAgICAgICAgICAgICAgICBpZihjb2xsZWN0aW9uLmxlbmd0aD09MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZT1jb2xsZWN0aW9uWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZWxlLmRhdGEgJiYgZWxlLmRhdGEoXCJvcmlnaW5hbEluZm9cIikuc2ltTm9kZU5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvcG9sb2d5RE9NLmRlbGV0ZVNpbU5vZGUoZWxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvcG9sb2d5RE9NLmRlbGV0ZUVsZW1lbnRzQXJyYXkoY29sbGVjdGlvbilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIF0pXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX21lbnUucHJvdG90eXBlLmFkZE1lbnVJdGVtc0Zvck90aGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY29udGVueHRNZW51SW5zdGFuY2UuYXBwZW5kTWVudUl0ZW1zKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnT3RoZXJzJyxcclxuICAgICAgICAgICAgY29udGVudDogJ090aGVycycsIFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25vZGUsZWRnZScsXHJcbiAgICAgICAgICAgIGRpc2FibGVkOnRydWUsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKCk9Pnt9IC8vZW1wdHkgZnVuYywgaXQgaXMgb25seSBhIG1lbnUgdGl0bGUgaXRlbVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ1F1ZXJ5T3V0Ym91bmQnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnTG9hZCBPdXRib3VuZCcsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZSxlZGdlJyxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb3BvbG9neURPTS5sb2FkT3V0Qm91bmQodGhpcy5ub2RlX2NoYW5nZVNlbGVjdGlvbldoZW5DbGlja0VsZW1lbnQoZS50YXJnZXQpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnUXVlcnlJbmJvdW5kJyxcclxuICAgICAgICAgICAgY29udGVudDogJ0xvYWQgSW5ib3VuZCcsIFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25vZGUsZWRnZScsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50VG9wb2xvZ3lET00ubG9hZEluQm91bmQodGhpcy5ub2RlX2NoYW5nZVNlbGVjdGlvbldoZW5DbGlja0VsZW1lbnQoZS50YXJnZXQpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSx7XHJcbiAgICAgICAgICAgIGlkOiAnU2VsZWN0T3V0Ym91bmQnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnK1NlbGVjdCBPdXRib3VuZCcsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZSxlZGdlJyxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb3BvbG9neURPTS5zZWxlY3RPdXRib3VuZE5vZGVzKHRoaXMubm9kZV9jaGFuZ2VTZWxlY3Rpb25XaGVuQ2xpY2tFbGVtZW50KGUudGFyZ2V0KSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ1NlbGVjdEluYm91bmQnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnK1NlbGVjdCBJbmJvdW5kJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlLGVkZ2UnLFxyXG4gICAgICAgICAgICBvbkNsaWNrRnVuY3Rpb246IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvcG9sb2d5RE9NLnNlbGVjdEluYm91bmROb2Rlcyh0aGlzLm5vZGVfY2hhbmdlU2VsZWN0aW9uV2hlbkNsaWNrRWxlbWVudChlLnRhcmdldCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdDT1NFJyxcclxuICAgICAgICAgICAgY29udGVudDogJ0NPU0UgTGF5b3V0JyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlLGVkZ2UnLFxyXG4gICAgICAgICAgICBvbkNsaWNrRnVuY3Rpb246IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvcG9sb2d5RE9NLmNvc2VTZWxlY3RlZCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdkdXBsaWNhdGUnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnRHVwbGljYXRlJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlJyxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb249dGhpcy5zZWxlY3RDbGlja2VkRWxlKGUudGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgdmFyIG9JbmZvPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS50YXJnZXQuZGF0YShcIm9yaWdpbmFsSW5mb1wiKSkpXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgb0luZm9bXCIkbWV0YWRhdGFcIl07ZGVsZXRlIG9JbmZvW1wiJGR0SWRcIl07ZGVsZXRlIG9JbmZvW1wiJGV0YWdcIl07ZGVsZXRlIG9JbmZvW1wiZGlzcGxheU5hbWVcIl1cclxuICAgICAgICAgICAgICAgIG9JbmZvW1wiJG1ldGFkYXRhXCJdPXtcIiRtb2RlbFwiOiBlLnRhcmdldC5kYXRhKFwibW9kZWxJRFwiKX1cclxuICAgICAgICAgICAgICAgIG5ld1R3aW5EaWFsb2cucG9wdXAob0luZm8sKHR3aW5JbmZvKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2luTmFtZT10d2luSW5mby5kaXNwbGF5TmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29weSB0aGlzIG5vZGUncyBzY2FsZSBhbmQgcm90YXRlIHRvIHRoZSBuZXcgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50VG9wb2xvZ3lET00udmlzdWFsTWFuYWdlci5hcHBseU5vZGVTY2FsZVJvdGF0ZSh0d2luTmFtZSxlLnRhcmdldC5kYXRhKFwic2NhbGVGYWN0b3JcIiksZS50YXJnZXQuZGF0YShcInJvdGF0ZUFuZ2xlXCIpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ0hpZGUnLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnSGlkZScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZSxlZGdlJyxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb249dGhpcy5ub2RlX2NoYW5nZVNlbGVjdGlvbldoZW5DbGlja0VsZW1lbnQoZS50YXJnZXQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvcG9sb2d5RE9NLmhpZGVDb2xsZWN0aW9uKGNvbGxlY3Rpb24pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdhZGRHcm91cFRhZycsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdBZGQgR3JvdXAgVGFnJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlJyxcclxuICAgICAgICAgICAgb25DbGlja0Z1bmN0aW9uOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb249dGhpcy5ub2RlX2NoYW5nZVNlbGVjdGlvbldoZW5DbGlja0VsZW1lbnQoZS50YXJnZXQpLmZpbHRlcignbm9kZScpXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXNJRD1bXVxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGVsZT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzSUQucHVzaChlbGUuZGF0YShcIm9yaWdpbmFsSW5mb1wiKVtcIiRkdElkXCJdKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0R3JvdXBUYWcobm9kZXNJRClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ2NvcHlTY2FsZVJvdGF0ZScsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdDb3B5IFN0eWxlJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlLmVkZ2ViZW5kZWRpdGluZ19zY2FsZVJvdGF0ZScsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uPXRoaXMubm9kZV9jaGFuZ2VTZWxlY3Rpb25XaGVuQ2xpY2tFbGVtZW50KGUudGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgdmFyIG49Y29sbGVjdGlvblswXVxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsQ2FjaGUuY2xpcGJvYXJkTm9kZVN0eWxlPXtcInNjYWxlRmFjdG9yXCI6bi5kYXRhKFwic2NhbGVGYWN0b3JcIil8fDEsXCJyb3RhdGVBbmdsZVwiOm4uZGF0YShcInJvdGF0ZUFuZ2xlXCIpfHwwfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAncGFzdGVTY2FsZVJvdGF0ZScsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdQYXN0ZSBTdHlsZScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbm9kZScsXHJcbiAgICAgICAgICAgIG9uQ2xpY2tGdW5jdGlvbjogKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uPXRoaXMubm9kZV9jaGFuZ2VTZWxlY3Rpb25XaGVuQ2xpY2tFbGVtZW50KGUudGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgdmFyIG49Y29sbGVjdGlvblswXVxyXG4gICAgICAgICAgICAgICAgaWYoZ2xvYmFsQ2FjaGUuY2xpcGJvYXJkTm9kZVN0eWxlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvcG9sb2d5RE9NLnZpc3VhbE1hbmFnZXIuYXBwbHlOb2RlU2NhbGVSb3RhdGUobi5pZCgpLGdsb2JhbENhY2hlLmNsaXBib2FyZE5vZGVTdHlsZS5zY2FsZUZhY3RvcixnbG9iYWxDYWNoZS5jbGlwYm9hcmROb2RlU3R5bGUucm90YXRlQW5nbGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIF0pXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX21lbnUucHJvdG90eXBlLmdldEFsbFRhZ3MgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHRhZ3M9e31cclxuICAgIGZvcih2YXIgdHdpbklEIGluIGdsb2JhbENhY2hlLkRCVHdpbnMpe1xyXG4gICAgICAgIHZhciBhREJUd2luPWdsb2JhbENhY2hlLkRCVHdpbnNbdHdpbklEXVxyXG4gICAgICAgIHZhciB0YWc9YURCVHdpbi5ncm91cFRhZ1xyXG4gICAgICAgIGlmKHRhZyE9bnVsbCkgdGFnc1t0YWddPTFcclxuICAgIH1cclxuICAgIHJldHVybiB0YWdzXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX21lbnUucHJvdG90eXBlLnNldEdyb3VwVGFnPWZ1bmN0aW9uKG5vZGVzSURBcnIpe1xyXG4gICAgdmFyIGRpYWxvZz1uZXcgc2ltcGxlQ29uZmlybURpYWxvZygpXHJcbiAgICB2YXIgc2VuZFRhZ1JlcWVzdD0odGFnU3RyKT0+e1xyXG4gICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NldFR3aW5zR3JvdXBUYWdcIiwgXCJQT1NUXCIsIHtcInR3aW5zSURBcnJcIjpub2Rlc0lEQXJyLFwiZ3JvdXBUYWdcIjp0YWdTdHJ9LFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgIGRpYWxvZy5jbG9zZSgpIFxyXG4gICAgfVxyXG4gICAgZGlhbG9nLnNob3coe1wid2lkdGhcIjpcIjMyMHB4XCJ9LHtcclxuICAgICAgICBcInRpdGxlXCI6XCJBc3NpZ24gR3JvdXAgVGFnXCIsXHJcbiAgICAgICAgXCJjdXN0b21EcmF3aW5nXCI6KHBhcmVudERPTSk9PntcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUYWdzPW5ldyBzaW1wbGVTZWxlY3RNZW51KFwiVXNlIGEgZXhpc3RpbmcgZ3JvdXAgdGFnIG9yIGZpbGwgYSBuZXcgb25lIGJlbG93XCIpXHJcbiAgICAgICAgICAgIHBhcmVudERPTS5hcHBlbmQoY3VycmVudFRhZ3MuRE9NKVxyXG4gICAgICAgICAgICB2YXIgdGFncz10aGlzLmdldEFsbFRhZ3MoKVxyXG4gICAgICAgICAgICBmb3IodmFyIGF0YWcgaW4gdGFncykgY3VycmVudFRhZ3MuYWRkT3B0aW9uKGF0YWcpXHJcbiAgICAgICAgICAgIGRpYWxvZy50YWdJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm1hcmdpbjo4cHggMDtwYWRkaW5nOjJweDt3aWR0aDoyOTBweDtvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmVcIiBwbGFjZWhvbGRlcj1cIlRhZ1wiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgICAgICAgICAgcGFyZW50RE9NLmFwcGVuZChkaWFsb2cudGFnSW5wdXQpXHJcbiAgICAgICAgICAgIGRpYWxvZy50YWdJbnB1dC5vbigna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInIHx8IGUua2V5Q29kZSA9PT0gMTMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZW5kVGFnUmVxZXN0KGRpYWxvZy50YWdJbnB1dC52YWwoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUYWdzLmNhbGxCYWNrX2NsaWNrT3B0aW9uPShvcHRpb25UZXh0LG9wdGlvblZhbHVlKT0+e1xyXG4gICAgICAgICAgICAgICAgZGlhbG9nLnRhZ0lucHV0LnZhbChvcHRpb25UZXh0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJ1dHRvbnNcIjpbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIk9LXCIsXHJcbiAgICAgICAgICAgICAgICBcImNvbG9yQ2xhc3NcIjpcInczLWxpbWVcIixcclxuICAgICAgICAgICAgICAgIFwiY2xpY2tGdW5jXCI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZW5kVGFnUmVxZXN0KGRpYWxvZy50YWdJbnB1dC52YWwoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1widGV4dFwiOlwiQ2FuY2VsXCIsXCJjb2xvckNsYXNzXCI6XCJ3My1saWdodC1ncmF5XCIsXCJjbGlja0Z1bmNcIjooKT0+e2RpYWxvZy5jbG9zZSgpfX1cclxuICAgICAgICBdXHJcbiAgICB9KVxyXG59XHJcblxyXG50b3BvbG9neURPTV9tZW51LnByb3RvdHlwZS5zZWxlY3RFbGVtZW50PWZ1bmN0aW9uKGVsZW1lbnQpe1xyXG4gICAgZWxlbWVudC5zZWxlY3QoKVxyXG4gICAgdGhpcy5wYXJlbnRUb3BvbG9neURPTS5zZWxlY3RGdW5jdGlvbigpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX21lbnUucHJvdG90eXBlLnNlbGVjdElmQ2xpY2tFbGVJc05vdFNlbGVjdGVkPWZ1bmN0aW9uKGNsaWNrRWxlKXtcclxuICAgIGlmKCFjbGlja0VsZS5zZWxlY3RlZCgpKXtcclxuICAgICAgICB0aGlzLmNvcmUuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudChjbGlja0VsZSlcclxuICAgIH1cclxufVxyXG5cclxudG9wb2xvZ3lET01fbWVudS5wcm90b3R5cGUuc2VsZWN0Q2xpY2tlZEVsZT1mdW5jdGlvbihjbGlja0VsZSl7XHJcbiAgICB0aGlzLmNvcmUuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoKVxyXG4gICAgdGhpcy5zZWxlY3RFbGVtZW50KGNsaWNrRWxlKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9tZW51LnByb3RvdHlwZS5ub2RlX2NoYW5nZVNlbGVjdGlvbldoZW5DbGlja0VsZW1lbnQ9ZnVuY3Rpb24oY2xpY2tFbGUpe1xyXG4gICAgaWYoY2xpY2tFbGUuaXNOb2RlICYmIGNsaWNrRWxlLmlzTm9kZSgpKXtcclxuICAgICAgICB0aGlzLnNlbGVjdElmQ2xpY2tFbGVJc05vdFNlbGVjdGVkKGNsaWNrRWxlKVxyXG4gICAgfVxyXG4gICAgdmFyIGFycj10aGlzLmNvcmUuJCgnOnNlbGVjdGVkJylcclxuICAgIHJldHVybiBhcnJcclxufVxyXG50b3BvbG9neURPTV9tZW51LnByb3RvdHlwZS5ub2Rlb3JlZGdlX2NoYW5nZVNlbGVjdGlvbldoZW5DbGlja0VsZW1lbnQ9ZnVuY3Rpb24oY2xpY2tFbGUpe1xyXG4gICAgaWYoY2xpY2tFbGUuaXNOb2RlKXsgLy9hdCBsZWFzdCBoYXZpbmcgaXNub2RlIGZ1bmN0aW9uIG1lYW5zIGl0IGlzIG5vZGUgb3IgZWRnZVxyXG4gICAgICAgIHRoaXMuc2VsZWN0SWZDbGlja0VsZUlzTm90U2VsZWN0ZWQoY2xpY2tFbGUpXHJcbiAgICB9XHJcbiAgICB2YXIgYXJyPXRoaXMuY29yZS4kKCc6c2VsZWN0ZWQnKVxyXG4gICAgcmV0dXJuIGFyclxyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdG9wb2xvZ3lET01fbWVudTsiLCJjb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcblxyXG5mdW5jdGlvbiB0b3BvbG9neURPTV9zaW1EYXRhU291cmNlKHBhcmVudFRvcG9sb2d5RE9NKXtcclxuICAgIHRoaXMucGFyZW50VG9wb2xvZ3lET009cGFyZW50VG9wb2xvZ3lET01cclxuICAgIHRoaXMuY29yZT10aGlzLnBhcmVudFRvcG9sb2d5RE9NLmNvcmVcclxuICAgIHRoaXMucnVubmluZ1NpbURhdGFTb3VyY2U9e31cclxuXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3NpbURhdGFTb3VyY2UucHJvdG90eXBlLnN0YXJ0U2ltTm9kZT1hc3luYyBmdW5jdGlvbihlbGUpe1xyXG4gICAgdmFyIHNpbU5vZGVJbmZvPWVsZS5kYXRhKFwib3JpZ2luYWxJbmZvXCIpXHJcbiAgICB0aGlzLnJlZnJlc2hSZWFsU2ltTm9kZUluZm9Gcm9tREJUd2luKHNpbU5vZGVJbmZvKVxyXG4gICAgXHJcbiAgICAvL2NoZWNrIGlmIGFueW9uZSBlbHNlIGlzIHVzaW5nIHRoZSBzaW11bGF0aW9uIGRhdGFzb3VyY2VcclxuICAgIGlmKHNpbU5vZGVJbmZvLmRldGFpbC5wcm9wZXJ0eVBhdGg9PVwiXCIgfHwgc2ltTm9kZUluZm8uZGV0YWlsLnByb3BlcnR5UGF0aD09bnVsbCApe1xyXG4gICAgICAgIGFsZXJ0KFwiVGhlcmUgaXMgbm8gZGVmaW5pdGlvbiBvZiBzaW11bGF0aW5nIHByb3BlcnR5XCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfVCA9IHBhcnNlRmxvYXQoc2ltTm9kZUluZm8uZGV0YWlsW1wiY3ljbGVMZW5ndGhcIl0pXHJcbiAgICB2YXIgc2FtcGxpbmcgPSBwYXJzZUZsb2F0KHNpbU5vZGVJbmZvLmRldGFpbFtcInNhbXBsZUludGVydmFsXCJdKVxyXG4gICAgdmFyIGZvcm11bGEgPSBzaW1Ob2RlSW5mby5kZXRhaWxbXCJmb3JtdWxhXCJdXHJcbiAgICBpZihfVD09MCB8fCBzYW1wbGluZz09MCB8fCBmb3JtdWxhPT1cIlwiIHx8IF9UPT1udWxsIHx8IHNhbXBsaW5nPT1udWxsIHx8IGZvcm11bGE9PW51bGwgfHwgX1Q8MCB8fCBzYW1wbGluZzwwKXtcclxuICAgICAgICBhbGVydChcIkluY29ycmVjdCBzaW11bGF0aW9uIHNldHRpbmdcIilcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF90PTA7XHJcbiAgICB2YXIgZGF0YUFycj1bXVxyXG4gICAgdmFyIF9vdXRwdXQ9bnVsbDtcclxuICAgIHdoaWxlKF90PF9UKXtcclxuICAgICAgICB2YXIgZXZhbFN0cj1mb3JtdWxhK1wiXFxuX291dHB1dFwiXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBfb3V0cHV0PWV2YWwoZXZhbFN0cikgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgICAgfWNhdGNoKGUpe31cclxuICAgICAgICBkYXRhQXJyLnB1c2goX291dHB1dClcclxuICAgICAgICBfdCs9c2FtcGxpbmdcclxuICAgIH1cclxuICAgIGlmKGRhdGFBcnIubGVuZ3RoPT0wKXtcclxuICAgICAgICBhbGVydChcIlRoZXJlIGlzIG5vIG91dHB1dCBmcm9tIHRoZSBzaW11bGF0aW9uIGZvcm11bGEuXCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYXlsb2FkPXtcclxuICAgICAgICBcInByb3BlcnR5UGF0aFN0clwiOiBzaW1Ob2RlSW5mby5kZXRhaWwucHJvcGVydHlQYXRoLmpvaW4oXCIuXCIpLCBcclxuICAgICAgICBcInR3aW5JRFwiOnNpbU5vZGVJbmZvLnR3aW5JRFxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY2hlY2tSZXN1bHQgPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9jaGVja1NpbXVsYXRpb25EYXRhU291cmNlXCIsIFwiUE9TVFwiLCBwYXlsb2FkKVxyXG4gICAgICAgIGlmKGNoZWNrUmVzdWx0LmFjY291bnQpe1xyXG4gICAgICAgICAgICBhbGVydChcIkNhbiBub3Qgc3RhcnQgc2ltdWxhdGlvbiBhcyBcIitjaGVja1Jlc3VsdC5hY2NvdW50K1wiIGlzIHNpbXVsYXRpbmcgdGhpcyBub2RlLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLi4uXCIpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHZhciBkYmxvY2tUaW1lcj1zZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vdXBkYXRlU2ltdWxhdGlvbkRhdGFTb3VyY2VcIiwgXCJQT1NUXCIsIHBheWxvYWQpXHJcbiAgICAgICAgICAgIH0sNDAwMDApIC8vZXZlcnkgNDAgc2Vjb25kLCB1cGRhdGUgdGhlIHJlY29yZCBpbiBzaW11bGF0aW9uIGNvbnRhaW5lciBhZ2FpbiwgaXQgc2VydmVzIGFzIGEgbG9jayBzbyBvdGhlciBwcGwgd2lsbCBub3Qgc3RhcnQgdGhlIHNpbXVsYXRpb24gcmVwZWF0bHlcclxuICAgICAgICAgICAgdmFyIG51bWJlckluZGV4PTA7XHJcbiAgICAgICAgICAgIHZhciBzaW1UaW1lcj1zZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgaWYobnVtYmVySW5kZXg+PWRhdGFBcnIubGVuZ3RoKSBudW1iZXJJbmRleD0wXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXREVFByb3BlcnR5KGdsb2JhbENhY2hlLnN0b3JlZFR3aW5zW3NpbU5vZGVJbmZvLnR3aW5JRF0sc2ltTm9kZUluZm8uZGV0YWlsLnByb3BlcnR5UGF0aCxkYXRhQXJyW251bWJlckluZGV4XSlcclxuICAgICAgICAgICAgICAgIG51bWJlckluZGV4KytcclxuICAgICAgICAgICAgfSxwYXJzZUludChzYW1wbGluZyoxMDAwKSlcclxuXHJcbiAgICAgICAgICAgIHRoaXMucnVubmluZ1NpbURhdGFTb3VyY2Vbc2ltTm9kZUluZm8uc2ltTm9kZU5hbWVdPXtcclxuICAgICAgICAgICAgICAgIFwiZGJsb2NrVGltZXJcIjpkYmxvY2tUaW1lcixcclxuICAgICAgICAgICAgICAgIFwic2ltVGltZXJcIjpzaW1UaW1lclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsZS5hZGRDbGFzcyhcInJ1bm5pbmdcIilcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgfVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zaW1EYXRhU291cmNlLnByb3RvdHlwZS5lZGl0RFRQcm9wZXJ0eT1mdW5jdGlvbihkdFR3aW5JbmZvLCBwYXRoLCBuZXdWYWwpIHtcclxuICAgIC8veyBcIm9wXCI6IFwiYWRkXCIsIFwicGF0aFwiOiBcIi94XCIsIFwidmFsdWVcIjogMzAgfVxyXG4gICAgdmFyIHN0ciA9IFwiXCJcclxuICAgIHBhdGguZm9yRWFjaChzZWdtZW50ID0+IHsgc3RyICs9IFwiL1wiICsgc2VnbWVudCB9KVxyXG4gICAgdmFyIGpzb25QYXRjaCA9IFt7IFwib3BcIjogXCJhZGRcIiwgXCJwYXRoXCI6IHN0ciwgXCJ2YWx1ZVwiOiBuZXdWYWwgfV1cclxuXHJcbiAgICB2YXIgdHdpbklEID0gZHRUd2luSW5mb1tcIiRkdElkXCJdXHJcbiAgICB2YXIgcGF5TG9hZCA9IHsgXCJqc29uUGF0Y2hcIjogSlNPTi5zdHJpbmdpZnkoanNvblBhdGNoKSwgXCJ0d2luSURcIjogdHdpbklEIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKHBheUxvYWQpXHJcbiAgICBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9jaGFuZ2VBdHRyaWJ1dGVcIiwgXCJQT1NUXCIsIHBheUxvYWQpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3NpbURhdGFTb3VyY2UucHJvdG90eXBlLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlPWZ1bmN0aW9uKG5vZGVJbmZvLCBwYXRoQXJyLCBuZXdWYWwpIHtcclxuICAgIGlmIChwYXRoQXJyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICB2YXIgdGhlSnNvbiA9IG5vZGVJbmZvXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gcGF0aEFycltpXVxyXG5cclxuICAgICAgICBpZiAoaSA9PSBwYXRoQXJyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgdGhlSnNvbltrZXldID0gbmV3VmFsXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGVKc29uW2tleV0gPT0gbnVsbCkgdGhlSnNvbltrZXldID0ge31cclxuICAgICAgICB0aGVKc29uID0gdGhlSnNvbltrZXldXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxudG9wb2xvZ3lET01fc2ltRGF0YVNvdXJjZS5wcm90b3R5cGUuc3RvcFNpbU5vZGU9ZnVuY3Rpb24oZWxlKXtcclxuICAgIHZhciBzaW1Ob2RlSW5mbz1lbGUuZGF0YShcIm9yaWdpbmFsSW5mb1wiKVxyXG4gICAgdGhpcy5yZWZyZXNoUmVhbFNpbU5vZGVJbmZvRnJvbURCVHdpbihzaW1Ob2RlSW5mbylcclxuICAgIGlmKCF0aGlzLnJ1bm5pbmdTaW1EYXRhU291cmNlW3NpbU5vZGVJbmZvLnNpbU5vZGVOYW1lXSkgcmV0dXJuO1xyXG4gICAgdmFyIHNpbVRpbWVyPXRoaXMucnVubmluZ1NpbURhdGFTb3VyY2Vbc2ltTm9kZUluZm8uc2ltTm9kZU5hbWVdLnNpbVRpbWVyXHJcbiAgICBpZihzaW1UaW1lcikgY2xlYXJJbnRlcnZhbChzaW1UaW1lcilcclxuICAgIHZhciBkYmxvY2tUaW1lcj10aGlzLnJ1bm5pbmdTaW1EYXRhU291cmNlW3NpbU5vZGVJbmZvLnNpbU5vZGVOYW1lXS5kYmxvY2tUaW1lclxyXG4gICAgaWYoZGJsb2NrVGltZXIpIGNsZWFySW50ZXJ2YWwoZGJsb2NrVGltZXIpXHJcblxyXG4gICAgdmFyIHBheWxvYWQ9e1xyXG4gICAgICAgIFwicHJvcGVydHlQYXRoU3RyXCI6IHNpbU5vZGVJbmZvLmRldGFpbC5wcm9wZXJ0eVBhdGguam9pbihcIi5cIiksIFxyXG4gICAgICAgIFwidHdpbklEXCI6c2ltTm9kZUluZm8udHdpbklEXHJcbiAgICB9XHJcbiAgICBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9kZWxldGVTaW11bGF0aW9uRGF0YVNvdXJjZUxvY2tcIiwgXCJQT1NUXCIsIHBheWxvYWQpXHJcblxyXG4gICAgZGVsZXRlIHRoaXMucnVubmluZ1NpbURhdGFTb3VyY2Vbc2ltTm9kZUluZm8uc2ltTm9kZU5hbWVdXHJcbiAgICBlbGUucmVtb3ZlQ2xhc3MoXCJydW5uaW5nXCIpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3NpbURhdGFTb3VyY2UucHJvdG90eXBlLnJlZnJlc2hSZWFsU2ltTm9kZUluZm9Gcm9tREJUd2luID0gZnVuY3Rpb24gKHNpbU5vZGVJbmZvKSB7XHJcbiAgICB2YXIgYXR0YWNoVHdpbklEID0gc2ltTm9kZUluZm9bXCJ0d2luSURcIl1cclxuICAgIHZhciBkYnR3aW4gPSBnbG9iYWxDYWNoZS5EQlR3aW5zW2F0dGFjaFR3aW5JRF1cclxuICAgIHZhciBzaW1Ob2RlTmFtZSA9IHNpbU5vZGVJbmZvW1wic2ltTm9kZU5hbWVcIl1cclxuICAgIHNpbU5vZGVJbmZvLmRldGFpbCA9IGRidHdpbi5zaW11bGF0ZVtzaW1Ob2RlTmFtZV1cclxufVxyXG5cclxudG9wb2xvZ3lET01fc2ltRGF0YVNvdXJjZS5wcm90b3R5cGUubmV3U2ltdWxhdG9yU291cmNlID0gZnVuY3Rpb24gKHR3aW5OYW1lKSB7XHJcbiAgICAvL2FkZCBhIHNpbXVsYXRvciBkYXRhIHNvdXJjZSBub2RlIGJlc2lkZSB0aGUgY2xpY2tlZCB0d2luXHJcbiAgICB2YXIgc2ltTm9kZU5hbWU9IGdsb2JhbENhY2hlLnV1aWR2NCgpXHJcbiAgICB2YXIgdHdpbklEPWdsb2JhbENhY2hlLnR3aW5EaXNwbGF5TmFtZU1hcFRvSURbdHdpbk5hbWVdXHJcbiAgICB2YXIgbmV3U2ltPXtcclxuICAgICAgICBcInByb3BlcnR5UGF0aFwiOm51bGxcclxuICAgIH1cclxuICAgIHRoaXMucGFyZW50VG9wb2xvZ3lET00udmlzdWFsTWFuYWdlci5zaG93U2ltdWxhdG9yU291cmNlKHR3aW5JRCxzaW1Ob2RlTmFtZSxuZXdTaW0pXHJcblxyXG4gICAgLy93cml0ZSB0aGUgc2ltdWxhdGUgbm9kZSBpbmZvbWF0aW9uIHRvIGRhdGFiYXNlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBkYnR3aW49Z2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICAgICAgdmFyIGFsbFNpbXM9IGRidHdpbi5zaW11bGF0ZXx8e31cclxuICAgICAgICBhbGxTaW1zW3NpbU5vZGVOYW1lXT1uZXdTaW1cclxuICAgICAgICBkYnR3aW4uc2ltdWxhdGU9YWxsU2ltc1xyXG4gICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3VwZGF0ZVR3aW5cIiwgXCJQT1NUXCJcclxuICAgICAgICAgICAgLCB7XCJ0d2luSURcIjp0d2luSUQsXCJ1cGRhdGVJbmZvXCI6SlNPTi5zdHJpbmdpZnkoe1wic2ltdWxhdGVcIjphbGxTaW1zfSl9XHJcbiAgICAgICAgICAgICwgXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgfVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zaW1EYXRhU291cmNlLnByb3RvdHlwZS5kZWxldGVTaW1Ob2RlPWZ1bmN0aW9uKGVsZSl7XHJcbiAgICB0aGlzLnN0b3BTaW1Ob2RlKGVsZSlcclxuICAgIHZhciBzaW1Ob2RlSW5mbz1lbGUuZGF0YShcIm9yaWdpbmFsSW5mb1wiKVxyXG4gICAgdmFyIHR3aW5JRD1zaW1Ob2RlSW5mby50d2luSURcclxuICAgIHZhciBzaW1Ob2RlTmFtZT1zaW1Ob2RlSW5mby5zaW1Ob2RlTmFtZVxyXG4gICAgdmFyIGRiVHdpbj0gZ2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICBpZihkYlR3aW4gJiYgZGJUd2luLnNpbXVsYXRlKXtcclxuICAgICAgICBkZWxldGUgZGJUd2luLnNpbXVsYXRlW3NpbU5vZGVOYW1lXVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3VwZGF0ZVR3aW5cIiwgXCJQT1NUXCJcclxuICAgICAgICAgICAgICAgICwge1widHdpbklEXCI6dHdpbklELFwidXBkYXRlSW5mb1wiOkpTT04uc3RyaW5naWZ5KHtcInNpbXVsYXRlXCI6ZGJUd2luLnNpbXVsYXRlfSl9XHJcbiAgICAgICAgICAgICAgICAsIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgICAgICB0aGlzLmNvcmUuJCgnW2lkID0gXCInK3NpbU5vZGVOYW1lKydcIl0nKS5yZW1vdmUoKSBcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB0b3BvbG9neURPTV9zaW1EYXRhU291cmNlOyIsImNvbnN0IGdsb2JhbENhY2hlID0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL2dsb2JhbENhY2hlXCIpO1xyXG5cclxuZnVuY3Rpb24gdG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyKHRvcG9sb2d5Q29yZSxkZWZhdWx0Tm9kZVNpemUpe1xyXG4gICAgdGhpcy5jb3JlPXRvcG9sb2d5Q29yZTtcclxuICAgIHRoaXMuZGVmYXVsdE5vZGVTaXplPWRlZmF1bHROb2RlU2l6ZXx8MzBcclxuICAgIHRoaXMuYmFzZU5vZGVTaXplPXRoaXMuZGVmYXVsdE5vZGVTaXplO1xyXG4gICAgdGhpcy5iYXNlU3F1YXJlU2hhcGVTaXplPXRoaXMuZGVmYXVsdE5vZGVTaXplO1xyXG4gICAgdGhpcy5ub2RlTW9kZWxWaXN1YWxBZGp1c3RtZW50PXt9XHJcbiAgICB0aGlzLmRlZmluZUhpZ2hQcmlvcml0eVN0eWxlcygpXHJcbiAgICB0aGlzLmluaXRTdHlsZSgpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3N0eWxlTWFuYWdlci5wcm90b3R5cGUuaW5pdFN0eWxlPWZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaW5pdFN0eWxlQXJyPVsgLy8gdGhlIHN0eWxlc2hlZXQgZm9yIHRoZSBncmFwaFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlJyxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjp0aGlzLmRlZmF1bHROb2RlU2l6ZSxcImhlaWdodFwiOnRoaXMuZGVmYXVsdE5vZGVTaXplLFxyXG4gICAgICAgICAgICAgICAgJ2xhYmVsJzogJ2RhdGEoaWQpJyxcclxuICAgICAgICAgICAgICAgICdvcGFjaXR5JzowLjksXHJcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplJzpcIjEycHhcIixcclxuICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6J0dlbmV2YSwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZidcclxuICAgICAgICAgICAgICAgIC8vLCdiYWNrZ3JvdW5kLWltYWdlJzogZnVuY3Rpb24oZWxlKXsgcmV0dXJuIFwiaW1hZ2VzL2NhdC5wbmdcIjsgfVxyXG4gICAgICAgICAgICAgICAgLy8sJ2JhY2tncm91bmQtZml0JzonY29udGFpbicgLy9jb3ZlclxyXG4gICAgICAgICAgICAgICAgLy8nYmFja2dyb3VuZC1jb2xvcic6IGZ1bmN0aW9uKCBlbGUgKXsgcmV0dXJuIGVsZS5kYXRhKCdiZycpIH1cclxuICAgICAgICAgICAgICAgICwnYmFja2dyb3VuZC13aWR0aCc6Jzc1JSdcclxuICAgICAgICAgICAgICAgICwnYmFja2dyb3VuZC1oZWlnaHQnOic3NSUnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdlZGdlJyxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICd3aWR0aCc6MixcclxuICAgICAgICAgICAgICAgICdsaW5lLWNvbG9yJzogJyM4ODgnLFxyXG4gICAgICAgICAgICAgICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICcjNTU1JyxcclxuICAgICAgICAgICAgICAgICd0YXJnZXQtYXJyb3ctc2hhcGUnOiAndHJpYW5nbGUnLFxyXG4gICAgICAgICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjOTk5JyxcclxuICAgICAgICAgICAgICAgICdzb3VyY2UtYXJyb3ctc2hhcGUnOiAnY2lyY2xlJyxcclxuICAgICAgICAgICAgICAgICdzb3VyY2UtYXJyb3ctZmlsbCc6J2hvbGxvdycsXHJcbiAgICAgICAgICAgICAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcclxuICAgICAgICAgICAgICAgICdhcnJvdy1zY2FsZSc6MC42XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtzZWxlY3RvcjogJ25vZGUuaG92ZXInLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOjAuNVxyXG4gICAgICAgIH19LFxyXG4gICAgICAgIHtzZWxlY3RvcjogJ2VkZ2UuaG92ZXInLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICd3aWR0aCc6MTBcclxuICAgICAgICB9fSxcclxuICAgICAgICB7c2VsZWN0b3I6ICdub2RlW21vZGVsSUQgPSBcIl9maXhlZF9zaW11bGF0aW9uRGF0YVNvdXJjZVwiXScsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgJ3NoYXBlJzoncmVjdGFuZ2xlJ1xyXG4gICAgICAgICAgICAsJ2JhY2tncm91bmQtZmlsbCc6ICdzb2xpZCdcclxuICAgICAgICAgICAgLCdiYWNrZ3JvdW5kLWNvbG9yJzogJ3doaXRlJyBcclxuICAgICAgICAgICAgLCdiYWNrZ3JvdW5kLWltYWdlJzp0aGlzLmRhdGFTb3VyY2VTVkcoKVxyXG4gICAgICAgICAgICAsJ2JvcmRlci1vcGFjaXR5JzoxXHJcbiAgICAgICAgICAgICwndGV4dC1vcGFjaXR5JzogMFxyXG4gICAgICAgICAgICAsJ2JvcmRlci13aWR0aCc6MVxyXG4gICAgICAgICAgICAsJ2JvcmRlci1jb2xvcic6J2RhcmtHcmF5J1xyXG4gICAgICAgIH19LFxyXG4gICAgICAgIHtzZWxlY3RvcjogJ2VkZ2Vbc291cmNlTW9kZWwgPSBcIl9maXhlZF9zaW11bGF0aW9uRGF0YVNvdXJjZVwiXScsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgJ3dpZHRoJzoyLFxyXG4gICAgICAgICAgICAnc291cmNlLWFycm93LXNoYXBlJzogJ2NpcmNsZScsXHJcbiAgICAgICAgICAgICd0YXJnZXQtYXJyb3ctc2hhcGUnOiAnY2lyY2xlJyxcclxuICAgICAgICAgICAgJ2xpbmUtY29sb3InOidncmF5JyxcclxuICAgICAgICAgICAgJ2xpbmUtc3R5bGUnOiAnZGFzaGVkJ1xyXG4gICAgICAgICAgICAsJ2xpbmUtZGFzaC1wYXR0ZXJuJzpbOCw4XVxyXG4gICAgICAgIH19XHJcbiAgICBdXHJcbiAgICB0aGlzLnVwZGF0ZVN0eWxlU2hlZXQoaW5pdFN0eWxlQXJyKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLmRlZmluZUhpZ2hQcmlvcml0eVN0eWxlcz1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5oaWdoZXN0U3R5bGVBcnI9IFtcclxuICAgICAgICB7c2VsZWN0b3I6J25vZGUuY2FsY0lucHV0JyAsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICdib3JkZXItY29sb3InOiBcInJlZFwiLFxyXG4gICAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMSxcclxuICAgICAgICAgICAgJ2JhY2tncm91bmQtZmlsbCc6ICdsaW5lYXItZ3JhZGllbnQnLFxyXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycyc6IFsncmVkJywgJ3JlZCcsICd3aGl0ZScsIFwid2hpdGVcIiwgXCJyZWRcIl0sXHJcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogWycwJScsICc1MCUnLCAnNTElJywgXCI5MCVcIiwgXCI5MSVcIl1cclxuICAgICAgICB9fSxcclxuICAgICAgICB7c2VsZWN0b3I6J25vZGUuY2FsY091dHB1dCcgLCBzdHlsZToge1xyXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogXCJibHVlXCIsXHJcbiAgICAgICAgICAgICdib3JkZXItd2lkdGgnOiAxLFxyXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1maWxsJzogJ2xpbmVhci1ncmFkaWVudCcsXHJcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJzogWydibHVlJywgJ2JsdWUnLCAnd2hpdGUnLCBcIndoaXRlXCIsIFwiYmx1ZVwiXSxcclxuICAgICAgICAgICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiBbJzAlJywgJzUwJScsICc1MSUnLCBcIjkwJVwiLCBcIjkxJVwiXVxyXG4gICAgICAgIH19LFxyXG4gICAgICAgIHtzZWxlY3RvcjonZWRnZS5jYWxjSW5wdXQnICwgc3R5bGU6e1xyXG4gICAgICAgICAgICAnd2lkdGgnOiAnNScsXHJcbiAgICAgICAgICAgICdsaW5lLWNvbG9yJzogJ3JlZCcsXHJcbiAgICAgICAgICAgICd0YXJnZXQtbGFiZWwnOiAnZGF0YShwcGF0aCknLFxyXG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzExcHgnLFxyXG4gICAgICAgICAgICAndGFyZ2V0LXRleHQtb2Zmc2V0JzogJ2RhdGEocHBhdGhPZmZzZXQpJyxcclxuICAgICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXHJcbiAgICAgICAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMSxcclxuICAgICAgICAgICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMSxcclxuICAgICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJzogJzJweCcsXHJcbiAgICAgICAgICAgICdjb2xvcic6ICdncmF5JyxcclxuICAgICAgICAgICAgJ3RleHQtYm9yZGVyLWNvbG9yJzogJ2dyYXknXHJcbiAgICAgICAgfSB9LFxyXG4gICAgICAgIHtzZWxlY3RvcjonZWRnZS5jYWxjT3V0cHV0JyAsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICd3aWR0aCc6ICc1JyxcclxuICAgICAgICAgICAgJ2xpbmUtY29sb3InOiAnYmx1ZScsXHJcbiAgICAgICAgICAgICdzb3VyY2UtbGFiZWwnOiAnZGF0YShwcGF0aCknLFxyXG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzExcHgnLFxyXG4gICAgICAgICAgICAnc291cmNlLXRleHQtb2Zmc2V0JzogJ2RhdGEocHBhdGhPZmZzZXQpJyxcclxuICAgICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXHJcbiAgICAgICAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMSxcclxuICAgICAgICAgICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMSxcclxuICAgICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJzogJzJweCcsXHJcbiAgICAgICAgICAgICdjb2xvcic6ICdncmF5JyxcclxuICAgICAgICAgICAgJ3RleHQtYm9yZGVyLWNvbG9yJzogJ2dyYXknXHJcbiAgICAgICAgfX0sXHJcbiAgICAgICAge3NlbGVjdG9yOidlZGdlOnNlbGVjdGVkJyAsIHN0eWxlOntcclxuICAgICAgICAgICAgJ3dpZHRoJzogOCxcclxuICAgICAgICAgICAgJ2xpbmUtY29sb3InOiAncmVkJyxcclxuICAgICAgICAgICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICdyZWQnLFxyXG4gICAgICAgICAgICAnc291cmNlLWFycm93LWNvbG9yJzogJ3JlZCcsXHJcbiAgICAgICAgICAgICdsaW5lLWZpbGwnOiBcImxpbmVhci1ncmFkaWVudFwiLFxyXG4gICAgICAgICAgICAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycyc6IFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdyddLFxyXG4gICAgICAgICAgICAnbGluZS1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6IFsnMCUnLCAnNzAlJywgJzEwMCUnXVxyXG4gICAgICAgIH0gfSxcclxuICAgICAgICB7c2VsZWN0b3I6J25vZGU6c2VsZWN0ZWQnICwgc3R5bGU6IHtcclxuICAgICAgICAgICAgJ2JvcmRlci1jb2xvcic6IFwicmVkXCIsXHJcbiAgICAgICAgICAgICdib3JkZXItd2lkdGgnOiAyLFxyXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1maWxsJzogJ3JhZGlhbC1ncmFkaWVudCcsXHJcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJzogWydjeWFuJywgJ21hZ2VudGEnLCAneWVsbG93J10sXHJcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogWycwJScsICc1MCUnLCAnNjAlJ11cclxuICAgICAgICB9fSxcclxuICAgICAgICB7c2VsZWN0b3I6ICdub2RlW21vZGVsSUQgPSBcIl9maXhlZF9zaW11bGF0aW9uRGF0YVNvdXJjZVwiXS5ydW5uaW5nJyxcclxuICAgICAgICBzdHlsZTp7XHJcbiAgICAgICAgICAgICdib3JkZXItd2lkdGgnOjNcclxuICAgICAgICAgICAgLCdib3JkZXItY29sb3InOicjY2RkYzM5J1xyXG4gICAgICAgIH19XHJcbiAgICBdXHJcbiAgICB0aGlzLmhpZ2hlc3RTdHlsZVNlbGVjdG9ycz17fVxyXG4gICAgdGhpcy5oaWdoZXN0U3R5bGVBcnIuZm9yRWFjaCgob25lU3R5bGUpPT57dGhpcy5oaWdoZXN0U3R5bGVTZWxlY3RvcnNbb25lU3R5bGUuc2VsZWN0b3JdPTF9KVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1vZGVsVHdpbkNvbG9yPWZ1bmN0aW9uKG1vZGVsSUQsY29sb3JDb2RlLHNlY29uZENvbG9yQ29kZSl7XHJcbiAgICB2YXIgc3R5bGVKc29uID0gdGhpcy5jb3JlLnN0eWxlKCkuanNvbigpO1xyXG4gICAgdmFyIGFycj1bXVxyXG4gICAgZm9yKHZhciBpbmQgaW4gc3R5bGVKc29uKXtcclxuICAgICAgICBhcnIucHVzaChzdHlsZUpzb25baW5kXS5zZWxlY3RvcilcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3R5bGVTZWxlY3Rvcj0nbm9kZVttb2RlbElEID0gXCInICsgbW9kZWxJRCArICdcIl0nXHJcbiAgICB2YXIgc3R5bGVPYmo9bnVsbFxyXG4gICAgaWYgKHNlY29uZENvbG9yQ29kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYoY29sb3JDb2RlPT1cIm5vbmVcIil7XHJcbiAgICAgICAgICAgIHN0eWxlT2JqPXsgJ2JhY2tncm91bmQtZmlsbCc6ICdzb2xpZCcsJ2JhY2tncm91bmQtY29sb3InOiAnZGFya0dyYXknLCdiYWNrZ3JvdW5kLW9wYWNpdHknOjAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBzdHlsZU9iaj17ICdiYWNrZ3JvdW5kLWZpbGwnOiAnc29saWQnLCdiYWNrZ3JvdW5kLWNvbG9yJzogY29sb3JDb2RlICwnYmFja2dyb3VuZC1vcGFjaXR5JzoxfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sb3JDb2RlPWNvbG9yQ29kZXx8XCJkYXJrR3JheVwiXHJcbiAgICAgICAgaWYoY29sb3JDb2RlPT1cIm5vbmVcIikgY29sb3JDb2RlPVwiZGFya0dyYXlcIlxyXG4gICAgICAgIHN0eWxlT2JqPXtcclxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWZpbGwnOiAnbGluZWFyLWdyYWRpZW50JyxcclxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJzogW2NvbG9yQ29kZSwgY29sb3JDb2RlLCBzZWNvbmRDb2xvckNvZGVdLFxyXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiBbJzAlJywgJzUwJScsICc1MSUnXVxyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihzdHlsZU9iaikgdGhpcy51cGRhdGVTdHlsZVNoZWV0KFt7c2VsZWN0b3I6c3R5bGVTZWxlY3RvcixzdHlsZTpzdHlsZU9ian1dKSBcclxufVxyXG5cclxudG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTdHlsZVNoZWV0PWZ1bmN0aW9uKHN0eWxlQXJyKXtcclxuICAgIC8vcmVzZXJ2ZSB0aGUgdHdvIHN0eWxlcyBvZiBlZGdlZWRpdGluZyBwbHVnaW4gZmlyc3QsIHJpZ2h0IG5vdyB0aGVyZSBpcyBubyBiZXR0ZXIgd2F5IHRvIHJlc2VydmUgdGhlbVxyXG4gICAgdmFyIGFsbFN0eWxlPXRoaXMuY29yZS5zdHlsZSgpXHJcbiAgICB2YXIgZWRnZUJlbmRTdHlsZT1udWxsXHJcbiAgICB2YXIgZWRnZUNvbnRyb2xTdHlsZT1udWxsXHJcbiAgICBmb3IodmFyIGluZCBpbiBhbGxTdHlsZSl7XHJcbiAgICAgICAgaWYodHlwZW9mKGFsbFN0eWxlW2luZF0pIT1cIm9iamVjdFwiKSBjb250aW51ZVxyXG4gICAgICAgIGlmKCFhbGxTdHlsZVtpbmRdLnNlbGVjdG9yKSBjb250aW51ZVxyXG4gICAgICAgIHZhciBzdHI9YWxsU3R5bGVbaW5kXS5zZWxlY3Rvci5pbnB1dFRleHRcclxuICAgICAgICBpZihzdHI9PVwiLmVkZ2ViZW5kZWRpdGluZy1oYXNiZW5kcG9pbnRzXCIpe1xyXG4gICAgICAgICAgICBlZGdlQmVuZFN0eWxlPWFsbFN0eWxlW2luZF1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoc3RyPT1cIi5lZGdlY29udHJvbGVkaXRpbmctaGFzY29udHJvbHBvaW50c1wiKXtcclxuICAgICAgICAgICAgZWRnZUNvbnRyb2xTdHlsZT1hbGxTdHlsZVtpbmRdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vZG8gc3R5bGUgbWVyZ2luZ1xyXG4gICAgdmFyIG1lcmdlU2VsZWN0b3I9e31cclxuICAgIHN0eWxlQXJyLmZvckVhY2goZWxlPT57XHJcbiAgICAgICAgbWVyZ2VTZWxlY3RvcltlbGUuc2VsZWN0b3JdPWVsZS5zdHlsZVxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgc3R5bGVKc29uID0gdGhpcy5jb3JlLnN0eWxlKCkuanNvbigpO1xyXG4gICAgdmFyIGFycj1bXVxyXG4gICAgZm9yKHZhciBpbmQgaW4gc3R5bGVKc29uKXtcclxuICAgICAgICBpZihtZXJnZVNlbGVjdG9yW3N0eWxlSnNvbltpbmRdLnNlbGVjdG9yXSkge1xyXG4gICAgICAgICAgICB2YXIgb2xkcz0gc3R5bGVKc29uW2luZF0uc3R5bGVcclxuICAgICAgICAgICAgdmFyIG5ld3M9bWVyZ2VTZWxlY3RvcltzdHlsZUpzb25baW5kXS5zZWxlY3Rvcl0gXHJcbiAgICAgICAgICAgIGZvcih2YXIgaW5kIGluIG9sZHMpe1xyXG4gICAgICAgICAgICAgICAgaWYobmV3c1tpbmRdIT1udWxsKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgbmV3c1tpbmRdPW9sZHNbaW5kXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG5ld3NbXCJiYWNrZ3JvdW5kLWltYWdlXCJdICYmIG5ld3NbXCJiYWNrZ3JvdW5kLWltYWdlXCJdPT1cIk5PTkVcIikgZGVsZXRlIG5ld3NbXCJiYWNrZ3JvdW5kLWltYWdlXCJdXHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfWVsc2UgaWYoc3R5bGVKc29uW2luZF0uc2VsZWN0b3I9PVwiLmVkZ2ViZW5kZWRpdGluZy1oYXNiZW5kcG9pbnRzXCIgfHxzdHlsZUpzb25baW5kXS5zZWxlY3Rvcj09XCIuZWRnZWNvbnRyb2xlZGl0aW5nLWhhc2NvbnRyb2xwb2ludHNcIiB8fCBzdHlsZUpzb25baW5kXS5zZWxlY3Rvcj09XCJub2RlLmVkZ2ViZW5kZWRpdGluZ19zY2FsZVJvdGF0ZVwiICkgY29udGludWVcclxuICAgICAgICBlbHNlIGlmKHRoaXMuaGlnaGVzdFN0eWxlU2VsZWN0b3JzW3N0eWxlSnNvbltpbmRdLnNlbGVjdG9yXSkgY29udGludWVcclxuICAgICAgICBcclxuICAgICAgICBhcnIucHVzaChzdHlsZUpzb25baW5kXSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgYXJyPWFyci5jb25jYXQoc3R5bGVBcnIpXHJcbiAgICBhcnI9YXJyLmNvbmNhdCh0aGlzLmhpZ2hlc3RTdHlsZUFycilcclxuICAgIHRoaXMuY29yZS5zdHlsZSgpLmZyb21Kc29uKGFycikudXBkYXRlKClcclxuICAgIGlmKGVkZ2VCZW5kU3R5bGUpe1xyXG4gICAgICAgIGFsbFN0eWxlPXRoaXMuY29yZS5zdHlsZSgpXHJcbiAgICAgICAgdmFyIGN1ckxlbj1hbGxTdHlsZS5sZW5ndGg7XHJcbiAgICAgICAgYWxsU3R5bGUubGVuZ3RoPWN1ckxlbisyXHJcbiAgICAgICAgYWxsU3R5bGVbY3VyTGVuXT1lZGdlQmVuZFN0eWxlXHJcbiAgICAgICAgYWxsU3R5bGVbY3VyTGVuKzFdPWVkZ2VDb250cm9sU3R5bGVcclxuICAgIH1cclxuXHJcbiAgICAvL25vZGUgc2NhbGUgcm90YXRlIHN0eWxlXHJcbiAgICB0aGlzLmNvcmUuc3R5bGUoKVxyXG4gICAgICAgIC5zZWxlY3Rvcignbm9kZS5lZGdlYmVuZGVkaXRpbmdfc2NhbGVSb3RhdGUnKVxyXG4gICAgICAgIC5zdHlsZSh7XHJcbiAgICAgICAgICAgICd3aWR0aCc6ICAoZWxlKT0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZUY9ZWxlLmRhdGEoJ3NjYWxlRmFjdG9yJyl8fDFcclxuICAgICAgICAgICAgICAgIGlmKCFlbGUuZGF0YShcIm9yaWdpbmFsV2lkdGhcIikpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZS5kYXRhKFwib3JpZ2luYWxXaWR0aFwiLGVsZS53aWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRoZVc9ZWxlLmRhdGEoXCJvcmlnaW5hbFdpZHRoXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGVXKSpzY2FsZUZcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ2hlaWdodCc6ICAoZWxlKT0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZUY9ZWxlLmRhdGEoJ3NjYWxlRmFjdG9yJyl8fDFcclxuICAgICAgICAgICAgICAgIGlmKCFlbGUuZGF0YShcIm9yaWdpbmFsSGVpZ2h0XCIpKXtcclxuICAgICAgICAgICAgICAgICAgICBlbGUuZGF0YShcIm9yaWdpbmFsSGVpZ2h0XCIsZWxlLmhlaWdodCgpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRoZUg9ZWxlLmRhdGEoXCJvcmlnaW5hbEhlaWdodFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhlSCkqc2NhbGVGXHJcbiAgICAgICAgICAgIH0sJ3NoYXBlLXJvdGF0aW9uJzogKCBlbGUgKT0+e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZWxlLmRhdGEoXCJyb3RhdGVBbmdsZVwiKXx8MClcclxuICAgICAgICAgICAgfSwndGV4dC1tYXJnaW4teCc6KGVsZSk9PntcclxuICAgICAgICAgICAgICAgIHZhciBtb2RlbElEPWVsZS5kYXRhKFwibW9kZWxJRFwiKVxyXG4gICAgICAgICAgICAgICAgdmFyIGxibE9mZnNldD10aGlzLmNhbGN1bGF0ZUxibE9mZnNldChtb2RlbElELGVsZS5kYXRhKCdzY2FsZUZhY3RvcicpfHwxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxibE9mZnNldFswXVxyXG4gICAgICAgICAgICB9LCd0ZXh0LW1hcmdpbi15JzooZWxlKT0+e1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsSUQ9ZWxlLmRhdGEoXCJtb2RlbElEXCIpXHJcbiAgICAgICAgICAgICAgICB2YXIgbGJsT2Zmc2V0PXRoaXMuY2FsY3VsYXRlTGJsT2Zmc2V0KG1vZGVsSUQsZWxlLmRhdGEoJ3NjYWxlRmFjdG9yJyl8fDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGJsT2Zmc2V0WzFdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS51cGRhdGUoKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLmFkanVzdE1vZGVsc0Jhc2VEaW1lbnNpb249ZnVuY3Rpb24oc3BlY2lmeU1vZGVsSUQpe1xyXG4gICAgdmFyIGZzPXRoaXMuZ2V0Rm9udFNpemVJbkN1cnJlbnRab29tKCk7XHJcbiAgICB0aGlzLmJhc2VTcXVhcmVTaGFwZVNpemU9dGhpcy5nZXROb2RlU2l6ZUluQ3VycmVudFpvb20oKTtcclxuXHJcbiAgICBpZighc3BlY2lmeU1vZGVsSUQpe1xyXG4gICAgICAgIHZhciBhcnI9W1xyXG4gICAgICAgICAgICB7c2VsZWN0b3I6J25vZGUnLHN0eWxlOnsgJ2ZvbnQtc2l6ZSc6IGZzLCB3aWR0aDogdGhpcy5iYXNlU3F1YXJlU2hhcGVTaXplLCBoZWlnaHQ6IHRoaXMuYmFzZVNxdWFyZVNoYXBlU2l6ZSB9fSwgLy9ub3JtYWwgbm9kZSBpcyBhIGNpcmNsZSwgd2lkdGg9aGVpZ2h0XHJcbiAgICAgICAgICAgIHtzZWxlY3Rvcjonbm9kZTpzZWxlY3RlZCcsc3R5bGU6eyAnYm9yZGVyLXdpZHRoJzogTWF0aC5jZWlsKHRoaXMuYmFzZVNxdWFyZVNoYXBlU2l6ZSAvIDE1KSB9fSxcclxuICAgICAgICBdXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBhcnI9W11cclxuICAgIH1cclxuICAgIGZvciAodmFyIG1vZGVsSUQgaW4gdGhpcy5ub2RlTW9kZWxWaXN1YWxBZGp1c3RtZW50KSB7XHJcbiAgICAgICAgaWYoc3BlY2lmeU1vZGVsSUQhPW51bGwgJiYgbW9kZWxJRCE9c3BlY2lmeU1vZGVsSUQpIGNvbnRpbnVlXHJcbiAgICAgICAgdmFyIHNpemVBZGp1c3RSYXRpbz10aGlzLm5vZGVNb2RlbFZpc3VhbEFkanVzdG1lbnRbbW9kZWxJRF0uZGltZW5zaW9uUmF0aW98fDFcclxuICAgICAgICAvL2lmIGl0cyBzaGFwZSBpcyByb3VuZC1yZWN0YW5nbGUgKGFjdHVhbGx5IGl0IGlzIHBvbHlnb24gcmVjdGFuZ2xlKSBhbmQgaXQgZG9lcyBoYXZlIGEgc3ZnIG9yIGltYWdlIGF2YXJ0YSwgdGhlbiBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoaXMgdHlwZSBvZiBub2RlcyBoYXZlIHdpZHRoIGRpZmZlcmVudCBmcm9tIGhlaWdodC4gSXQgd2lsbCBmb2xsb3cgdGhlIHdpZHRoLWhlaWdodC1yYXRpbyBvZiB0aGUgaW1hZ2Ugb3Igc3ZnXHJcbiAgICAgICAgdmFyIHRoZVNoYXBlPXRoaXMubm9kZU1vZGVsVmlzdWFsQWRqdXN0bWVudFttb2RlbElEXS5zaGFwZXx8XCJlbGxpcHNlXCJcclxuICAgICAgICBpZih0aGVTaGFwZT09XCJlbGxpcHNlXCIgfHx0aGVTaGFwZT09XCJoZXhhZ29uXCIpe1xyXG4gICAgICAgICAgICB2YXIgYmFzZVNpemU9dGhpcy5iYXNlU3F1YXJlU2hhcGVTaXplXHJcbiAgICAgICAgfWVsc2UgYmFzZVNpemU9dGhpcy5iYXNlTm9kZVNpemVcclxuICAgICAgICB2YXIgbmV3Vz1NYXRoLmNlaWwoc2l6ZUFkanVzdFJhdGlvICogYmFzZVNpemUpXHJcbiAgICAgICAgdmFyIG5ld0g9bmV3V1xyXG4gICAgICAgIHZhciBiZ1JhdGlvVz03NVxyXG4gICAgICAgIHZhciBiZ1JhdGlvSD03NVxyXG4gICAgICAgIHZhciB2aXN1YWxKc29uPWdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFttb2RlbElEXVxyXG4gICAgICAgIHZhciBjdXJyZW50U2hhcGU9dGhpcy5ub2RlTW9kZWxWaXN1YWxBZGp1c3RtZW50W21vZGVsSURdLnNoYXBlXHJcbiAgICAgICAgaWYoY3VycmVudFNoYXBlPT1cInJlY3RhbmdsZVwiICYmIHZpc3VhbEpzb24uYXZhcnRhKXtcclxuICAgICAgICAgICAgdmFyIHZpc3VhbEpzb249Z2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsW21vZGVsSURdXHJcbiAgICAgICAgICAgIGlmKHZpc3VhbEpzb24uYXZhcnRhSGVpZ2h0ICYmIHZpc3VhbEpzb24uYXZhcnRhSGVpZ2h0IT0wKXtcclxuICAgICAgICAgICAgICAgIHZhciB3aFJhdGlvPXZpc3VhbEpzb24uYXZhcnRhV2lkdGgvdmlzdWFsSnNvbi5hdmFydGFIZWlnaHRcclxuICAgICAgICAgICAgICAgIGlmKHdoUmF0aW8+MSkgbmV3Vz1uZXdIKndoUmF0aW9cclxuICAgICAgICAgICAgICAgIGVsc2UgbmV3SD1uZXdXL3doUmF0aW9cclxuICAgICAgICAgICAgICAgIGJnUmF0aW9XPWJnUmF0aW9IPScxMDAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSBpZih2aXN1YWxKc29uLmF2YXJ0YSAmJiB2aXN1YWxKc29uLmF2YXJ0YUhlaWdodCAmJiB2aXN1YWxKc29uLmF2YXJ0YUhlaWdodCE9MCl7XHJcbiAgICAgICAgICAgIHZhciB3aFJhdGlvPXZpc3VhbEpzb24uYXZhcnRhV2lkdGgvdmlzdWFsSnNvbi5hdmFydGFIZWlnaHRcclxuICAgICAgICAgICAgaWYod2hSYXRpbz4xKSBiZ1JhdGlvSD1iZ1JhdGlvVy93aFJhdGlvXHJcbiAgICAgICAgICAgIGVsc2UgYmdSYXRpb1cgPSBiZ1JhdGlvSCAqIHdoUmF0aW9cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhuZXdXLG5ld0gsbW9kZWxJRClcclxuICAgICAgICAvL2ZvciBhbnkgbm9kZSB0aGF0IGFscmVhZHkgaGFzIGVkZ2ViZW5kZWRpdGluZ19zY2FsZVJvdGF0ZSwgYWxzbyBtb2RpZnkgaXRzIG9yaWdpbmFsV2lkdGggYW5kIG9yaWdpbmFsSGVpZ2h0XHJcbiAgICAgICAgdGhpcy5jb3JlLm5vZGVzKGBbbW9kZWxJRCA9IFwiJHttb2RlbElEfVwiXWApLmZvckVhY2goZWxlID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZS5kYXRhKFwib3JpZ2luYWxXaWR0aFwiKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbGUuZGF0YShcIm9yaWdpbmFsV2lkdGhcIiwgbmV3VylcclxuICAgICAgICAgICAgICAgIGVsZS5kYXRhKFwib3JpZ2luYWxIZWlnaHRcIiwgbmV3SClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxibE9mZnNldD10aGlzLmNhbGN1bGF0ZUxibE9mZnNldChtb2RlbElEKVxyXG4gICAgICAgIGFyci5wdXNoKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdub2RlW21vZGVsSUQgPSBcIicgKyBtb2RlbElEICsgJ1wiXScsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3VywgaGVpZ2h0OiBuZXdILCAnYmFja2dyb3VuZC13aWR0aCc6IGJnUmF0aW9XICsgXCIlXCIsICdiYWNrZ3JvdW5kLWhlaWdodCc6IGJnUmF0aW9IICsgXCIlXCJcclxuICAgICAgICAgICAgICAgICxcInRleHQtbWFyZ2luLXhcIjpsYmxPZmZzZXRbMF0sJ3RleHQtbWFyZ2luLXknOmxibE9mZnNldFsxXSBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVN0eWxlU2hlZXQoYXJyKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLmNhbGN1bGF0ZUxibE9mZnNldD1mdW5jdGlvbihtb2RlbElELHNjYWxlRil7XHJcbiAgICB2YXIgdmlzdWFsSnNvbj1nbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxbbW9kZWxJRF1cclxuICAgIGlmKCF2aXN1YWxKc29uKSByZXR1cm4gWzAsMF1cclxuICAgIHZhciB4b2ZmPXZpc3VhbEpzb24ubGFiZWxYfHwwXHJcbiAgICB2YXIgeW9mZj12aXN1YWxKc29uLmxhYmVsWXx8MFxyXG4gICAgdmFyIGRpbWVuc2lvblJhdGlvPSB2aXN1YWxKc29uLmRpbWVuc2lvblJhdGlvfHwxIFxyXG4gICAgdmFyIHRoZVNoYXBlID0gdmlzdWFsSnNvbi5zaGFwZSB8fCBcImVsbGlwc2VcIlxyXG4gICAgaWYgKHRoZVNoYXBlID09IFwiZWxsaXBzZVwiIHx8IHRoZVNoYXBlID09IFwiaGV4YWdvblwiKSB7XHJcbiAgICAgICAgdmFyIGJhc2VTaXplID0gdGhpcy5iYXNlU3F1YXJlU2hhcGVTaXplXHJcbiAgICB9IGVsc2UgYmFzZVNpemUgPSB0aGlzLmJhc2VOb2RlU2l6ZVxyXG4gICAgdmFyIGJhc2VOb2RlQWRqdXN0Uj0gYmFzZVNpemUvMzBcclxuICAgIHZhciBzY2FsZUY9c2NhbGVGfHwxXHJcbiAgICByZXR1cm4gW3hvZmYqZGltZW5zaW9uUmF0aW8qYmFzZU5vZGVBZGp1c3RSKnNjYWxlRix5b2ZmKmRpbWVuc2lvblJhdGlvKmJhc2VOb2RlQWRqdXN0UipzY2FsZUYgXSBcclxufVxyXG5cclxudG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVNb2RlbEF2YXJ0YT1mdW5jdGlvbihtb2RlbElELGRhdGFVcmwpe1xyXG4gICAgaWYoIXRoaXMubm9kZU1vZGVsVmlzdWFsQWRqdXN0bWVudFttb2RlbElEXSl0aGlzLm5vZGVNb2RlbFZpc3VhbEFkanVzdG1lbnRbbW9kZWxJRF09e31cclxuICAgIHRoaXMubm9kZU1vZGVsVmlzdWFsQWRqdXN0bWVudFttb2RlbElEXS5hdmFydGE9ZGF0YVVybFxyXG5cclxuICAgIHRyeXtcclxuICAgICAgICBpZihkYXRhVXJsPT1udWxsKSBkYXRhVXJsPVwiTk9ORVwiXHJcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZVNoZWV0KFt7c2VsZWN0b3I6J25vZGVbbW9kZWxJRCA9IFwiJyttb2RlbElEKydcIl0nLHN0eWxlOnsnYmFja2dyb3VuZC1pbWFnZSc6IGRhdGFVcmx9fSBdKVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1vZGVsVHdpblNoYXBlPWZ1bmN0aW9uKG1vZGVsSUQsc2hhcGUpe1xyXG4gICAgdmFyIG5ld1N0eWxlXHJcbiAgICBpZighdGhpcy5ub2RlTW9kZWxWaXN1YWxBZGp1c3RtZW50W21vZGVsSURdKXRoaXMubm9kZU1vZGVsVmlzdWFsQWRqdXN0bWVudFttb2RlbElEXT17fVxyXG4gICAgdGhpcy5ub2RlTW9kZWxWaXN1YWxBZGp1c3RtZW50W21vZGVsSURdLnNoYXBlPXNoYXBlXHJcbiAgICBpZihzaGFwZT09XCJoZXhhZ29uXCIpe1xyXG4gICAgICAgIHZhciBwb2x5Z29uPVswLC0xLDAuODY2LC0wLjUsMC44NjYsMC41LDAsMSwtMC44NjYsMC41LC0wLjg2NiwtMC41XVxyXG4gICAgICAgIG5ld1N0eWxlPXtzZWxlY3Rvcjonbm9kZVttb2RlbElEID0gXCInK21vZGVsSUQrJ1wiXScsc3R5bGU6eydzaGFwZSc6ICdwb2x5Z29uJywnc2hhcGUtcG9seWdvbi1wb2ludHMnOnBvbHlnb259fVxyXG4gICAgfWVsc2UgaWYoc2hhcGU9PVwicmVjdGFuZ2xlXCIpe1xyXG4gICAgICAgIG5ld1N0eWxlPXtzZWxlY3Rvcjonbm9kZVttb2RlbElEID0gXCInK21vZGVsSUQrJ1wiXScsc3R5bGU6eydzaGFwZSc6ICdyZWN0YW5nbGUnfX1cclxuICAgIH1lbHNle1xyXG4gICAgICAgIG5ld1N0eWxlPXtzZWxlY3Rvcjonbm9kZVttb2RlbElEID0gXCInK21vZGVsSUQrJ1wiXScsc3R5bGU6eydzaGFwZSc6IHNoYXBlfX1cclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlU3R5bGVTaGVldChbbmV3U3R5bGVdKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1vZGVsVHdpbkRpbWVuc2lvbj1mdW5jdGlvbihtb2RlbElELGRpbWVuc2lvblJhdGlvKXtcclxuICAgIGlmKCF0aGlzLm5vZGVNb2RlbFZpc3VhbEFkanVzdG1lbnRbbW9kZWxJRF0pdGhpcy5ub2RlTW9kZWxWaXN1YWxBZGp1c3RtZW50W21vZGVsSURdPXt9XHJcbiAgICB0aGlzLm5vZGVNb2RlbFZpc3VhbEFkanVzdG1lbnRbbW9kZWxJRF0uZGltZW5zaW9uUmF0aW89cGFyc2VGbG9hdChkaW1lbnNpb25SYXRpbylcclxuICAgIHRoaXMuYWRqdXN0TW9kZWxzQmFzZURpbWVuc2lvbihtb2RlbElEKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1vZGVsVHdpbkxhYmVsT2Zmc2V0ID0gZnVuY3Rpb24gKG1vZGVsSUQpIHtcclxuICAgIHRoaXMuYWRqdXN0TW9kZWxzQmFzZURpbWVuc2lvbihtb2RlbElEKVxyXG59XHJcblxyXG50b3BvbG9neURPTV9zdHlsZU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVJlbGF0aW9uc2hpcENvbG9yPWZ1bmN0aW9uKHNyY01vZGVsSUQscmVsYXRpb25zaGlwTmFtZSxjb2xvckNvZGUpe1xyXG4gICAgdGhpcy51cGRhdGVTdHlsZVNoZWV0KFtcclxuICAgICAgICB7c2VsZWN0b3I6J2VkZ2Vbc291cmNlTW9kZWwgPSBcIicrc3JjTW9kZWxJRCsnXCJdW3JlbGF0aW9uc2hpcE5hbWUgPSBcIicrcmVsYXRpb25zaGlwTmFtZSsnXCJdJywgc3R5bGU6eydsaW5lLWNvbG9yJzogY29sb3JDb2RlfX1cclxuICAgIF0pXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3N0eWxlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUmVsYXRpb25zaGlwU2hhcGU9ZnVuY3Rpb24oc3JjTW9kZWxJRCxyZWxhdGlvbnNoaXBOYW1lLHNoYXBlKXtcclxuICAgIHZhciBuZXdTdHlsZVxyXG4gICAgaWYoc2hhcGU9PVwic29saWRcIil7XHJcbiAgICAgICAgbmV3U3R5bGU9e3NlbGVjdG9yOidlZGdlW3NvdXJjZU1vZGVsID0gXCInK3NyY01vZGVsSUQrJ1wiXVtyZWxhdGlvbnNoaXBOYW1lID0gXCInK3JlbGF0aW9uc2hpcE5hbWUrJ1wiXScsIHN0eWxlOnsnbGluZS1zdHlsZSc6IHNoYXBlfX1cclxuICAgIH1lbHNlIGlmKHNoYXBlPT1cImRvdHRlZFwiKXtcclxuICAgICAgICBuZXdTdHlsZT17c2VsZWN0b3I6J2VkZ2Vbc291cmNlTW9kZWwgPSBcIicrc3JjTW9kZWxJRCsnXCJdW3JlbGF0aW9uc2hpcE5hbWUgPSBcIicrcmVsYXRpb25zaGlwTmFtZSsnXCJdJywgc3R5bGU6eydsaW5lLXN0eWxlJzogJ2Rhc2hlZCcsJ2xpbmUtZGFzaC1wYXR0ZXJuJzpbOCw4XX19XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVN0eWxlU2hlZXQoW25ld1N0eWxlXSkgICAgXHJcbn1cclxudG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVSZWxhdGlvbnNoaXBXaWR0aD1mdW5jdGlvbihzcmNNb2RlbElELHJlbGF0aW9uc2hpcE5hbWUsZWRnZVdpZHRoKXtcclxuICAgIHZhciBhcnI9W1xyXG4gICAgICAgIHtzZWxlY3RvcjonZWRnZVtzb3VyY2VNb2RlbCA9IFwiJytzcmNNb2RlbElEKydcIl1bcmVsYXRpb25zaGlwTmFtZSA9IFwiJytyZWxhdGlvbnNoaXBOYW1lKydcIl0nLHN0eWxlOnsnd2lkdGgnOnBhcnNlRmxvYXQoZWRnZVdpZHRoKX19LFxyXG4gICAgICAgIHtzZWxlY3RvcjonZWRnZS5ob3Zlcltzb3VyY2VNb2RlbCA9IFwiJytzcmNNb2RlbElEKydcIl1bcmVsYXRpb25zaGlwTmFtZSA9IFwiJytyZWxhdGlvbnNoaXBOYW1lKydcIl0nLHN0eWxlOnsnd2lkdGgnOnBhcnNlRmxvYXQoZWRnZVdpZHRoKSsxMH19LFxyXG4gICAgXVxyXG4gICAgdGhpcy51cGRhdGVTdHlsZVNoZWV0KGFycilcclxufVxyXG5cclxudG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRGb250U2l6ZUluQ3VycmVudFpvb209ZnVuY3Rpb24oKXtcclxuICAgIHZhciBjdXJab29tPXRoaXMuY29yZS56b29tKClcclxuICAgIGlmKGN1clpvb20+MSl7XHJcbiAgICAgICAgdmFyIG1heEZTPTEyXHJcbiAgICAgICAgdmFyIG1pbkZTPTVcclxuICAgICAgICB2YXIgcmF0aW89IChtYXhGUy9taW5GUy0xKS85KihjdXJab29tLTEpKzFcclxuICAgICAgICB2YXIgZnM9TWF0aC5jZWlsKG1heEZTL3JhdGlvKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdmFyIG1heEZTPTEyMFxyXG4gICAgICAgIHZhciBtaW5GUz0xMlxyXG4gICAgICAgIHZhciByYXRpbz0gKG1heEZTL21pbkZTLTEpLzkqKDEvY3VyWm9vbS0xKSsxXHJcbiAgICAgICAgdmFyIGZzPU1hdGguY2VpbChtaW5GUypyYXRpbylcclxuICAgIH1cclxuICAgIHJldHVybiBmcztcclxufVxyXG5cclxudG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyLnByb3RvdHlwZS5nZXROb2RlU2l6ZUluQ3VycmVudFpvb209ZnVuY3Rpb24oKXtcclxuICAgIHZhciBjdXJab29tPXRoaXMuY29yZS56b29tKClcclxuICAgIC8vY29uc29sZS5sb2coY3VyWm9vbSlcclxuICAgIC8vYmlnZ2VyIHpvb20gbWVhbnMgem9vbSBpbiBtb3JlIHRvIHRoZSBkZXRhaWxcclxuICAgIGlmKGN1clpvb20+MSl7Ly9zY2FsZSB1cCBidXQgbm90IHRvbyBtdWNoXHJcbiAgICAgICAgdmFyIHJhdGlvPSAoY3VyWm9vbS0xKSooMi0xKS80KzFcclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGVmYXVsdE5vZGVTaXplL3JhdGlvKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdmFyIHJhdGlvPSAoMS9jdXJab29tLTEpKigyLTEpLzQrMVxyXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kZWZhdWx0Tm9kZVNpemUqcmF0aW8pXHJcbiAgICB9XHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3N0eWxlTWFuYWdlci5wcm90b3R5cGUuZGF0YVNvdXJjZVNWRz1mdW5jdGlvbigpe1xyXG4gICAgdmFyIHN2Z1N0cj0gJzxzdmcgZW5hYmxlLWJhY2tncm91bmQ9XCIwIDAgNTEyIDUxMlwiIGhlaWdodD1cIjUxMlwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHdpZHRoPVwiNTEyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJtMjgyLjkzMSA0NjhjLTIzLjEzMSAwLTQxLjUtMTUuODk3LTQ0LjgwNC0zOC44OTdsLTQ4Ljc3Mi0zNDEuMjI2Yy0uMTc5LTEuMjQ4LS41NTctMy44NzUtNC40ODUtMy44NzctLjAwMiAwLS4wMDUgMC0uMDA3IDAtMy45MjMgMC00LjMwMyAyLjYyNC00LjQ4NiAzLjg4NWwtMzQuNzM2IDI0My41MzFjLTMuMTU4IDIxLjc0My0yMC42NTMgMzcuNTctNDIuNTUxIDM4LjUzOS0yMS45MDEuOTY3LTQwLjcyMi0xMy4yNTItNDUuNzc2LTM0LjU4MS0uMDE5LS4wNzctLjAzNi0uMTUzLS4wNTMtLjIzbC0xMS4yMTQtNDkuOTQ3Yy0zLjA0Ny0xMi42NjItMTQuMjI4LTIyLjE5Ny0yNi4wNDctMjIuMTk3LTExLjA0NiAwLTIwLTguOTU0LTIwLTIwczguOTU0LTIwIDIwLTIwYzMwLjM3MiAwIDU3LjcwNSAyMi4zMjEgNjQuOTkzIDUzLjA3NC4wMTkuMDc3LjAzNi4xNTMuMDUzLjIzbDExLjIxNiA0OS45NTVjLjI4MiAxLjE3MiAxLjA2NCAzLjkwNCA1LjA2IDMuNzM0IDQuMTMzLS4xODMgNC41NjQtMy4xNTcgNC43MjctNC4yNzdsMzQuNzM2LTI0My41MzFjMy4yNy0yMi41MDggMjEuMzkxLTM4LjE4NSA0NC4wNzgtMzguMTg1aC4wMzljMjIuNzA3LjAxOCA0MC44MiAxNS43MjggNDQuMDQ5IDM4LjIwNGw0OC43NzEgMzQxLjIyNWMuMTgxIDEuMjU5LjcwOCA0LjY2NiA1LjM2OSA0LjU3IDQuNzAyLS4wNzEgNS4wODYtMy40NjUgNS4yMzEtNC43NDNsNi44MDMtNjAuNDkxYzEuMjM0LTEwLjk3NyAxMS4xMzQtMTguODc3IDIyLjExLTE3LjYzOSAxMC45NzcgMS4yMzQgMTguODc0IDExLjEzMyAxNy42MzkgMjIuMTFsLTYuODA1IDYwLjUwNGMtMi42NDIgMjMuMzU0LTIwLjg5IDM5LjkwMi00NC4zNzcgNDAuMjU1LS4yNTQuMDAzLS41MDguMDA1LS43NjEuMDA1em0xNjkuMjUzLTE0Ny42MzNjLjAyLS4wNzkuMDM5LS4xNTguMDU4LS4yMzdsNy4wNjItMjkuOTY3YzMuOTAxLTE1LjQ5MyAxNy45MzktMjcuMTYzIDMyLjY5Ni0yNy4xNjMgMTEuMDQ2IDAgMjAtOC45NTQgMjAtMjBzLTguOTU0LTIwLTIwLTIwYy0zMy4xNTQgMC02My4yNDIgMjQuMjMxLTcxLjU0MiA1Ny42MTctLjAyLjA3OS0uMDM5LjE1OS0uMDU4LjIzOGwtNy4wNjMgMjkuOTc0Yy0uMjM4Ljk0Mi0uNjYyIDIuMjUzLTMuMDA4IDIuMTY3LTIuNDQ1LS4wOTYtMi42ODctMS41NDktMi44MzktMi40NThsLTE1LjY5Ni05NS43NDZjLTMuNDA4LTIwLjQ0NC0yMC4yNS0zNC4zNTQtNDAuOTc4LTMzLjc5OS0yMC43MTkuNTQ0LTM2LjgxNyAxNS4zMDgtMzkuMTQ3IDM1LjkwM2wtOC40NjkgNzQuODU1Yy0xLjI0MiAxMC45NzYgNi42NDkgMjAuODggMTcuNjI1IDIyLjEyMiAxMC45NzkgMS4yNDMgMjAuODgtNi42NDkgMjIuMTIyLTE3LjYyNWw4LjQ2OS03NC44NTVjLjAxOC0uMTUyLjAzOC0uMjc0LjA1OC0uMzY5LjIzNy0uMDUzLjU1Mi0uMDYyLjc5LS4wMjEuMDIyLjA4My4wNDYuMTg3LjA2Ny4zMTJsMTUuNjk2IDk1Ljc0NmMzLjM4OCAyMC4zMzEgMjAuMTM5IDM1LjA5NSA0MC43MzQgMzUuOTA0LjU5MS4wMjMgMS4xNzguMDM1IDEuNzY0LjAzNSAxOS44NDMgMCAzNi44MjktMTMuMjA0IDQxLjY1OS0zMi42MzN6XCIvPjwvc3ZnPidcclxuICAgIHJldHVybiAnZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJyArIGVuY29kZVVSSUNvbXBvbmVudChzdmdTdHIpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdG9wb2xvZ3lET01fc3R5bGVNYW5hZ2VyOyIsImNvbnN0IGdsb2JhbENhY2hlID0gcmVxdWlyZShcIi4uL3NoYXJlZFNvdXJjZUZpbGVzL2dsb2JhbENhY2hlXCIpXHJcblxyXG5mdW5jdGlvbiB0b3BvbG9neURPTV92aXN1YWwodG9wb2xvZ3lDb3JlKXtcclxuICAgIHRoaXMuY29yZT10b3BvbG9neUNvcmVcclxuXHJcbiAgICB2YXIgdXIgPSB0aGlzLmNvcmUudW5kb1JlZG8oe2lzRGVidWc6IGZhbHNlfSk7XHJcbiAgICB0aGlzLnVyPXVyXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3Zpc3VhbC5wcm90b3R5cGUuY2hvb3NlTGF5b3V0ID0gZnVuY3Rpb24gKGxheW91dE5hbWUpIHtcclxuICAgIGlmIChsYXlvdXROYW1lID09IFwiW05BXVwiKSB7XHJcbiAgICAgICAgdGhpcy5ub1Bvc2l0aW9uX2Nvc2UobnVsbClcclxuICAgIH0gZWxzZSBpZiAobGF5b3V0TmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGxheW91dERldGFpbCA9IGdsb2JhbENhY2hlLmxheW91dEpTT05bbGF5b3V0TmFtZV0uZGV0YWlsXHJcbiAgICAgICAgaWYgKGxheW91dERldGFpbCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TmV3TGF5b3V0V2l0aFVuZG8obGF5b3V0RGV0YWlsLCB0aGlzLmdldEN1cnJlbnRMYXlvdXREZXRhaWwoKSxudWxsLFwiY2VudGVyTm9kZXNcIilcclxuICAgICAgICAgICAgdGhpcy5jb3JlLmZpdCh0aGlzLmNvcmUubm9kZXMoKSkgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLmRpbWVuc2lvblNlbGVjdGVkTm9kZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgIHZhciByYXRpbz0xLjJcclxuICAgIHZhciBzZWxlY3RlZE5vZGVzPXRoaXMuY29yZS5ub2RlcygnOnNlbGVjdGVkJylcclxuICAgIGlmKHNlbGVjdGVkTm9kZXMuc2l6ZSgpPDIpIHJldHVybjtcclxuICAgIHZhciBib3VuZGFyeT0gc2VsZWN0ZWROb2Rlcy5ib3VuZGluZ0JveCh7aW5jbHVkZUxhYmVscyA6ZmFsc2UsaW5jbHVkZU92ZXJsYXlzIDpmYWxzZSB9KVxyXG4gICAgdmFyIGNlbnRlclg9Ym91bmRhcnlbXCJ4MVwiXStib3VuZGFyeVtcIndcIl0vMlxyXG4gICAgdmFyIGNlbnRlclk9Ym91bmRhcnlbXCJ5MVwiXStib3VuZGFyeVtcImhcIl0vMlxyXG4gICAgXHJcbiAgICB2YXIgb2xkTGF5b3V0PXt9XHJcbiAgICB2YXIgbmV3TGF5b3V0PXt9XHJcbiAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2gob25lTm9kZT0+e1xyXG4gICAgICAgIHZhciBjdXJQb3M9b25lTm9kZS5wb3NpdGlvbigpXHJcbiAgICAgICAgdmFyIG5vZGVJRD1vbmVOb2RlLmlkKClcclxuICAgICAgICBvbGRMYXlvdXRbbm9kZUlEXT1bY3VyUG9zWyd4J10sY3VyUG9zWyd5J11dXHJcbiAgICAgICAgdmFyIHhvZmZjZW50ZXI9Y3VyUG9zW1wieFwiXS1jZW50ZXJYXHJcbiAgICAgICAgdmFyIHlvZmZjZW50ZXI9Y3VyUG9zW1wieVwiXS1jZW50ZXJZXHJcbiAgICAgICAgaWYoZGlyZWN0aW9uPT1cImV4cGFuZFwiKSBuZXdMYXlvdXRbbm9kZUlEXT1bY2VudGVyWCt4b2ZmY2VudGVyKnJhdGlvLGNlbnRlclkreW9mZmNlbnRlcipyYXRpb11cclxuICAgICAgICBlbHNlIGlmKGRpcmVjdGlvbj09XCJjb21wcmVzc1wiKSBuZXdMYXlvdXRbbm9kZUlEXT1bY2VudGVyWCt4b2ZmY2VudGVyL3JhdGlvLGNlbnRlclkreW9mZmNlbnRlci9yYXRpb11cclxuICAgIH0pXHJcbiAgICB0aGlzLmFwcGx5TmV3TGF5b3V0V2l0aFVuZG8obmV3TGF5b3V0LG9sZExheW91dCxcIm9ubHlBZGp1c3ROb2RlUG9zaXRpb25cIilcclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5taXJyb3JTZWxlY3RlZE5vZGUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgc2VsZWN0ZWROb2Rlcz10aGlzLmNvcmUubm9kZXMoJzpzZWxlY3RlZCcpXHJcbiAgICBpZihzZWxlY3RlZE5vZGVzLnNpemUoKTwyKSByZXR1cm47XHJcbiAgICB2YXIgYm91bmRhcnk9IHNlbGVjdGVkTm9kZXMuYm91bmRpbmdCb3goe2luY2x1ZGVMYWJlbHMgOmZhbHNlLGluY2x1ZGVPdmVybGF5cyA6ZmFsc2UgfSlcclxuICAgIHZhciBjZW50ZXJYPWJvdW5kYXJ5W1wieDFcIl0rYm91bmRhcnlbXCJ3XCJdLzJcclxuICAgIHZhciBjZW50ZXJZPWJvdW5kYXJ5W1wieTFcIl0rYm91bmRhcnlbXCJoXCJdLzJcclxuICAgIFxyXG4gICAgdmFyIG9sZExheW91dD17fVxyXG4gICAgdmFyIG5ld0xheW91dD17fVxyXG4gICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKG9uZU5vZGU9PntcclxuICAgICAgICB2YXIgY3VyUG9zPW9uZU5vZGUucG9zaXRpb24oKVxyXG4gICAgICAgIHZhciBub2RlSUQ9b25lTm9kZS5pZCgpXHJcbiAgICAgICAgb2xkTGF5b3V0W25vZGVJRF09W2N1clBvc1sneCddLGN1clBvc1sneSddXVxyXG4gICAgICAgIHZhciB4b2ZmY2VudGVyPWN1clBvc1tcInhcIl0tY2VudGVyWFxyXG4gICAgICAgIHZhciB5b2ZmY2VudGVyPWN1clBvc1tcInlcIl0tY2VudGVyWVxyXG4gICAgICAgIGlmKGRpcmVjdGlvbj09XCJob3Jpem9udGFsXCIpIG5ld0xheW91dFtub2RlSURdPVtjZW50ZXJYLXhvZmZjZW50ZXIsY3VyUG9zWyd5J11dXHJcbiAgICAgICAgZWxzZSBpZihkaXJlY3Rpb249PVwidmVydGljYWxcIikgbmV3TGF5b3V0W25vZGVJRF09W2N1clBvc1sneCddLGNlbnRlclkteW9mZmNlbnRlcl1cclxuICAgIH0pXHJcbiAgICB0aGlzLmFwcGx5TmV3TGF5b3V0V2l0aFVuZG8obmV3TGF5b3V0LG9sZExheW91dCxcIm9ubHlBZGp1c3ROb2RlUG9zaXRpb25cIilcclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5yb3RhdGVTZWxlY3RlZE5vZGUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgc2VsZWN0ZWROb2Rlcz10aGlzLmNvcmUubm9kZXMoJzpzZWxlY3RlZCcpXHJcbiAgICBpZihzZWxlY3RlZE5vZGVzLnNpemUoKTwyKSByZXR1cm47XHJcbiAgICB2YXIgYm91bmRhcnk9IHNlbGVjdGVkTm9kZXMuYm91bmRpbmdCb3goe2luY2x1ZGVMYWJlbHMgOmZhbHNlLGluY2x1ZGVPdmVybGF5cyA6ZmFsc2UgfSlcclxuICAgIHZhciBjZW50ZXJYPWJvdW5kYXJ5W1wieDFcIl0rYm91bmRhcnlbXCJ3XCJdLzJcclxuICAgIHZhciBjZW50ZXJZPWJvdW5kYXJ5W1wieTFcIl0rYm91bmRhcnlbXCJoXCJdLzJcclxuICAgIFxyXG4gICAgdmFyIG9sZExheW91dD17fVxyXG4gICAgdmFyIG5ld0xheW91dD17fVxyXG4gICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKG9uZU5vZGU9PntcclxuICAgICAgICB2YXIgY3VyUG9zPW9uZU5vZGUucG9zaXRpb24oKVxyXG4gICAgICAgIHZhciBub2RlSUQ9b25lTm9kZS5pZCgpXHJcbiAgICAgICAgb2xkTGF5b3V0W25vZGVJRF09W2N1clBvc1sneCddLGN1clBvc1sneSddXVxyXG4gICAgICAgIHZhciB4b2ZmY2VudGVyPWN1clBvc1tcInhcIl0tY2VudGVyWFxyXG4gICAgICAgIHZhciB5b2ZmY2VudGVyPWN1clBvc1tcInlcIl0tY2VudGVyWVxyXG4gICAgICAgIGlmKGRpcmVjdGlvbj09XCJsZWZ0XCIpIG5ld0xheW91dFtub2RlSURdPVtjZW50ZXJYK3lvZmZjZW50ZXIsY2VudGVyWS14b2ZmY2VudGVyXVxyXG4gICAgICAgIGVsc2UgaWYoZGlyZWN0aW9uPT1cInJpZ2h0XCIpIG5ld0xheW91dFtub2RlSURdPVtjZW50ZXJYLXlvZmZjZW50ZXIsY2VudGVyWSt4b2ZmY2VudGVyXVxyXG4gICAgfSlcclxuICAgIHRoaXMuYXBwbHlOZXdMYXlvdXRXaXRoVW5kbyhuZXdMYXlvdXQsb2xkTGF5b3V0LFwib25seUFkanVzdE5vZGVQb3NpdGlvblwiKVxyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLmRpc3RyaWJ1dGVTZWxlY3RlZE5vZGUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgc2VsZWN0ZWROb2Rlcz10aGlzLmNvcmUubm9kZXMoJzpzZWxlY3RlZCcpXHJcbiAgICBpZihzZWxlY3RlZE5vZGVzLnNpemUoKTwzKSByZXR1cm47XHJcbiAgICB2YXIgbnVtQXJyPVtdXHJcbiAgICB2YXIgb2xkTGF5b3V0PXt9XHJcbiAgICB2YXIgbGF5b3V0Rm9yU29ydD1bXVxyXG4gICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKG9uZU5vZGU9PntcclxuICAgICAgICB2YXIgcG9zaXRpb249b25lTm9kZS5wb3NpdGlvbigpXHJcbiAgICAgICAgaWYoZGlyZWN0aW9uPT1cInZlcnRpY2FsXCIpIG51bUFyci5wdXNoKHBvc2l0aW9uWyd5J10pXHJcbiAgICAgICAgZWxzZSBpZihkaXJlY3Rpb249PVwiaG9yaXpvbnRhbFwiKSBudW1BcnIucHVzaChwb3NpdGlvblsneCddKVxyXG4gICAgICAgIHZhciBjdXJQb3M9b25lTm9kZS5wb3NpdGlvbigpXHJcbiAgICAgICAgdmFyIG5vZGVJRD1vbmVOb2RlLmlkKClcclxuICAgICAgICBvbGRMYXlvdXRbbm9kZUlEXT1bY3VyUG9zWyd4J10sY3VyUG9zWyd5J11dXHJcbiAgICAgICAgbGF5b3V0Rm9yU29ydC5wdXNoKHtpZDpub2RlSUQseDpjdXJQb3NbJ3gnXSx5OmN1clBvc1sneSddfSlcclxuICAgIH0pXHJcblxyXG4gICAgaWYoZGlyZWN0aW9uPT1cInZlcnRpY2FsXCIpIGxheW91dEZvclNvcnQuc29ydChmdW5jdGlvbiAoYSwgYikge3JldHVybiBhW1wieVwiXS1iW1wieVwiXSB9KVxyXG4gICAgZWxzZSBpZihkaXJlY3Rpb249PVwiaG9yaXpvbnRhbFwiKSBsYXlvdXRGb3JTb3J0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtyZXR1cm4gYVtcInhcIl0tYltcInhcIl0gfSlcclxuICAgIFxyXG4gICAgdmFyIG1pblY9TWF0aC5taW4oLi4ubnVtQXJyKVxyXG4gICAgdmFyIG1heFY9TWF0aC5tYXgoLi4ubnVtQXJyKVxyXG4gICAgaWYobWluVj09bWF4VikgcmV0dXJuO1xyXG4gICAgdmFyIGdhcD0obWF4Vi1taW5WKS8oc2VsZWN0ZWROb2Rlcy5zaXplKCktMSlcclxuICAgIHZhciBuZXdMYXlvdXQ9e31cclxuICAgIGlmKGRpcmVjdGlvbj09XCJ2ZXJ0aWNhbFwiKSB2YXIgY3VyVj1sYXlvdXRGb3JTb3J0WzBdW1wieVwiXVxyXG4gICAgZWxzZSBpZihkaXJlY3Rpb249PVwiaG9yaXpvbnRhbFwiKSBjdXJWPWxheW91dEZvclNvcnRbMF1bXCJ4XCJdXHJcbiAgICBmb3IodmFyIGk9MDtpPGxheW91dEZvclNvcnQubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdmFyIG9uZU5vZGVJbmZvPWxheW91dEZvclNvcnRbaV1cclxuICAgICAgICBpZihpPT0wfHwgaT09bGF5b3V0Rm9yU29ydC5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgIG5ld0xheW91dFtvbmVOb2RlSW5mby5pZF09W29uZU5vZGVJbmZvWyd4J10sb25lTm9kZUluZm9bJ3knXV1cclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyVis9Z2FwO1xyXG4gICAgICAgIGlmKGRpcmVjdGlvbj09XCJ2ZXJ0aWNhbFwiKSBuZXdMYXlvdXRbb25lTm9kZUluZm8uaWRdPVtvbmVOb2RlSW5mb1sneCddLGN1clZdXHJcbiAgICAgICAgZWxzZSBpZihkaXJlY3Rpb249PVwiaG9yaXpvbnRhbFwiKSBuZXdMYXlvdXRbb25lTm9kZUluZm8uaWRdPVtjdXJWLG9uZU5vZGVJbmZvWyd5J11dXHJcbiAgICB9XHJcbiAgICB0aGlzLmFwcGx5TmV3TGF5b3V0V2l0aFVuZG8obmV3TGF5b3V0LG9sZExheW91dCxcIm9ubHlBZGp1c3ROb2RlUG9zaXRpb25cIilcclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5hbGlnblNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgc2VsZWN0ZWROb2Rlcz10aGlzLmNvcmUubm9kZXMoJzpzZWxlY3RlZCcpXHJcbiAgICBpZihzZWxlY3RlZE5vZGVzLnNpemUoKTwyKSByZXR1cm47XHJcbiAgICB2YXIgbnVtQXJyPVtdXHJcbiAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2gob25lTm9kZT0+e1xyXG4gICAgICAgIHZhciBwb3NpdGlvbj1vbmVOb2RlLnBvc2l0aW9uKClcclxuICAgICAgICBpZihkaXJlY3Rpb249PVwidG9wXCJ8fCBkaXJlY3Rpb249PVwiYm90dG9tXCIpIG51bUFyci5wdXNoKHBvc2l0aW9uWyd5J10pXHJcbiAgICAgICAgZWxzZSBpZihkaXJlY3Rpb249PVwibGVmdFwifHwgZGlyZWN0aW9uPT1cInJpZ2h0XCIpIG51bUFyci5wdXNoKHBvc2l0aW9uWyd4J10pXHJcbiAgICB9KVxyXG4gICAgdmFyIHRhcmdldFg9bnVsbFxyXG4gICAgdmFyIHRhcmdldFk9bnVsbFxyXG4gICAgaWYoZGlyZWN0aW9uPT1cInRvcFwiKSB2YXIgdGFyZ2V0WT0gTWF0aC5taW4oLi4ubnVtQXJyKVxyXG4gICAgZWxzZSBpZihkaXJlY3Rpb249PVwiYm90dG9tXCIpIHZhciB0YXJnZXRZPSBNYXRoLm1heCguLi5udW1BcnIpXHJcbiAgICBpZihkaXJlY3Rpb249PVwibGVmdFwiKSB2YXIgdGFyZ2V0WD0gTWF0aC5taW4oLi4ubnVtQXJyKVxyXG4gICAgZWxzZSBpZihkaXJlY3Rpb249PVwicmlnaHRcIikgdmFyIHRhcmdldFg9IE1hdGgubWF4KC4uLm51bUFycilcclxuICAgIFxyXG4gICAgdmFyIG9sZExheW91dD17fVxyXG4gICAgdmFyIG5ld0xheW91dD17fVxyXG4gICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKG9uZU5vZGU9PntcclxuICAgICAgICB2YXIgY3VyUG9zPW9uZU5vZGUucG9zaXRpb24oKVxyXG4gICAgICAgIHZhciBub2RlSUQ9b25lTm9kZS5pZCgpXHJcbiAgICAgICAgb2xkTGF5b3V0W25vZGVJRF09W2N1clBvc1sneCddLGN1clBvc1sneSddXVxyXG4gICAgICAgIG5ld0xheW91dFtub2RlSURdPVtjdXJQb3NbJ3gnXSxjdXJQb3NbJ3knXV1cclxuICAgICAgICBpZih0YXJnZXRYIT1udWxsKSBuZXdMYXlvdXRbbm9kZUlEXVswXT10YXJnZXRYXHJcbiAgICAgICAgaWYodGFyZ2V0WSE9bnVsbCkgbmV3TGF5b3V0W25vZGVJRF1bMV09dGFyZ2V0WVxyXG4gICAgfSlcclxuICAgIHRoaXMuYXBwbHlOZXdMYXlvdXRXaXRoVW5kbyhuZXdMYXlvdXQsb2xkTGF5b3V0LFwib25seUFkanVzdE5vZGVQb3NpdGlvblwiKVxyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLm51bWJlclByZWNpc2lvbiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgIGlmKEFycmF5LmlzQXJyYXkobnVtYmVyKSl7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7aTxudW1iZXIubGVuZ3RoO2krKykgbnVtYmVyW2ldID0gdGhpcy5udW1iZXJQcmVjaXNpb24obnVtYmVyW2ldKVxyXG4gICAgICAgIHJldHVybiBudW1iZXJcclxuICAgIH1lbHNle1xyXG4gICAgICAgIGlmKG51bWJlciA9PSBudWxsKSByZXR1cm4gbnVsbFxyXG4gICAgICAgIGVsc2UgbnVtYmVyPXBhcnNlRmxvYXQobnVtYmVyKVxyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG51bWJlci50b0ZpeGVkKDMpKVxyXG4gICAgfSAgXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3Zpc3VhbC5wcm90b3R5cGUuZHJhd1R3aW5zPWZ1bmN0aW9uKHR3aW5zRGF0YSxhbmltYXRpb24pe1xyXG4gICAgdmFyIGFycj1bXVxyXG4gICAgZm9yKHZhciBpPTA7aTx0d2luc0RhdGEubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsSW5mbz10d2luc0RhdGFbaV07XHJcbiAgICAgICAgdmFyIG5ld05vZGU9e2RhdGE6e30sZ3JvdXA6XCJub2Rlc1wifVxyXG4gICAgICAgIG5ld05vZGUuZGF0YVtcIm9yaWdpbmFsSW5mb1wiXT0gb3JpZ2luYWxJbmZvO1xyXG4gICAgICAgIG5ld05vZGUuZGF0YVtcImlkXCJdPW9yaWdpbmFsSW5mb1snZGlzcGxheU5hbWUnXVxyXG4gICAgICAgIHZhciBtb2RlbElEPW9yaWdpbmFsSW5mb1snJG1ldGFkYXRhJ11bJyRtb2RlbCddXHJcbiAgICAgICAgbmV3Tm9kZS5kYXRhW1wibW9kZWxJRFwiXT1tb2RlbElEXHJcbiAgICAgICAgYXJyLnB1c2gobmV3Tm9kZSlcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxlcyA9IHRoaXMuY29yZS5hZGQoYXJyKVxyXG4gICAgaWYoZWxlcy5zaXplKCk9PTApIHJldHVybiBlbGVzXHJcbiAgICB0aGlzLm5vUG9zaXRpb25fZ3JpZChlbGVzKVxyXG4gICAgaWYoYW5pbWF0aW9uKXtcclxuICAgICAgICBlbGVzLmZvckVhY2goKGVsZSk9PnsgdGhpcy5hbmltYXRlQU5vZGUoZWxlKSB9KVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvL2RyYXcgc2ltdWxhdGluZyBkYXRhIHNvdXJjZVxyXG4gICAgZWxlcy5mb3JFYWNoKGVsZT0+e1xyXG4gICAgICAgIHZhciB0d2luSUQ9ZWxlLmRhdGEoKS5vcmlnaW5hbEluZm9bJyRkdElkJ11cclxuICAgICAgICB2YXIgZGJ0d2luPWdsb2JhbENhY2hlLkRCVHdpbnNbdHdpbklEXVxyXG4gICAgICAgIGlmKGRidHdpbiAmJiBkYnR3aW4uc2ltdWxhdGUpe1xyXG4gICAgICAgICAgICBmb3IodmFyIHNpbU5vZGVOYW1lIGluIGRidHdpbi5zaW11bGF0ZSkgdGhpcy5zaG93U2ltdWxhdG9yU291cmNlKHR3aW5JRCxzaW1Ob2RlTmFtZSxkYnR3aW4uc2ltdWxhdGVbc2ltTm9kZU5hbWVdKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIGVsZXNcclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5oaWRlUmVsYXRpb25zPWZ1bmN0aW9uKHJlbGF0aW9ucyl7XHJcbiAgICByZWxhdGlvbnMuZm9yRWFjaChvbmVSZWxhdGlvbj0+e1xyXG4gICAgICAgIHZhciBzcmNJRD1vbmVSZWxhdGlvbltcInNyY0lEXCJdXHJcbiAgICAgICAgdmFyIHJlbGF0aW9uSUQ9b25lUmVsYXRpb25bXCJyZWxJRFwiXVxyXG4gICAgICAgIHZhciB0aGVOb2RlTmFtZT1nbG9iYWxDYWNoZS50d2luSURNYXBUb0Rpc3BsYXlOYW1lW3NyY0lEXVxyXG4gICAgICAgIHZhciB0aGVOb2RlPXRoaXMuY29yZS5maWx0ZXIoJ1tpZCA9IFwiJyt0aGVOb2RlTmFtZSsnXCJdJyk7XHJcbiAgICAgICAgdmFyIGVkZ2VzPXRoZU5vZGUuY29ubmVjdGVkRWRnZXMoKS50b0FycmF5KClcclxuICAgICAgICBmb3IodmFyIGk9MDtpPGVkZ2VzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB2YXIgYW5FZGdlPWVkZ2VzW2ldXHJcbiAgICAgICAgICAgIGlmKGFuRWRnZS5kYXRhKFwib3JpZ2luYWxJbmZvXCIpW1wiJHJlbGF0aW9uc2hpcElkXCJdPT1yZWxhdGlvbklEKXtcclxuICAgICAgICAgICAgICAgIGFuRWRnZS5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pICAgXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3Zpc3VhbC5wcm90b3R5cGUubm9Qb3NpdGlvbl9ncmlkPWZ1bmN0aW9uKGVsZXMpe1xyXG4gICAgdmFyIG5ld0xheW91dCA9IGVsZXMubGF5b3V0KHtcclxuICAgICAgICBuYW1lOiAnZ3JpZCcsXHJcbiAgICAgICAgYW5pbWF0ZTogZmFsc2UsXHJcbiAgICAgICAgZml0OmZhbHNlXHJcbiAgICB9KSBcclxuICAgIG5ld0xheW91dC5ydW4oKSBcclxufVxyXG5cclxuXHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLm5vUG9zaXRpb25fY29uY2VudHJpYz1mdW5jdGlvbihlbGVzLGJveCl7XHJcbiAgICBpZihlbGVzPT1udWxsKSBlbGVzPXRoaXMuY29yZS5lbGVtZW50cygpXHJcbiAgICB2YXIgbmV3TGF5b3V0ID1lbGVzLmxheW91dCh7XHJcbiAgICAgICAgbmFtZTogJ2NvbmNlbnRyaWMnLFxyXG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxyXG4gICAgICAgIGZpdDpmYWxzZSxcclxuICAgICAgICBtaW5Ob2RlU3BhY2luZzo2MCxcclxuICAgICAgICBncmF2aXR5OjEsXHJcbiAgICAgICAgYm91bmRpbmdCb3g6Ym94XHJcbiAgICB9KSBcclxuICAgIG5ld0xheW91dC5ydW4oKVxyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLmRyYXdUd2luc0FuZFJlbGF0aW9ucz1mdW5jdGlvbihkYXRhKXtcclxuICAgIHZhciB0d2luc0FuZFJlbGF0aW9ucz1kYXRhLmNoaWxkVHdpbnNBbmRSZWxhdGlvbnNcclxuXHJcbiAgICAvL2RyYXcgdGhvc2UgbmV3IHR3aW5zIGZpcnN0XHJcbiAgICB0d2luc0FuZFJlbGF0aW9ucy5mb3JFYWNoKG9uZVNldD0+e1xyXG4gICAgICAgIHZhciB0d2luSW5mb0Fycj1bXVxyXG4gICAgICAgIGZvcih2YXIgaW5kIGluIG9uZVNldC5jaGlsZFR3aW5zKSB0d2luSW5mb0Fyci5wdXNoKG9uZVNldC5jaGlsZFR3aW5zW2luZF0pXHJcbiAgICAgICAgdmFyIGVsZXM9dGhpcy5kcmF3VHdpbnModHdpbkluZm9BcnIsXCJhbmltYXRpb25cIilcclxuICAgIH0pXHJcblxyXG4gICAgLy9kcmF3IHRob3NlIGtub3duIHR3aW5zIGZyb20gdGhlIHJlbGF0aW9uc2hpcHNcclxuICAgIHZhciB0d2luc0luZm89e31cclxuICAgIHR3aW5zQW5kUmVsYXRpb25zLmZvckVhY2gob25lU2V0PT57XHJcbiAgICAgICAgdmFyIHJlbGF0aW9uc0luZm89b25lU2V0W1wicmVsYXRpb25zaGlwc1wiXVxyXG4gICAgICAgIHJlbGF0aW9uc0luZm8uZm9yRWFjaCgob25lUmVsYXRpb24pPT57XHJcbiAgICAgICAgICAgIHZhciBzcmNJRD1vbmVSZWxhdGlvblsnJHNvdXJjZUlkJ11cclxuICAgICAgICAgICAgdmFyIHRhcmdldElEPW9uZVJlbGF0aW9uWyckdGFyZ2V0SWQnXVxyXG4gICAgICAgICAgICBpZihnbG9iYWxDYWNoZS5zdG9yZWRUd2luc1tzcmNJRF0pXHJcbiAgICAgICAgICAgICAgICB0d2luc0luZm9bc3JjSURdID0gZ2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbc3JjSURdXHJcbiAgICAgICAgICAgIGlmKGdsb2JhbENhY2hlLnN0b3JlZFR3aW5zW3RhcmdldElEXSlcclxuICAgICAgICAgICAgICAgIHR3aW5zSW5mb1t0YXJnZXRJRF0gPSBnbG9iYWxDYWNoZS5zdG9yZWRUd2luc1t0YXJnZXRJRF0gICAgXHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbiAgICB2YXIgdG1wQXJyPVtdXHJcbiAgICBmb3IodmFyIHR3aW5JRCBpbiB0d2luc0luZm8pIHRtcEFyci5wdXNoKHR3aW5zSW5mb1t0d2luSURdKVxyXG4gICAgdGhpcy5kcmF3VHdpbnModG1wQXJyKVxyXG5cclxuICAgIC8vdGhlbiBjaGVjayBhbGwgc3RvcmVkIHJlbGF0aW9uc2hpcHMgYW5kIGRyYXcgaWYgaXQgY2FuIGJlIGRyYXduXHJcbiAgICB0aGlzLnJldmlld1N0b3JlZFJlbGF0aW9uc2hpcHNUb0RyYXcoKVxyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLnJldmlld1N0b3JlZFJlbGF0aW9uc2hpcHNUb0RyYXc9ZnVuY3Rpb24oKXtcclxuICAgIC8vY2hlY2sgdGhlIHN0b3JlZE91dGJvdW5kUmVsYXRpb25zaGlwcyBhZ2FpbiBhbmQgbWF5YmUgc29tZSBvZiB0aGVtIGNhbiBiZSBkcmF3biBub3cgc2luY2UgdGFyZ2V0Tm9kZSBpcyBhdmFpbGFibGVcclxuICAgIHZhciBzdG9yZWRSZWxhdGlvbkFycj1bXVxyXG4gICAgZm9yKHZhciB0d2luSUQgaW4gZ2xvYmFsQ2FjaGUuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzKXtcclxuICAgICAgICBzdG9yZWRSZWxhdGlvbkFycj1zdG9yZWRSZWxhdGlvbkFyci5jb25jYXQoZ2xvYmFsQ2FjaGUuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW3R3aW5JRF0pXHJcbiAgICB9XHJcbiAgICB0aGlzLmRyYXdSZWxhdGlvbnMoc3RvcmVkUmVsYXRpb25BcnIpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3Zpc3VhbC5wcm90b3R5cGUuZHJhd1JlbGF0aW9ucz1mdW5jdGlvbihyZWxhdGlvbnNEYXRhKXtcclxuICAgIHZhciByZWxhdGlvbkluZm9BcnI9W11cclxuICAgIGZvcih2YXIgaT0wO2k8cmVsYXRpb25zRGF0YS5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIgb3JpZ2luYWxJbmZvPXJlbGF0aW9uc0RhdGFbaV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRoZUlEPW9yaWdpbmFsSW5mb1snJHJlbGF0aW9uc2hpcE5hbWUnXStcIl9cIitvcmlnaW5hbEluZm9bJyRyZWxhdGlvbnNoaXBJZCddXHJcbiAgICAgICAgdmFyIGFSZWxhdGlvbj17ZGF0YTp7fSxncm91cDpcImVkZ2VzXCJ9XHJcbiAgICAgICAgYVJlbGF0aW9uLmRhdGFbXCJvcmlnaW5hbEluZm9cIl09b3JpZ2luYWxJbmZvXHJcbiAgICAgICAgYVJlbGF0aW9uLmRhdGFbXCJpZFwiXT10aGVJRFxyXG4gICAgICAgIGFSZWxhdGlvbi5kYXRhW1wic291cmNlXCJdPWdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbb3JpZ2luYWxJbmZvWyckc291cmNlSWQnXV1cclxuICAgICAgICBhUmVsYXRpb24uZGF0YVtcInRhcmdldFwiXT1nbG9iYWxDYWNoZS50d2luSURNYXBUb0Rpc3BsYXlOYW1lW29yaWdpbmFsSW5mb1snJHRhcmdldElkJ11dXHJcblxyXG4gICAgICAgIGlmKHRoaXMuY29yZS4kKGBbaWQ9XCIke2FSZWxhdGlvbi5kYXRhW1wic291cmNlXCJdfVwiXWApLmxlbmd0aD09MCBcclxuICAgICAgICAgICAgfHwgdGhpcy5jb3JlLiQoYFtpZD1cIiR7YVJlbGF0aW9uLmRhdGFbXCJ0YXJnZXRcIl19XCJdYCkubGVuZ3RoPT0wKSBjb250aW51ZVxyXG4gICAgICAgIHZhciBzb3VyY2VOb2RlPXRoaXMuY29yZS4kKGBbaWQ9XCIke2FSZWxhdGlvbi5kYXRhW1wic291cmNlXCJdfVwiXWApXHJcbiAgICAgICAgdmFyIHNvdXJjZU1vZGVsPXNvdXJjZU5vZGVbMF0uZGF0YShcIm9yaWdpbmFsSW5mb1wiKVsnJG1ldGFkYXRhJ11bJyRtb2RlbCddXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9hZGQgYWRkaXRpb25hbCBzb3VyY2Ugbm9kZSBpbmZvcm1hdGlvbiB0byB0aGUgb3JpZ2luYWwgcmVsYXRpb25zaGlwIGluZm9ybWF0aW9uXHJcbiAgICAgICAgb3JpZ2luYWxJbmZvWydzb3VyY2VNb2RlbCddPXNvdXJjZU1vZGVsXHJcbiAgICAgICAgYVJlbGF0aW9uLmRhdGFbXCJzb3VyY2VNb2RlbFwiXT1zb3VyY2VNb2RlbFxyXG4gICAgICAgIGFSZWxhdGlvbi5kYXRhW1wicmVsYXRpb25zaGlwTmFtZVwiXT1vcmlnaW5hbEluZm9bJyRyZWxhdGlvbnNoaXBOYW1lJ11cclxuXHJcbiAgICAgICAgdmFyIGV4aXN0RWRnZT10aGlzLmNvcmUuJCgnZWRnZVtpZCA9IFwiJyt0aGVJRCsnXCJdJylcclxuICAgICAgICBpZihleGlzdEVkZ2Uuc2l6ZSgpPjApIHtcclxuICAgICAgICAgICAgZXhpc3RFZGdlLmRhdGEoXCJvcmlnaW5hbEluZm9cIixvcmlnaW5hbEluZm8pXHJcbiAgICAgICAgICAgIGNvbnRpbnVlOyAgLy9ubyBuZWVkIHRvIGRyYXcgaXRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbGF0aW9uSW5mb0Fyci5wdXNoKGFSZWxhdGlvbilcclxuICAgIH1cclxuICAgIGlmKHJlbGF0aW9uSW5mb0Fyci5sZW5ndGg9PTApIHJldHVybiBudWxsO1xyXG5cclxuICAgIHZhciBlZGdlcz10aGlzLmNvcmUuYWRkKHJlbGF0aW9uSW5mb0FycilcclxuICAgIHJldHVybiBlZGdlc1xyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLmFuaW1hdGVBTm9kZT1mdW5jdGlvbih0d2luKXtcclxuICAgIHZhciBjdXJEaW1lbnNpb249IHR3aW4ud2lkdGgoKVxyXG4gICAgdHdpbi5hbmltYXRlKHtcclxuICAgICAgICBzdHlsZTogeyAnaGVpZ2h0JzogY3VyRGltZW5zaW9uKjIsJ3dpZHRoJzogY3VyRGltZW5zaW9uKjIgfSxcclxuICAgICAgICBkdXJhdGlvbjogMjAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgdHdpbi5hbmltYXRlKHtcclxuICAgICAgICAgICAgc3R5bGU6IHsgJ2hlaWdodCc6IGN1ckRpbWVuc2lvbiwnd2lkdGgnOiBjdXJEaW1lbnNpb24gfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IDIwMFxyXG4gICAgICAgICAgICAsY29tcGxldGU6KCk9PntcclxuICAgICAgICAgICAgICAgIHR3aW4ucmVtb3ZlU3R5bGUoKSAvL211c3QgcmVtb3ZlIHRoZSBzdHlsZSBhZnRlciBhbmltYXRpb24sIG90aGVyd2lzZSB0aGV5IHdpbGwgaGF2ZSB0aGVpciBvd24gc3R5bGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwyMDApXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3Zpc3VhbC5wcm90b3R5cGUuc2hvd1NpbXVsYXRvclNvdXJjZSA9IGZ1bmN0aW9uICh0d2luSUQsc2ltTm9kZU5hbWUsc2ltU291cmNlT2JqKSB7XHJcbiAgICB2YXIgdHdpbk5hbWU9Z2xvYmFsQ2FjaGUudHdpbklETWFwVG9EaXNwbGF5TmFtZVt0d2luSURdXHJcbiAgICB0aGlzLmNvcmUuYWRkKFt7XHJcbiAgICAgICAgZGF0YTp7XHJcbiAgICAgICAgICAgIFwiaWRcIjpzaW1Ob2RlTmFtZSxcclxuICAgICAgICAgICAgXCJtb2RlbElEXCI6XCJfZml4ZWRfc2ltdWxhdGlvbkRhdGFTb3VyY2VcIixcclxuICAgICAgICAgICAgXCJub3RUd2luXCI6dHJ1ZSxcclxuICAgICAgICAgICAgXCJvcmlnaW5hbEluZm9cIjp7XHJcbiAgICAgICAgICAgICAgICBcInNpbU5vZGVOYW1lXCI6c2ltTm9kZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBcInR3aW5JRFwiOnR3aW5JRCxcclxuICAgICAgICAgICAgICAgIFwiZGV0YWlsXCI6c2ltU291cmNlT2JqXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLGdyb3VwOlwibm9kZXNcIlxyXG4gICAgfV0pXHJcbiAgICB2YXIgdG9wb05vZGU9IHRoaXMuY29yZS5ub2RlcyhgW2lkPVwiJHtzaW1Ob2RlTmFtZX1cIl1gKVxyXG4gICAgdmFyIHNvdXJjZU5vZGU9dGhpcy5jb3JlLm5vZGVzKGBbaWQ9XCIke3R3aW5OYW1lfVwiXWApXHJcbiAgICBpZih0b3BvTm9kZSl7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uPXNvdXJjZU5vZGUucmVuZGVyZWRQb3NpdGlvbigpXHJcbiAgICAgICAgdG9wb05vZGUucmVuZGVyZWRQb3NpdGlvbigge3g6cG9zaXRpb24ueC02MCx5OnBvc2l0aW9uLnktcGFyc2VJbnQoKE1hdGgucmFuZG9tKCktMC41KSoxMjApfSApXHJcbiAgICAgICAgdGhpcy5jb3JlLmFkZChbe1xyXG4gICAgICAgICAgICBkYXRhOntcclxuICAgICAgICAgICAgICAgIFwiaWRcIjpnbG9iYWxDYWNoZS51dWlkdjQoKSxcclxuICAgICAgICAgICAgICAgIFwic291cmNlTW9kZWxcIjpcIl9maXhlZF9zaW11bGF0aW9uRGF0YVNvdXJjZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjpzaW1Ob2RlTmFtZSxcclxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6dHdpbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBcIm5vdFR3aW5cIjp0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLGdyb3VwOlwiZWRnZXNcIlxyXG4gICAgICAgIH1dKVxyXG4gICAgfVxyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLmdldEN1cnJlbnRMYXlvdXREZXRhaWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbGF5b3V0RGljdD17XCJlZGdlc1wiOnt9fVxyXG4gICAgaWYodGhpcy5jb3JlLm5vZGVzKCkuc2l6ZSgpPT0wKSByZXR1cm4gbGF5b3V0RGljdDtcclxuICAgIC8vc3RvcmUgbm9kZXMgcG9zaXRpb25cclxuICAgIHRoaXMuY29yZS5ub2RlcygpLmZvckVhY2gob25lTm9kZT0+e1xyXG4gICAgICAgIHZhciBwb3NpdGlvbj1vbmVOb2RlLnBvc2l0aW9uKClcclxuICAgICAgICB2YXIgdGhlQXJyPVtwb3NpdGlvblsneCddLHBvc2l0aW9uWyd5J11dXHJcbiAgICAgICAgLy9hbHNvIHN0b3JlIG5vZGUgcm90YXRlIGFuZCBzY2FsZSBpbmZvcm1hdGlvblxyXG4gICAgICAgIGlmKG9uZU5vZGUuZGF0YShcInNjYWxlRmFjdG9yXCIpIHx8IG9uZU5vZGUuZGF0YShcInJvdGF0ZUFuZ2xlXCIpKXtcclxuICAgICAgICAgICAgdGhlQXJyLnB1c2gob25lTm9kZS5kYXRhKFwic2NhbGVGYWN0b3JcIiksb25lTm9kZS5kYXRhKFwicm90YXRlQW5nbGVcIikpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm51bWJlclByZWNpc2lvbih0aGVBcnIpXHJcbiAgICAgICAgbGF5b3V0RGljdFtvbmVOb2RlLmlkKCldPXRoZUFyclxyXG4gICAgfSlcclxuXHJcbiAgICAvL3N0b3JlIGFueSBlZGdlIGJlbmRpbmcgcG9pbnRzIG9yIGNvbnRyb2xpbmcgcG9pbnRzLCB3aGljaCBpcyBlbGVtZW50cyBkYXRhIGN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0cyxjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlcyBjeWVkZ2Vjb250cm9sZWRpdGluZ1dlaWdodHMgIGN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzXHJcbiAgICB0aGlzLmNvcmUuZWRnZXMoKS5mb3JFYWNoKG9uZUVkZ2U9PntcclxuICAgICAgICBpZihvbmVFZGdlLmRhdGEoKS5ub3RUd2luKSByZXR1cm47XHJcbiAgICAgICAgdmFyIHNyY0lEPW9uZUVkZ2UuZGF0YShcIm9yaWdpbmFsSW5mb1wiKVtcIiRzb3VyY2VJZFwiXVxyXG4gICAgICAgIHZhciByZWxhdGlvbnNoaXBJRD1vbmVFZGdlLmRhdGEoXCJvcmlnaW5hbEluZm9cIilbXCIkcmVsYXRpb25zaGlwSWRcIl1cclxuICAgICAgICB2YXIgY3llZGdlYmVuZGVkaXRpbmdXZWlnaHRzPW9uZUVkZ2UuZGF0YSgnY3llZGdlYmVuZGVkaXRpbmdXZWlnaHRzJylcclxuICAgICAgICB2YXIgY3llZGdlYmVuZGVkaXRpbmdEaXN0YW5jZXM9b25lRWRnZS5kYXRhKCdjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlcycpXHJcbiAgICAgICAgdmFyIGN5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ2h0cz1vbmVFZGdlLmRhdGEoJ2N5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ2h0cycpXHJcbiAgICAgICAgdmFyIGN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzPW9uZUVkZ2UuZGF0YSgnY3llZGdlY29udHJvbGVkaXRpbmdEaXN0YW5jZXMnKVxyXG4gICAgICAgIGlmKCFjeWVkZ2ViZW5kZWRpdGluZ1dlaWdodHMgJiYgIWN5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ2h0cykgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZihsYXlvdXREaWN0LmVkZ2VzW3NyY0lEXT09bnVsbClsYXlvdXREaWN0LmVkZ2VzW3NyY0lEXT17fVxyXG4gICAgICAgIGxheW91dERpY3QuZWRnZXNbc3JjSURdW3JlbGF0aW9uc2hpcElEXT17fVxyXG4gICAgICAgIGlmKGN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0cyAmJiBjeWVkZ2ViZW5kZWRpdGluZ1dlaWdodHMubGVuZ3RoPjApIHtcclxuICAgICAgICAgICAgbGF5b3V0RGljdC5lZGdlc1tzcmNJRF1bcmVsYXRpb25zaGlwSURdW1wiY3llZGdlYmVuZGVkaXRpbmdXZWlnaHRzXCJdPXRoaXMubnVtYmVyUHJlY2lzaW9uKGN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0cylcclxuICAgICAgICAgICAgbGF5b3V0RGljdC5lZGdlc1tzcmNJRF1bcmVsYXRpb25zaGlwSURdW1wiY3llZGdlYmVuZGVkaXRpbmdEaXN0YW5jZXNcIl09dGhpcy5udW1iZXJQcmVjaXNpb24oY3llZGdlYmVuZGVkaXRpbmdEaXN0YW5jZXMpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGN5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ2h0cyAmJiBjeWVkZ2Vjb250cm9sZWRpdGluZ1dlaWdodHMubGVuZ3RoPjApIHtcclxuICAgICAgICAgICAgbGF5b3V0RGljdC5lZGdlc1tzcmNJRF1bcmVsYXRpb25zaGlwSURdW1wiY3llZGdlY29udHJvbGVkaXRpbmdXZWlnaHRzXCJdPXRoaXMubnVtYmVyUHJlY2lzaW9uKGN5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ2h0cylcclxuICAgICAgICAgICAgbGF5b3V0RGljdC5lZGdlc1tzcmNJRF1bcmVsYXRpb25zaGlwSURdW1wiY3llZGdlY29udHJvbGVkaXRpbmdEaXN0YW5jZXNcIl09dGhpcy5udW1iZXJQcmVjaXNpb24oY3llZGdlY29udHJvbGVkaXRpbmdEaXN0YW5jZXMpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgIHJldHVybiBsYXlvdXREaWN0O1xyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLm5vUG9zaXRpb25fY29zZT1mdW5jdGlvbihlbGVzKXtcclxuICAgIGlmKGVsZXM9PW51bGwpIGVsZXM9dGhpcy5jb3JlLmVsZW1lbnRzKClcclxuICAgIHZhciB1bmRvTGF5b3V0RGV0YWlsPSB0aGlzLmdldEN1cnJlbnRMYXlvdXREZXRhaWwoKVxyXG5cclxuICAgIC8vcmVtb3ZlIGFsbCBiZW5kaW5nIHBvaW50IGFuZCBzY2FsZSByb3RhdGVcclxuICAgIHRoaXMucmVzZXRBbGxCZW5kaW5nRWRnZSgpXHJcbiAgICB0aGlzLnJlc2V0QWxsTm9kZVNjYWxlUm90YXRlKClcclxuICAgIHZhciBuZXdMYXlvdXQgPWVsZXMubGF5b3V0KHtcclxuICAgICAgICBuYW1lOiAnY29zZScsXHJcbiAgICAgICAgZ3Jhdml0eToxLFxyXG4gICAgICAgIGFuaW1hdGU6IGZhbHNlXHJcbiAgICAgICAgLGZpdDpmYWxzZVxyXG4gICAgfSkgXHJcbiAgICBuZXdMYXlvdXQucnVuKClcclxuICAgIGlmKHVuZG9MYXlvdXREZXRhaWwpe1xyXG4gICAgICAgIHZhciBuZXdMYXlvdXREZXRhaWw9dGhpcy5nZXRDdXJyZW50TGF5b3V0RGV0YWlsKClcclxuICAgICAgICB0aGlzLmFwcGx5TmV3TGF5b3V0V2l0aFVuZG8obmV3TGF5b3V0RGV0YWlsLCB1bmRvTGF5b3V0RGV0YWlsKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmNvcmUuY2VudGVyKGVsZXMpXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3Zpc3VhbC5wcm90b3R5cGUucmVzZXRBbGxCZW5kaW5nRWRnZT1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5jb3JlLmVkZ2VzKCkuZm9yRWFjaChvbmVFZGdlPT57XHJcbiAgICAgICAgb25lRWRnZS5yZW1vdmVDbGFzcygnZWRnZWJlbmRlZGl0aW5nLWhhc2JlbmRwb2ludHMnKVxyXG4gICAgICAgIG9uZUVkZ2UucmVtb3ZlQ2xhc3MoJ2VkZ2Vjb250cm9sZWRpdGluZy1oYXNjb250cm9scG9pbnRzJylcclxuICAgICAgICBvbmVFZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ1dlaWdodHNcIixbXSlcclxuICAgICAgICBvbmVFZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlc1wiLFtdKVxyXG4gICAgICAgIG9uZUVkZ2UuZGF0YShcImN5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ2h0c1wiLFtdKVxyXG4gICAgICAgIG9uZUVkZ2UuZGF0YShcImN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzXCIsW10pXHJcbiAgICB9KVxyXG59XHJcblxyXG50b3BvbG9neURPTV92aXN1YWwucHJvdG90eXBlLnJlc2V0QWxsTm9kZVNjYWxlUm90YXRlPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmNvcmUubm9kZXMoKS5mb3JFYWNoKG9uZU5vZGU9PntcclxuICAgICAgICBvbmVOb2RlLnJlbW92ZUNsYXNzKCdlZGdlYmVuZGVkaXRpbmdfc2NhbGVSb3RhdGUnKVxyXG4gICAgICAgIG9uZU5vZGUucmVtb3ZlRGF0YShcInNjYWxlRmFjdG9yXCIpXHJcbiAgICAgICAgb25lTm9kZS5yZW1vdmVEYXRhKFwicm90YXRlQW5nbGVcIilcclxuICAgIH0pXHJcbn1cclxuXHJcbnRvcG9sb2d5RE9NX3Zpc3VhbC5wcm90b3R5cGUucmVkcmF3QmFzZWRPbkxheW91dERldGFpbCA9IGZ1bmN0aW9uIChsYXlvdXREZXRhaWwsb25seUFkanVzdE5vZGVQb3NpdGlvbixub0FuaW1hdGlvbixjZW50ZXJOb2Rlcykge1xyXG4gICAgLy9yZW1vdmUgYWxsIGJlbmRpbmcgZWRnZSBcclxuICAgIGlmKCFvbmx5QWRqdXN0Tm9kZVBvc2l0aW9uKSB0aGlzLnJlc2V0QWxsQmVuZGluZ0VkZ2UoKSAgICBcclxuICAgIGlmKGxheW91dERldGFpbD09bnVsbCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICB2YXIgc3RvcmVkUG9zaXRpb25zPXt9XHJcbiAgICBmb3IodmFyIGluZCBpbiBsYXlvdXREZXRhaWwpe1xyXG4gICAgICAgIGlmKGluZCA9PSBcImVkZ2VzXCIpIGNvbnRpbnVlXHJcbiAgICAgICAgLy9pbmQgaXMgdGhlIG5vZGUgbmFtZSwgY2hlY2sgaWYgdGhlcmUgaXMgYXR0YWNoZWQgc2ltdWxhdGlvbiBkYXRhIHNvdXJjZSwgaWYgaGF2ZSwgYWRqdXN0IGl0cyBwb3NpdGlvbiBhcyB3ZWxsXHJcbiAgICAgICAgc3RvcmVkUG9zaXRpb25zW2luZF09e1xyXG4gICAgICAgICAgICB4OmxheW91dERldGFpbFtpbmRdWzBdXHJcbiAgICAgICAgICAgICx5OmxheW91dERldGFpbFtpbmRdWzFdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb25seUFkanVzdE5vZGVQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAvL2FwcGx5IHNjYWxlIG9yIHJvdGF0ZSBpZiB0aGUgdHdpbiBub2RlIGhhc1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5Tm9kZVNjYWxlUm90YXRlKGluZCwgbGF5b3V0RGV0YWlsW2luZF1bMl0sIGxheW91dERldGFpbFtpbmRdWzNdKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGJUd2luPWdsb2JhbENhY2hlLmdldFNpbmdsZURCVHdpbkJ5TmFtZShpbmQpXHJcbiAgICAgICAgaWYgKCFkYlR3aW4gfHwgIWRiVHdpbi5zaW11bGF0ZSkgY29udGludWVcclxuICAgICAgICAvL3JlZHJhdyB0aGUgYXR0YWNoZWQgc2ltdWxhdGlvbiBkYXRhIHNvdXJjZXMgb2YgdHdpblxyXG4gICAgICAgIGZvciAodmFyIHNpbU5vZGVOYW1lIGluIGRiVHdpbi5zaW11bGF0ZSkge1xyXG4gICAgICAgICAgICBzdG9yZWRQb3NpdGlvbnNbc2ltTm9kZU5hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgeDogbGF5b3V0RGV0YWlsW2luZF1bMF0gLSA2MFxyXG4gICAgICAgICAgICAgICAgLCB5OiBsYXlvdXREZXRhaWxbaW5kXVsxXSAtIHBhcnNlSW50KChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEyMClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBuZXdMYXlvdXQ9dGhpcy5jb3JlLmxheW91dCh7XHJcbiAgICAgICAgbmFtZTogJ3ByZXNldCcsXHJcbiAgICAgICAgcG9zaXRpb25zOnN0b3JlZFBvc2l0aW9ucyxcclxuICAgICAgICBmaXQ6ZmFsc2UsXHJcbiAgICAgICAgYW5pbWF0ZTogKChub0FuaW1hdGlvbik/ZmFsc2U6dHJ1ZSksXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDMwMCxcclxuICAgIH0pXHJcbiAgICBuZXdMYXlvdXQucnVuKClcclxuICAgIGlmKGNlbnRlck5vZGVzKXtcclxuICAgICAgICBuZXdMYXlvdXQub24oXCJsYXlvdXRzdG9wXCIsKCk9PntcclxuICAgICAgICAgICAgdGhpcy5jb3JlLmFuaW1hdGUoe1wiZml0XCI6e1wiZWxlc1wiOnRoaXMuY29yZS5ub2RlcygpLFwicGFkZGluZ1wiOlwiMTAwXCJ9fSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvL3Jlc3RvcmUgZWRnZXMgYmVuZGluZyBvciBjb250cm9sIHBvaW50c1xyXG4gICAgdmFyIGVkZ2VQb2ludHNEaWN0PWxheW91dERldGFpbFtcImVkZ2VzXCJdXHJcbiAgICBpZihlZGdlUG9pbnRzRGljdD09bnVsbClyZXR1cm47XHJcbiAgICBmb3IodmFyIHNyY0lEIGluIGVkZ2VQb2ludHNEaWN0KXtcclxuICAgICAgICBmb3IodmFyIHJlbGF0aW9uc2hpcElEIGluIGVkZ2VQb2ludHNEaWN0W3NyY0lEXSl7XHJcbiAgICAgICAgICAgIHZhciBvYmo9ZWRnZVBvaW50c0RpY3Rbc3JjSURdW3JlbGF0aW9uc2hpcElEXVxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5RWRnZUJlbmRjb250cm9sUG9pbnRzKHNyY0lELHJlbGF0aW9uc2hpcElELG9ialtcImN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0c1wiXVxyXG4gICAgICAgICAgICAsb2JqW1wiY3llZGdlYmVuZGVkaXRpbmdEaXN0YW5jZXNcIl0sb2JqW1wiY3llZGdlY29udHJvbGVkaXRpbmdXZWlnaHRzXCJdLG9ialtcImN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzXCJdKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5hcHBseU5vZGVTY2FsZVJvdGF0ZT1mdW5jdGlvbih0d2luTmFtZSxzY2FsZUYscm90YXRlRil7XHJcbiAgICB2YXIgdGhlTm9kZT10aGlzLmNvcmUuZmlsdGVyKCdbaWQgPSBcIicrdHdpbk5hbWUrJ1wiXScpO1xyXG4gICAgaWYodGhlTm9kZS5sZW5ndGg9PTApIHJldHVybjtcclxuICAgIHRoZU5vZGU9dGhlTm9kZVswXVxyXG4gICAgaWYoc2NhbGVGIHx8IHJvdGF0ZUYpe1xyXG4gICAgICAgIGlmKHNjYWxlRikgdGhlTm9kZS5kYXRhKFwic2NhbGVGYWN0b3JcIixzY2FsZUYpXHJcbiAgICAgICAgZWxzZSB0aGVOb2RlLnJlbW92ZURhdGEoXCJzY2FsZUZhY3RvclwiKVxyXG4gICAgICAgIGlmKHJvdGF0ZUYpIHRoZU5vZGUuZGF0YShcInJvdGF0ZUFuZ2xlXCIscm90YXRlRilcclxuICAgICAgICBlbHNlIHRoZU5vZGUucmVtb3ZlRGF0YShcInJvdGF0ZUFuZ2xlXCIpXHJcbiAgICAgICAgdGhlTm9kZS5hZGRDbGFzcygnZWRnZWJlbmRlZGl0aW5nX3NjYWxlUm90YXRlJyk7XHJcbiAgICB9ZWxzZSB0aGVOb2RlLnJlbW92ZUNsYXNzKCdlZGdlYmVuZGVkaXRpbmdfc2NhbGVSb3RhdGUnKTtcclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5hcHBseUVkZ2VCZW5kY29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChzcmNJRCxyZWxhdGlvbnNoaXBJRFxyXG4gICAgLGN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0cyxjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlcyxjeWVkZ2Vjb250cm9sZWRpdGluZ1dlaWdodHMsY3llZGdlY29udHJvbGVkaXRpbmdEaXN0YW5jZXMpIHtcclxuICAgICAgICB2YXIgbm9kZU5hbWU9Z2xvYmFsQ2FjaGUudHdpbklETWFwVG9EaXNwbGF5TmFtZVtzcmNJRF1cclxuICAgICAgICB2YXIgdGhlTm9kZT10aGlzLmNvcmUuZmlsdGVyKCdbaWQgPSBcIicrbm9kZU5hbWUrJ1wiXScpO1xyXG4gICAgICAgIGlmKHRoZU5vZGUubGVuZ3RoPT0wKSByZXR1cm47XHJcbiAgICAgICAgdmFyIGVkZ2VzPXRoZU5vZGUuY29ubmVjdGVkRWRnZXMoKS50b0FycmF5KClcclxuICAgICAgICBmb3IodmFyIGk9MDtpPGVkZ2VzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB2YXIgYW5FZGdlPWVkZ2VzW2ldXHJcbiAgICAgICAgICAgIGlmKGFuRWRnZS5kYXRhKCkubm90VHdpbikgY29udGludWVcclxuICAgICAgICAgICAgaWYoYW5FZGdlLmRhdGEoXCJvcmlnaW5hbEluZm9cIilbXCIkcmVsYXRpb25zaGlwSWRcIl09PXJlbGF0aW9uc2hpcElEKXtcclxuICAgICAgICAgICAgICAgIGlmKGN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5FZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ1dlaWdodHNcIixjeWVkZ2ViZW5kZWRpdGluZ1dlaWdodHMpXHJcbiAgICAgICAgICAgICAgICAgICAgYW5FZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlc1wiLGN5ZWRnZWJlbmRlZGl0aW5nRGlzdGFuY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIGFuRWRnZS5hZGRDbGFzcygnZWRnZWJlbmRlZGl0aW5nLWhhc2JlbmRwb2ludHMnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGN5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ2h0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5FZGdlLmRhdGEoXCJjeWVkZ2Vjb250cm9sZWRpdGluZ1dlaWdodHNcIixjeWVkZ2Vjb250cm9sZWRpdGluZ1dlaWdodHMpXHJcbiAgICAgICAgICAgICAgICAgICAgYW5FZGdlLmRhdGEoXCJjeWVkZ2Vjb250cm9sZWRpdGluZ0Rpc3RhbmNlc1wiLGN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIGFuRWRnZS5hZGRDbGFzcygnZWRnZWNvbnRyb2xlZGl0aW5nLWhhc2NvbnRyb2xwb2ludHMnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5hcHBseUN1cnJlbnRMYXlvdXRXaXRoTm9BbmltdGFpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbGF5b3V0TmFtZSA9IGdsb2JhbENhY2hlLmN1cnJlbnRMYXlvdXROYW1lXHJcbiAgICBpZiAobGF5b3V0TmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGxheW91dERldGFpbCA9IGdsb2JhbENhY2hlLmxheW91dEpTT05bbGF5b3V0TmFtZV0uZGV0YWlsXHJcbiAgICAgICAgaWYgKGxheW91dERldGFpbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhd0Jhc2VkT25MYXlvdXREZXRhaWwobGF5b3V0RGV0YWlsLCBudWxsLCBcIm5vQW5pbWF0aW9uXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5jb3JlLmZpdCh0aGlzLmNvcmUubm9kZXMoKSlcclxufVxyXG5cclxudG9wb2xvZ3lET01fdmlzdWFsLnByb3RvdHlwZS5hcHBseU5ld0xheW91dFdpdGhVbmRvID0gZnVuY3Rpb24gKG5ld0xheW91dERldGFpbCxvbGRMYXlvdXREZXRhaWwsb25seUFkanVzdE5vZGVQb3NpdGlvbixjZW50ZXJOb2Rlcykge1xyXG4gICAgLy9zdG9yZSBjdXJyZW50IGxheW91dCBmb3IgdW5kbyBvcGVyYXRpb25cclxuICAgIHRoaXMudXIuYWN0aW9uKCBcImNoYW5nZUxheW91dFwiXHJcbiAgICAgICAgLCAoYXJnKT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhd0Jhc2VkT25MYXlvdXREZXRhaWwoYXJnLm5ld0xheW91dERldGFpbCxhcmcub25seUFkanVzdE5vZGVQb3NpdGlvbixudWxsLGNlbnRlck5vZGVzKSAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBhcmdcclxuICAgICAgICB9XHJcbiAgICAgICAgLCAoYXJnKT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhd0Jhc2VkT25MYXlvdXREZXRhaWwoYXJnLm9sZExheW91dERldGFpbCxhcmcub25seUFkanVzdE5vZGVQb3NpdGlvbixudWxsLGNlbnRlck5vZGVzKVxyXG4gICAgICAgICAgICByZXR1cm4gYXJnXHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG4gICAgdGhpcy51ci5kbyhcImNoYW5nZUxheW91dFwiXHJcbiAgICAgICAgLCB7IGZpcnN0VGltZTogdHJ1ZSwgXCJuZXdMYXlvdXREZXRhaWxcIjogbmV3TGF5b3V0RGV0YWlsLCBcIm9sZExheW91dERldGFpbFwiOiBvbGRMYXlvdXREZXRhaWwsXCJvbmx5QWRqdXN0Tm9kZVBvc2l0aW9uXCI6b25seUFkanVzdE5vZGVQb3NpdGlvbn1cclxuICAgIClcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB0b3BvbG9neURPTV92aXN1YWw7IiwiY29uc3Qgc2ltcGxlVHJlZT1yZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlVHJlZVwiKVxyXG5jb25zdCBtb2RlbEFuYWx5emVyPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEFuYWx5emVyXCIpXHJcbmNvbnN0IG1zYWxIZWxwZXIgPSByZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBuZXdUd2luRGlhbG9nPXJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9uZXdUd2luRGlhbG9nXCIpO1xyXG5cclxuZnVuY3Rpb24gdHdpbnNUcmVlKERPTSwgc2VhcmNoRE9NKSB7XHJcbiAgICB0aGlzLnRyZWU9bmV3IHNpbXBsZVRyZWUoRE9NLHtcImxlYWZOYW1lUHJvcGVydHlcIjpcImRpc3BsYXlOYW1lXCJ9KVxyXG5cclxuICAgIHRoaXMudHJlZS5vcHRpb25zLmdyb3VwTm9kZUljb25GdW5jPShnbik9PntcclxuICAgICAgICByZXR1cm4gZ2xvYmFsQ2FjaGUuZ2VuZXJhdGVNb2RlbEljb24oZ24uaW5mb1tcIkBpZFwiXSlcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyZWUub3B0aW9ucy5ncm91cE5vZGVUYWlsQnV0dG9uRnVuYyA9IChnbikgPT4ge1xyXG4gICAgICAgIHZhciBhZGRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yZWQgdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cImZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjRweCA4cHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtoZWlnaHQ6MjdweDsgcmlnaHQ6MTBweDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKVwiPis8L2J1dHRvbj4nKVxyXG4gICAgICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGduLmV4cGFuZCgpXHJcbiAgICAgICAgICAgIG5ld1R3aW5EaWFsb2cucG9wdXAoe1xyXG4gICAgICAgICAgICAgICAgXCIkbWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiJG1vZGVsXCI6IGduLmluZm9bXCJAaWRcIl1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gYWRkQnV0dG9uO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJlZS5jYWxsYmFja19hZnRlclNlbGVjdE5vZGVzPShub2Rlc0Fycixtb3VzZUNsaWNrRGV0YWlsKT0+e1xyXG4gICAgICAgIHZhciBpbmZvQXJyPVtdXHJcbiAgICAgICAgbm9kZXNBcnIuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+e1xyXG4gICAgICAgICAgICBpbmZvQXJyLnB1c2goaXRlbS5sZWFmSW5mbylcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJzaG93SW5mb1NlbGVjdGVkTm9kZXNcIiwgaW5mbzppbmZvQXJyLCBcIm1vdXNlQ2xpY2tEZXRhaWxcIjptb3VzZUNsaWNrRGV0YWlsfSlcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyZWUuY2FsbGJhY2tfYWZ0ZXJEYmxjbGlja05vZGU9KHRoZU5vZGUpPT57XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiUGFuVG9Ob2RlXCIsIGluZm86dGhlTm9kZS5sZWFmSW5mb30pXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZWFyY2hCb3g9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgIHBsYWNlaG9sZGVyPVwic2VhcmNoLi4uXCIvPicpLmFkZENsYXNzKFwidzMtaW5wdXRcIik7XHJcbiAgICB0aGlzLnNlYXJjaEJveC5jc3Moe1wib3V0bGluZVwiOlwibm9uZVwiLFwiaGVpZ2h0XCI6XCIxMDAlXCIsXCJ3aWR0aFwiOlwiMTAwJVwifSkgXHJcbiAgICBzZWFyY2hET00uYXBwZW5kKHRoaXMuc2VhcmNoQm94KVxyXG4gICAgdmFyIGhpZGVPclNob3dFbXB0eUdyb3VwPSQoJzxidXR0b24gc3R5bGU9XCJoZWlnaHQ6MjBweDtib3JkZXI6bm9uZTtwYWRkaW5nLWxlZnQ6MnB4XCIgY2xhc3M9XCJ3My1yaXBwbGUgdzMtYmxvY2sgdzMtdGlueSB3My1ob3Zlci1yZWQgdzMtYW1iZXJcIj5IaWRlIEVtcHR5IE1vZGVsczwvYnV0dG9uPicpXHJcbiAgICBzZWFyY2hET00uYXBwZW5kKGhpZGVPclNob3dFbXB0eUdyb3VwKVxyXG4gICAgRE9NLmNzcyhcInRvcFwiLFwiNTBweFwiKVxyXG4gICAgaGlkZU9yU2hvd0VtcHR5R3JvdXAuYXR0cihcInN0YXR1c1wiLFwic2hvd1wiKVxyXG4gICAgaGlkZU9yU2hvd0VtcHR5R3JvdXAub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgaWYoaGlkZU9yU2hvd0VtcHR5R3JvdXAuYXR0cihcInN0YXR1c1wiKT09XCJzaG93XCIpe1xyXG4gICAgICAgICAgICBoaWRlT3JTaG93RW1wdHlHcm91cC5hdHRyKFwic3RhdHVzXCIsXCJoaWRlXCIpXHJcbiAgICAgICAgICAgIGhpZGVPclNob3dFbXB0eUdyb3VwLnRleHQoXCJTaG93IEVtcHR5IE1vZGVsc1wiKVxyXG4gICAgICAgICAgICB0aGlzLnRyZWUub3B0aW9ucy5oaWRlRW1wdHlHcm91cD10cnVlXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGhpZGVPclNob3dFbXB0eUdyb3VwLmF0dHIoXCJzdGF0dXNcIixcInNob3dcIilcclxuICAgICAgICAgICAgaGlkZU9yU2hvd0VtcHR5R3JvdXAudGV4dChcIkhpZGUgRW1wdHkgTW9kZWxzXCIpXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRyZWUub3B0aW9ucy5oaWRlRW1wdHlHcm91cFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyZWUuZ3JvdXBOb2Rlcy5mb3JFYWNoKG9uZUdyb3VwTm9kZT0+e29uZUdyb3VwTm9kZS5jaGVja09wdGlvbkhpZGVFbXB0eUdyb3VwKCl9KVxyXG4gICAgfSlcclxuICAgIHRoaXMuc2VhcmNoQm94LmtleXVwKChlKT0+e1xyXG4gICAgICAgIGlmKGUua2V5Q29kZSA9PSAxMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBhTm9kZSA9IHRoaXMudHJlZS5zZWFyY2hUZXh0KCQoZS50YXJnZXQpLnZhbCgpKVxyXG4gICAgICAgICAgICBpZihhTm9kZSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBhTm9kZS5wYXJlbnRHcm91cE5vZGUuZXhwYW5kKClcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5zZWxlY3RMZWFmTm9kZShhTm9kZSlcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5zY3JvbGxUb0xlYWZOb2RlKGFOb2RlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR3aW5zVHJlZS5wcm90b3R5cGUucnhNZXNzYWdlPWZ1bmN0aW9uKG1zZ1BheWxvYWQpe1xyXG4gICAgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cInN0YXJ0U2VsZWN0aW9uX3JlcGxhY2VcIikgdGhpcy5sb2FkU3RhcnRTZWxlY3Rpb24obXNnUGF5bG9hZC50d2luSURzLG1zZ1BheWxvYWQubW9kZWxJRHMsXCJyZXBsYWNlXCIpXHJcbiAgICBlbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJzdGFydFNlbGVjdGlvbl9hcHBlbmRcIikgdGhpcy5sb2FkU3RhcnRTZWxlY3Rpb24obXNnUGF5bG9hZC50d2luSURzLG1zZ1BheWxvYWQubW9kZWxJRHMsXCJhcHBlbmRcIilcclxuICAgIGVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImRyYXdUd2luc0FuZFJlbGF0aW9uc1wiKSB0aGlzLmRyYXdUd2luc0FuZFJlbGF0aW9ucyhtc2dQYXlsb2FkLmluZm8pXHJcbiAgICBlbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJBRFRNb2RlbHNDaGFuZ2VcIikgdGhpcy5yZWZyZXNoTW9kZWxzKClcclxuICAgIGVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImFkZE5ld1R3aW5cIikgdGhpcy5kcmF3T25lVHdpbihtc2dQYXlsb2FkLnR3aW5JbmZvKVxyXG4gICAgZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwiYWRkTmV3VHdpbnNcIikgbXNnUGF5bG9hZC50d2luc0luZm8uZm9yRWFjaChvbmVUd2luSW5mbz0+e3RoaXMuZHJhd09uZVR3aW4ob25lVHdpbkluZm8pfSlcclxuICAgIGVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cInR3aW5zRGVsZXRlZFwiKSB0aGlzLmhpZGVUd2lucyhtc2dQYXlsb2FkLnR3aW5JREFycilcclxuICAgIGVsc2UgaWYobXNnUGF5bG9hZC5tZXNzYWdlPT1cImhpZGVTZWxlY3RlZE5vZGVzXCIpIHRoaXMuaGlkZVR3aW5zKG1zZ1BheWxvYWQudHdpbklEQXJyKVxyXG4gICAgZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwidmlzdWFsRGVmaW5pdGlvbkNoYW5nZVwiKXtcclxuICAgICAgICBpZighbXNnUGF5bG9hZC5zcmNNb2RlbElEKXsgLy8gY2hhbmdlIG1vZGVsIGNsYXNzIHZpc3VhbGl6YXRpb25cclxuICAgICAgICAgICAgdGhpcy50cmVlLmdyb3VwTm9kZXMuZm9yRWFjaChnbj0+e2duLnJlZnJlc2hOYW1lKCl9KVxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcbn1cclxuXHJcbnR3aW5zVHJlZS5wcm90b3R5cGUuaGlkZVR3aW5zPWZ1bmN0aW9uKHR3aW5JREFycil7XHJcbiAgICB0d2luSURBcnIuZm9yRWFjaCh0d2luSUQ9PntcclxuICAgICAgICB2YXIgdHdpbkRpc3BsYXlOYW1lPWdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbdHdpbklEXVxyXG4gICAgICAgIHRoaXMudHJlZS5kZWxldGVMZWFmTm9kZSh0d2luRGlzcGxheU5hbWUpXHJcbiAgICB9KVxyXG59XHJcblxyXG50d2luc1RyZWUucHJvdG90eXBlLnJlZnJlc2hNb2RlbHM9ZnVuY3Rpb24oKXtcclxuICAgIHZhciBtb2RlbHNEYXRhPXt9XHJcbiAgICBmb3IodmFyIG1vZGVsSUQgaW4gbW9kZWxBbmFseXplci5EVERMTW9kZWxzKXtcclxuICAgICAgICB2YXIgb25lTW9kZWw9bW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdXHJcbiAgICAgICAgbW9kZWxzRGF0YVtvbmVNb2RlbFtcImRpc3BsYXlOYW1lXCJdXSA9IG9uZU1vZGVsXHJcbiAgICB9XHJcbiAgICAvL2RlbGV0ZSBhbGwgZ3JvdXAgbm9kZXMgb2YgZGVsZXRlZCBtb2RlbHNcclxuICAgIHZhciBhcnI9W10uY29uY2F0KHRoaXMudHJlZS5ncm91cE5vZGVzKVxyXG4gICAgYXJyLmZvckVhY2goKGdub2RlKT0+e1xyXG4gICAgICAgIGlmKG1vZGVsc0RhdGFbZ25vZGUubmFtZV09PW51bGwpe1xyXG4gICAgICAgICAgICAvL2RlbGV0ZSB0aGlzIGdyb3VwIG5vZGVcclxuICAgICAgICAgICAgZ25vZGUuZGVsZXRlU2VsZigpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL3RoZW4gYWRkIGFsbCBncm91cCBub2RlcyB0aGF0IHRvIGJlIGFkZGVkXHJcbiAgICB2YXIgY3VycmVudE1vZGVsTmFtZUFycj1bXVxyXG4gICAgdGhpcy50cmVlLmdyb3VwTm9kZXMuZm9yRWFjaCgoZ25vZGUpPT57Y3VycmVudE1vZGVsTmFtZUFyci5wdXNoKGdub2RlLm5hbWUpfSlcclxuXHJcbiAgICB2YXIgYWN0dWFsTW9kZWxOYW1lQXJyPVtdXHJcbiAgICBmb3IodmFyIGluZCBpbiBtb2RlbHNEYXRhKSBhY3R1YWxNb2RlbE5hbWVBcnIucHVzaChpbmQpXHJcbiAgICBhY3R1YWxNb2RlbE5hbWVBcnIuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoYi50b0xvd2VyQ2FzZSgpKSB9KTtcclxuXHJcbiAgICBmb3IodmFyIGk9MDtpPGFjdHVhbE1vZGVsTmFtZUFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICBpZihpPGN1cnJlbnRNb2RlbE5hbWVBcnIubGVuZ3RoICYmIGN1cnJlbnRNb2RlbE5hbWVBcnJbaV09PWFjdHVhbE1vZGVsTmFtZUFycltpXSkgY29udGludWVcclxuICAgICAgICAvL290aGVyd2lzZSBhZGQgdGhpcyBncm91cCB0byB0aGUgdHJlZVxyXG4gICAgICAgIHZhciBuZXdHcm91cD10aGlzLnRyZWUuaW5zZXJ0R3JvdXBOb2RlKG1vZGVsc0RhdGFbYWN0dWFsTW9kZWxOYW1lQXJyW2ldXSxpKVxyXG4gICAgICAgIG5ld0dyb3VwLnNocmluaygpXHJcbiAgICAgICAgY3VycmVudE1vZGVsTmFtZUFyci5zcGxpY2UoaSwgMCwgYWN0dWFsTW9kZWxOYW1lQXJyW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbnR3aW5zVHJlZS5wcm90b3R5cGUubG9hZFN0YXJ0U2VsZWN0aW9uPWFzeW5jIGZ1bmN0aW9uKHR3aW5JRHMsbW9kZWxJRHMscmVwbGFjZU9yQXBwZW5kKXtcclxuICAgIGlmKHJlcGxhY2VPckFwcGVuZD09XCJyZXBsYWNlXCIpIHRoaXMudHJlZS5jbGVhckFsbExlYWZOb2RlcygpXHJcblxyXG4gICAgXHJcbiAgICB0aGlzLnJlZnJlc2hNb2RlbHMoKVxyXG4gICAgXHJcbiAgICAvL2FkZCBuZXcgdHdpbnMgdW5kZXIgdGhlIG1vZGVsIGdyb3VwIG5vZGVcclxuICAgIHRyeXtcclxuICAgICAgICB2YXIgdHdpbnNkYXRhID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vbGlzdFR3aW5zRm9ySURzXCIsIFwiUE9TVFwiLCB0d2luSURzKVxyXG4gICAgICAgIHZhciB0d2luSURBcnIgPSBbXVxyXG4gICAgICAgIC8vY2hlY2sgaWYgYW55IGN1cnJlbnQgbGVhZiBub2RlIGRvZXMgbm90IGhhdmUgc3RvcmVkIG91dGJvdW5kIHJlbGF0aW9uc2hpcCBkYXRhIHlldFxyXG4gICAgICAgIHRoaXMudHJlZS5ncm91cE5vZGVzLmZvckVhY2goKGdOb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGdOb2RlLmNoaWxkTGVhZk5vZGVzLmZvckVhY2gobGVhZk5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJZCA9IGxlYWZOb2RlLmxlYWZJbmZvW1wiJGR0SWRcIl1cclxuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxDYWNoZS5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHNbbm9kZUlkXSA9PSBudWxsKSB0d2luSURBcnIucHVzaChub2RlSWQpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVBRFRUd2lucyh0d2luc2RhdGEpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0d2luc2RhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGdsb2JhbENhY2hlLm1vZGVsSURNYXBUb05hbWVbdHdpbnNkYXRhW2ldW1wiJG1ldGFkYXRhXCJdW1wiJG1vZGVsXCJdXVxyXG4gICAgICAgICAgICB0aGlzLnRyZWUuYWRkTGVhZm5vZGVUb0dyb3VwKGdyb3VwTmFtZSwgdHdpbnNkYXRhW2ldLCBcInNraXBSZXBlYXRcIilcclxuICAgICAgICAgICAgdHdpbklEQXJyLnB1c2godHdpbnNkYXRhW2ldW1wiJGR0SWRcIl0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHJlcGxhY2VPckFwcGVuZD09XCJyZXBsYWNlXCIpIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInJlcGxhY2VBbGxUd2luc1wiLCBpbmZvOiB0d2luc2RhdGEgfSlcclxuICAgICAgICBlbHNlIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcImFwcGVuZEFsbFR3aW5zXCIsIGluZm86IHR3aW5zZGF0YSB9KVxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICB0aGlzLmZldGNoQWxsUmVsYXRpb25zaGlwcyh0d2luSURBcnIpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICB9XHJcbn1cclxuXHJcbnR3aW5zVHJlZS5wcm90b3R5cGUuZHJhd1R3aW5zQW5kUmVsYXRpb25zPSBmdW5jdGlvbihkYXRhKXtcclxuICAgIGRhdGEuY2hpbGRUd2luc0FuZFJlbGF0aW9ucy5mb3JFYWNoKG9uZVNldD0+e1xyXG4gICAgICAgIGZvcih2YXIgaW5kIGluIG9uZVNldC5jaGlsZFR3aW5zKXtcclxuICAgICAgICAgICAgdmFyIG9uZVR3aW49b25lU2V0LmNoaWxkVHdpbnNbaW5kXVxyXG4gICAgICAgICAgICB0aGlzLmRyYXdPbmVUd2luKG9uZVR3aW4pXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgIFxyXG4gICAgLy9kcmF3IHRob3NlIGtub3duIHR3aW5zIGZyb20gdGhlIHJlbGF0aW9uc2hpcHNcclxuICAgIHZhciB0d2luc0luZm89e31cclxuICAgIGRhdGEuY2hpbGRUd2luc0FuZFJlbGF0aW9ucy5mb3JFYWNoKG9uZVNldD0+e1xyXG4gICAgICAgIHZhciByZWxhdGlvbnNJbmZvPW9uZVNldFtcInJlbGF0aW9uc2hpcHNcIl1cclxuICAgICAgICByZWxhdGlvbnNJbmZvLmZvckVhY2goKG9uZVJlbGF0aW9uKT0+e1xyXG4gICAgICAgICAgICB2YXIgc3JjSUQ9b25lUmVsYXRpb25bJyRzb3VyY2VJZCddXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRJRD1vbmVSZWxhdGlvblsnJHRhcmdldElkJ11cclxuICAgICAgICAgICAgaWYoZ2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbc3JjSURdKVxyXG4gICAgICAgICAgICAgICAgdHdpbnNJbmZvW3NyY0lEXSA9IGdsb2JhbENhY2hlLnN0b3JlZFR3aW5zW3NyY0lEXVxyXG4gICAgICAgICAgICBpZihnbG9iYWxDYWNoZS5zdG9yZWRUd2luc1t0YXJnZXRJRF0pXHJcbiAgICAgICAgICAgICAgICB0d2luc0luZm9bdGFyZ2V0SURdID0gZ2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbdGFyZ2V0SURdICAgIFxyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgdmFyIHRtcEFycj1bXVxyXG4gICAgZm9yKHZhciB0d2luSUQgaW4gdHdpbnNJbmZvKSB0bXBBcnIucHVzaCh0d2luc0luZm9bdHdpbklEXSlcclxuICAgIHRtcEFyci5mb3JFYWNoKG9uZVR3aW49Pnt0aGlzLmRyYXdPbmVUd2luKG9uZVR3aW4pfSlcclxufVxyXG5cclxudHdpbnNUcmVlLnByb3RvdHlwZS5kcmF3T25lVHdpbj0gZnVuY3Rpb24odHdpbkluZm8pe1xyXG4gICAgdmFyIGdyb3VwTmFtZT1nbG9iYWxDYWNoZS5tb2RlbElETWFwVG9OYW1lW3R3aW5JbmZvW1wiJG1ldGFkYXRhXCJdW1wiJG1vZGVsXCJdXVxyXG4gICAgdGhpcy50cmVlLmFkZExlYWZub2RlVG9Hcm91cChncm91cE5hbWUsdHdpbkluZm8sXCJza2lwUmVwZWF0XCIpXHJcbn1cclxuXHJcbnR3aW5zVHJlZS5wcm90b3R5cGUuZmV0Y2hBbGxSZWxhdGlvbnNoaXBzPSBhc3luYyBmdW5jdGlvbih0d2luSURBcnIpe1xyXG4gICAgd2hpbGUodHdpbklEQXJyLmxlbmd0aD4wKXtcclxuICAgICAgICB2YXIgc21hbGxBcnI9IHR3aW5JREFyci5zcGxpY2UoMCwgMTAwKTtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vZ2V0UmVsYXRpb25zaGlwc0Zyb21Ud2luSURzXCIsIFwiUE9TVFwiLCBzbWFsbEFycilcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gXCJcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGdsb2JhbENhY2hlLnN0b3JlVHdpblJlbGF0aW9uc2hpcHMoZGF0YSkgLy9zdG9yZSB0aGVtIGluIGdsb2JhbCBhdmFpbGFibGUgYXJyYXlcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiZHJhd0FsbFJlbGF0aW9uc1wiLCBpbmZvOiBkYXRhIH0pXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHR3aW5zVHJlZTsiLCJjb25zdCBzaWdudXBzaWduaW5uYW1lPVwiQjJDXzFfc2luZ3Vwc2lnbmluX3NwYWFwcDFcIlxyXG5jb25zdCBiMmNUZW5hbnROYW1lPVwiYXp1cmVpb3RiMmNcIlxyXG5cclxuY29uc3QgdXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcblxyXG52YXIgc3RyQXJyPXdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiP1wiKVxyXG52YXIgaXNMb2NhbFRlc3Q9KHN0ckFyci5pbmRleE9mKFwidGVzdD0xXCIpIT0tMSlcclxuXHJcbmNvbnN0IGdsb2JhbEFwcFNldHRpbmdzPXtcclxuICAgIFwiYjJjU2lnblVwU2lnbkluTmFtZVwiOiBzaWdudXBzaWduaW5uYW1lLFxyXG4gICAgXCJiMmNTY29wZV90YXNrbWFzdGVyXCI6XCJodHRwczovL1wiK2IyY1RlbmFudE5hbWUrXCIub25taWNyb3NvZnQuY29tL3Rhc2ttYXN0ZXJtb2R1bGUvb3BlcmF0aW9uXCIsXHJcbiAgICBcImIyY1Njb3BlX2Z1bmN0aW9uc1wiOlwiaHR0cHM6Ly9cIitiMmNUZW5hbnROYW1lK1wiLm9ubWljcm9zb2Z0LmNvbS9henVyZWlvdHJvY2tzZnVuY3Rpb25zL2Jhc2ljXCIsXHJcbiAgICBcImxvZ291dFJlZGlyZWN0VXJpXCI6IHVybC5vcmlnaW4rXCIvc3BhaW5kZXguaHRtbFwiLFxyXG4gICAgXCJtc2FsQ29uZmlnXCI6e1xyXG4gICAgICAgIGF1dGg6IHtcclxuICAgICAgICAgICAgY2xpZW50SWQ6IFwiZjQ2OTNiZTUtNjAxYi00ZDBlLTkyMDgtYzM1ZDlhZDYyMzg3XCIsXHJcbiAgICAgICAgICAgIGF1dGhvcml0eTogXCJodHRwczovL1wiK2IyY1RlbmFudE5hbWUrXCIuYjJjbG9naW4uY29tL1wiK2IyY1RlbmFudE5hbWUrXCIub25taWNyb3NvZnQuY29tL1wiK3NpZ251cHNpZ25pbm5hbWUsXHJcbiAgICAgICAgICAgIGtub3duQXV0aG9yaXRpZXM6IFtiMmNUZW5hbnROYW1lK1wiLmIyY2xvZ2luLmNvbVwiXSxcclxuICAgICAgICAgICAgcmVkaXJlY3RVcmk6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWNoZToge1xyXG4gICAgICAgICAgICBjYWNoZUxvY2F0aW9uOiBcInNlc3Npb25TdG9yYWdlXCIsIFxyXG4gICAgICAgICAgICBzdG9yZUF1dGhTdGF0ZUluQ29va2llOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3lzdGVtOiB7XHJcbiAgICAgICAgICAgIGxvZ2dlck9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlckNhbGxiYWNrOiAobGV2ZWwsIG1lc3NhZ2UsIGNvbnRhaW5zUGlpKSA9PiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiaXNMb2NhbFRlc3RcIjppc0xvY2FsVGVzdCxcclxuICAgIFwidGFza01hc3RlckFQSVVSSVwiOigoaXNMb2NhbFRlc3QpP1wiaHR0cDovL2xvY2FsaG9zdDo1MDAyL1wiOlwiaHR0cHM6Ly9henVyZWlvdHJvY2tzdGFza21hc3Rlcm1vZHVsZS5henVyZXdlYnNpdGVzLm5ldC9cIiksXHJcbiAgICBcImZ1bmN0aW9uc0FQSVVSSVwiOlwiaHR0cHM6Ly9henVyZWlvdHJvY2tzZnVuY3Rpb25zLmF6dXJld2Vic2l0ZXMubmV0L2FwaS9cIlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbEFwcFNldHRpbmdzOyIsImNvbnN0IGdsb2JhbEFwcFNldHRpbmdzPXJlcXVpcmUoXCIuL2dsb2JhbEFwcFNldHRpbmdzXCIpXHJcbmNvbnN0IGdsb2JhbENhY2hlPXJlcXVpcmUoXCIuL3NoYXJlZFNvdXJjZUZpbGVzL2dsb2JhbENhY2hlXCIpXHJcblxyXG5cclxuZnVuY3Rpb24gbXNhbEhlbHBlcigpe1xyXG4gICAgdGhpcy5teU1TQUxPYmogPSBuZXcgbXNhbC5QdWJsaWNDbGllbnRBcHBsaWNhdGlvbihnbG9iYWxBcHBTZXR0aW5ncy5tc2FsQ29uZmlnKTtcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUuc2lnbkluPWFzeW5jIGZ1bmN0aW9uKCl7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgdmFyIHJlc3BvbnNlPSBhd2FpdCB0aGlzLm15TVNBTE9iai5sb2dpblBvcHVwKHsgc2NvcGVzOltdICB9KSAvL2dsb2JhbEFwcFNldHRpbmdzLmIyY1Njb3Blc1xyXG4gICAgICAgIGlmIChyZXNwb25zZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5zZXRBY2NvdW50KHJlc3BvbnNlLmFjY291bnQpXHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hY2NvdW50XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlICByZXR1cm4gdGhpcy5mZXRjaEFjY291bnQoKVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGlmKGUuZXJyb3JDb2RlIT1cInVzZXJfY2FuY2VsbGVkXCIpIGNvbnNvbGUubG9nKGUpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1zYWxIZWxwZXIucHJvdG90eXBlLnNldEFjY291bnQ9ZnVuY3Rpb24odGhlQWNjb3VudCl7XHJcbiAgICBpZih0aGVBY2NvdW50PT1udWxsKXJldHVybjtcclxuICAgIHRoaXMuYWNjb3VudElkID0gdGhlQWNjb3VudC5ob21lQWNjb3VudElkO1xyXG4gICAgdGhpcy5hY2NvdW50TmFtZSA9IHRoZUFjY291bnQudXNlcm5hbWU7XHJcbiAgICB0aGlzLnVzZXJOYW1lPXRoZUFjY291bnQubmFtZTtcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUuZmV0Y2hBY2NvdW50PWZ1bmN0aW9uKCl7XHJcbiAgICBjb25zdCBjdXJyZW50QWNjb3VudHMgPSB0aGlzLm15TVNBTE9iai5nZXRBbGxBY2NvdW50cygpO1xyXG4gICAgaWYgKGN1cnJlbnRBY2NvdW50cy5sZW5ndGggPCAxKSByZXR1cm47XHJcbiAgICB2YXIgZm91bmRBY2NvdW50PW51bGw7XHJcbiAgICBmb3IodmFyIGk9MDtpPGN1cnJlbnRBY2NvdW50cy5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIgYW5BY2NvdW50PSBjdXJyZW50QWNjb3VudHNbaV1cclxuICAgICAgICBpZihhbkFjY291bnQuaG9tZUFjY291bnRJZC50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKGdsb2JhbEFwcFNldHRpbmdzLmIyY1NpZ25VcFNpZ25Jbk5hbWUudG9VcHBlckNhc2UoKSlcclxuICAgICAgICAgICAgJiYgYW5BY2NvdW50LmlkVG9rZW5DbGFpbXMuaXNzLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoZ2xvYmFsQXBwU2V0dGluZ3MubXNhbENvbmZpZy5hdXRoLmtub3duQXV0aG9yaXRpZXNbMF0udG9VcHBlckNhc2UoKSlcclxuICAgICAgICAgICAgJiYgYW5BY2NvdW50LmlkVG9rZW5DbGFpbXMuYXVkID09PSBnbG9iYWxBcHBTZXR0aW5ncy5tc2FsQ29uZmlnLmF1dGguY2xpZW50SWRcclxuICAgICAgICApe1xyXG4gICAgICAgICAgICBmb3VuZEFjY291bnQ9IGFuQWNjb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldEFjY291bnQoZm91bmRBY2NvdW50KVxyXG4gICAgcmV0dXJuIGZvdW5kQWNjb3VudDtcclxufVxyXG5cclxuXHJcbm1zYWxIZWxwZXIucHJvdG90eXBlLmNhbGxBenVyZUZ1bmN0aW9uc1NlcnZpY2U9YXN5bmMgZnVuY3Rpb24oQVBJU3RyaW5nLFJFU1RNZXRob2QscGF5bG9hZCl7XHJcbiAgICB2YXIgaGVhZGVyc09iaj17fVxyXG4gICAgdmFyIHRva2VuPWF3YWl0IHRoaXMuZ2V0VG9rZW4oZ2xvYmFsQXBwU2V0dGluZ3MuYjJjU2NvcGVfZnVuY3Rpb25zKVxyXG4gICAgaGVhZGVyc09ialtcIkF1dGhvcml6YXRpb25cIl09YEJlYXJlciAke3Rva2VufWBcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdmFyIGFqYXhDb250ZW50PXtcclxuICAgICAgICAgICAgdHlwZTogUkVTVE1ldGhvZCB8fCAnR0VUJyxcclxuICAgICAgICAgICAgXCJoZWFkZXJzXCI6aGVhZGVyc09iaixcclxuICAgICAgICAgICAgdXJsOiBnbG9iYWxBcHBTZXR0aW5ncy5mdW5jdGlvbnNBUElVUkkrQVBJU3RyaW5nLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGNyb3NzRG9tYWluOiB0cnVlLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZURhdGEpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlRGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihSRVNUTWV0aG9kPT1cIlBPU1RcIikgYWpheENvbnRlbnQuZGF0YT0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcclxuICAgICAgICAkLmFqYXgoYWpheENvbnRlbnQpO1xyXG4gICAgfSlcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUucGFyc2VKV1Q9ZnVuY3Rpb24odG9rZW4pe1xyXG4gICAgdmFyIGJhc2U2NFVybCA9IHRva2VuLnNwbGl0KCcuJylbMV07XHJcbiAgICB2YXIgYmFzZTY0ID0gYmFzZTY0VXJsLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XHJcbiAgICBiYXNlNjQ9IEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XHJcbiAgICB2YXIganNvblBheWxvYWQgPSBkZWNvZGVVUklDb21wb25lbnQoYmFzZTY0LnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oYykge1xyXG4gICAgICAgIHJldHVybiAnJScgKyAoJzAwJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcclxuICAgIH0pLmpvaW4oJycpKTtcclxuXHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uUGF5bG9hZCk7XHJcbn1cclxuXHJcbm1zYWxIZWxwZXIucHJvdG90eXBlLnJlbG9hZFVzZXJBY2NvdW50RGF0YT1hc3luYyBmdW5jdGlvbigpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIHZhciByZXM9YXdhaXQgdGhpcy5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvZmV0Y2hVc2VyRGF0YVwiKVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIHJldHVyblxyXG5cclxuICAgIH1cclxuICAgIGdsb2JhbENhY2hlLnN0b3JlVXNlckRhdGEocmVzKVxyXG59XHJcblxyXG5tc2FsSGVscGVyLnByb3RvdHlwZS5jYWxsQVBJPWFzeW5jIGZ1bmN0aW9uKEFQSVN0cmluZyxSRVNUTWV0aG9kLHBheWxvYWQsd2l0aFByb2plY3RJRCl7XHJcbiAgICB2YXIgaGVhZGVyc09iaj17fVxyXG4gICAgaWYod2l0aFByb2plY3RJRCl7XHJcbiAgICAgICAgcGF5bG9hZD1wYXlsb2FkfHx7fVxyXG4gICAgICAgIHBheWxvYWRbXCJwcm9qZWN0SURcIl09Z2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRFxyXG4gICAgfSBcclxuICAgIGlmKCFnbG9iYWxBcHBTZXR0aW5ncy5pc0xvY2FsVGVzdCl7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICB2YXIgdG9rZW49YXdhaXQgdGhpcy5nZXRUb2tlbihnbG9iYWxBcHBTZXR0aW5ncy5iMmNTY29wZV90YXNrbWFzdGVyKVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgd2luZG93Lm9wZW4oZ2xvYmFsQXBwU2V0dGluZ3MubG9nb3V0UmVkaXJlY3RVcmksXCJfc2VsZlwiKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBoZWFkZXJzT2JqW1wiQXV0aG9yaXphdGlvblwiXT1gQmVhcmVyICR7dG9rZW59YFxyXG5cclxuICAgICAgICAvL2luIGNhc2Ugam9pbmVkIHByb2plY3RzIEpXVCBpcyBnb2luZyB0byBleHBpcmUsIHJlbmV3IGFub3RoZXIgb25lXHJcbiAgICAgICAgaWYoZ2xvYmFsQ2FjaGUuam9pbmVkUHJvamVjdHNUb2tlbikge1xyXG4gICAgICAgICAgICB2YXIgZXhwVFM9dGhpcy5wYXJzZUpXVChnbG9iYWxDYWNoZS5qb2luZWRQcm9qZWN0c1Rva2VuKS5leHBcclxuICAgICAgICAgICAgdmFyIGN1cnJUaW1lPXBhcnNlSW50KG5ldyBEYXRlKCkuZ2V0VGltZSgpLzEwMDApXHJcbiAgICAgICAgICAgIGlmKGV4cFRTLWN1cnJUaW1lPDYwKXsgLy9mZXRjaCBhIG5ldyBwcm9qZWN0cyBKV1QgdG9rZW4gXHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZFVzZXJBY2NvdW50RGF0YSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgdGhlIEFQSSBuZWVkIHRvIHVzZSBwcm9qZWN0IElELCBtdXN0IGFkZCBhIGhlYWRlciBcInByb2plY3RzXCIgand0IHRva2VuIHNvIHNlcnZlciBzaWRlIHdpbGwgdmVyaWZ5XHJcbiAgICAgICAgaWYocGF5bG9hZCAmJiBwYXlsb2FkLnByb2plY3RJRCAmJiBnbG9iYWxDYWNoZS5qb2luZWRQcm9qZWN0c1Rva2VuKXtcclxuICAgICAgICAgICAgaGVhZGVyc09ialtcInByb2plY3RzXCJdPWdsb2JhbENhY2hlLmpvaW5lZFByb2plY3RzVG9rZW5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB2YXIgYWpheENvbnRlbnQ9e1xyXG4gICAgICAgICAgICB0eXBlOiBSRVNUTWV0aG9kIHx8ICdHRVQnLFxyXG4gICAgICAgICAgICBcImhlYWRlcnNcIjpoZWFkZXJzT2JqLFxyXG4gICAgICAgICAgICB1cmw6IGdsb2JhbEFwcFNldHRpbmdzLnRhc2tNYXN0ZXJBUElVUkkrQVBJU3RyaW5nLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGNyb3NzRG9tYWluOiB0cnVlLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZURhdGEpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlRGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihSRVNUTWV0aG9kPT1cIlBPU1RcIikgYWpheENvbnRlbnQuZGF0YT0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcclxuICAgICAgICAkLmFqYXgoYWpheENvbnRlbnQpO1xyXG4gICAgfSlcclxufVxyXG5cclxubXNhbEhlbHBlci5wcm90b3R5cGUuZ2V0VG9rZW49YXN5bmMgZnVuY3Rpb24oYjJjU2NvcGUpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGlmKHRoaXMuc3RvcmVkVG9rZW49PW51bGwpIHRoaXMuc3RvcmVkVG9rZW49e31cclxuICAgICAgICBpZih0aGlzLnN0b3JlZFRva2VuW2IyY1Njb3BlXSE9bnVsbCl7XHJcbiAgICAgICAgICAgIHZhciBjdXJyVGltZT1wYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKS8xMDAwKVxyXG4gICAgICAgICAgICBpZihjdXJyVGltZSs2MCA8IHRoaXMuc3RvcmVkVG9rZW5bYjJjU2NvcGVdLmV4cGlyZSkgcmV0dXJuIHRoaXMuc3RvcmVkVG9rZW5bYjJjU2NvcGVdLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0b2tlblJlcXVlc3Q9e1xyXG4gICAgICAgICAgICBzY29wZXM6IFtiMmNTY29wZV0sXHJcbiAgICAgICAgICAgIGZvcmNlUmVmcmVzaDogZmFsc2UsIC8vIFNldCB0aGlzIHRvIFwidHJ1ZVwiIHRvIHNraXAgYSBjYWNoZWQgdG9rZW4gYW5kIGdvIHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IGEgbmV3IHRva2VuXHJcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMubXlNU0FMT2JqLmdldEFjY291bnRCeUhvbWVJZCh0aGlzLmFjY291bnRJZClcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhcInRyeSB0byBzaWxlbnRseSBnZXQgdG9rZW5cIilcclxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm15TVNBTE9iai5hY3F1aXJlVG9rZW5TaWxlbnQodG9rZW5SZXF1ZXN0KVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IHRva2VuIHN1Y2Nlc3NmdWxseVwiKVxyXG4gICAgICAgIGlmICghcmVzcG9uc2UuYWNjZXNzVG9rZW4gfHwgcmVzcG9uc2UuYWNjZXNzVG9rZW4gPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IG1zYWwuSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3JlZFRva2VuW2IyY1Njb3BlXT17XCJhY2Nlc3NUb2tlblwiOnJlc3BvbnNlLmFjY2Vzc1Rva2VuLFwiZXhwaXJlXCI6cmVzcG9uc2UuaWRUb2tlbkNsYWltcy5leHB9XHJcbiAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1zYWwuSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvcikge1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbnRlcmFjdGlvbiB3aGVuIHNpbGVudCBjYWxsIGZhaWxzXHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZT1hd2FpdCB0aGlzLm15TVNBTE9iai5hY3F1aXJlVG9rZW5Qb3B1cCh0b2tlblJlcXVlc3QpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5hY2Nlc3NUb2tlbjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgbXNhbEhlbHBlcigpOyIsImNvbnN0IHNpbXBsZVNlbGVjdE1lbnU9IHJlcXVpcmUoXCIuL3NpbXBsZVNlbGVjdE1lbnVcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvZ2xvYmFsQ2FjaGVcIilcclxuY29uc3QgbW9kZWxBbmFseXplciA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9tb2RlbEFuYWx5emVyXCIpO1xyXG5jb25zdCBtc2FsSGVscGVyID0gcmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuY29uc3Qgc2ltcGxlQ2hhcnQ9cmVxdWlyZShcIi4vc2ltcGxlQ2hhcnRcIilcclxuXHJcbmNsYXNzIGJhc2VJbmZvUGFuZWwge1xyXG4gICAgZHJhd0VkaXRhYmxlKHBhcmVudCxqc29uSW5mbyxvcmlnaW5FbGVtZW50SW5mbyxwYXRoQXJyLGZ1bmNHZXRLZXlMYmxDb2xvckNsYXNzKXtcclxuICAgICAgICBpZihqc29uSW5mbz09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIGZvcih2YXIgaW5kIGluIGpzb25JbmZvKXtcclxuICAgICAgICAgICAgdmFyIGtleURpdj0gJChcIjxsYWJlbCBzdHlsZT0nZGlzcGxheTpibG9jayc+PGRpdiBzdHlsZT0nZGlzcGxheTppbmxpbmU7cGFkZGluZzouMWVtIC4zZW0gLjFlbSAuM2VtOyBtYXJnaW4tcmlnaHQ6NXB4Jz5cIitpbmQrXCI8L2Rpdj48L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kKGtleURpdilcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGtleURpdi5jc3MoXCJwYWRkaW5nLXRvcFwiLFwiLjNlbVwiKSBcclxuICAgIFxyXG4gICAgICAgICAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsIHN0eWxlPSdwYWRkaW5nLXRvcDouMmVtJz48L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICB2YXIgbmV3UGF0aD1wYXRoQXJyLmNvbmNhdChbaW5kXSlcclxuICAgICAgICAgICAgdmFyIGtleUxhYmVsQ29sb3JDbGFzcz1cInczLWRhcmstZ3JheVwiXHJcbiAgICAgICAgICAgIGlmKGZ1bmNHZXRLZXlMYmxDb2xvckNsYXNzKSBrZXlMYWJlbENvbG9yQ2xhc3M9ZnVuY0dldEtleUxibENvbG9yQ2xhc3MobmV3UGF0aClcclxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShqc29uSW5mb1tpbmRdKSl7XHJcbiAgICAgICAgICAgICAgICBrZXlEaXYuY2hpbGRyZW4oXCI6Zmlyc3RcIikuYWRkQ2xhc3Moa2V5TGFiZWxDb2xvckNsYXNzKVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZ2xvYmFsQ2FjaGUuc2VhcmNoVmFsdWUob3JpZ2luRWxlbWVudEluZm8sIG5ld1BhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHsgXCJjb2xvclwiOiBcImdyYXlcIiwgXCJmb250LXNpemVcIjogXCI5cHhcIiB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoXCJbZW1wdHldXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNvbnRlbnRET00udGV4dCh2YWwpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdEcm9wZG93bk9wdGlvbihjb250ZW50RE9NLG5ld1BhdGgsanNvbkluZm9baW5kXSxvcmlnaW5FbGVtZW50SW5mbylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2UgaWYodHlwZW9mKGpzb25JbmZvW2luZF0pPT09XCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAga2V5RGl2LmNoaWxkcmVuKFwiOmZpcnN0XCIpLmNzcyhcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcImRpc3BsYXlcIixcImJsb2NrXCIpXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcInBhZGRpbmctbGVmdFwiLFwiMWVtXCIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdFZGl0YWJsZShjb250ZW50RE9NLGpzb25JbmZvW2luZF0sb3JpZ2luRWxlbWVudEluZm8sbmV3UGF0aCxmdW5jR2V0S2V5TGJsQ29sb3JDbGFzcylcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5RGl2LmNoaWxkcmVuKFwiOmZpcnN0XCIpLmFkZENsYXNzKGtleUxhYmVsQ29sb3JDbGFzcylcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBnbG9iYWxDYWNoZS5zZWFyY2hWYWx1ZShvcmlnaW5FbGVtZW50SW5mbywgbmV3UGF0aClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHsgXCJjb2xvclwiOiBcImdyYXlcIiwgXCJmb250LXNpemVcIjogXCI5cHhcIiB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoXCJbZW1wdHldXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNvbnRlbnRET00udGV4dCh2YWwpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhSW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cInBhZGRpbmc6MnB4O3dpZHRoOjUwJTtvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmVcIiBwbGFjZWhvbGRlcj1cInR5cGU6ICcgKyBqc29uSW5mb1tpbmRdICsgJ1wiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NLmFwcGVuZChhSW5wdXQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSBhSW5wdXQudmFsKHZhbClcclxuICAgICAgICAgICAgICAgICAgICBhSW5wdXQuZGF0YShcInBhdGhcIiwgbmV3UGF0aClcclxuICAgICAgICAgICAgICAgICAgICBhSW5wdXQuZGF0YShcImRhdGFUeXBlXCIsIGpzb25JbmZvW2luZF0pXHJcbiAgICAgICAgICAgICAgICAgICAgYUlucHV0LmNoYW5nZSgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXREVFByb3BlcnR5KG9yaWdpbkVsZW1lbnRJbmZvLCAkKGUudGFyZ2V0KS5kYXRhKFwicGF0aFwiKSwgJChlLnRhcmdldCkudmFsKCksICQoZS50YXJnZXQpLmRhdGEoXCJkYXRhVHlwZVwiKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtleURpdi5hcHBlbmQoY29udGVudERPTSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0Ryb3Bkb3duT3B0aW9uKGNvbnRlbnRET00sbmV3UGF0aCx2YWx1ZUFycixvcmlnaW5FbGVtZW50SW5mbyl7XHJcbiAgICAgICAgdmFyIGFTZWxlY3RNZW51PW5ldyBzaW1wbGVTZWxlY3RNZW51KFwiXCIse2J1dHRvbkNTUzp7XCJwYWRkaW5nXCI6XCI0cHggMTZweFwifX0pXHJcbiAgICAgICAgY29udGVudERPTS5hcHBlbmQoYVNlbGVjdE1lbnUuRE9NKVxyXG4gICAgICAgIGFTZWxlY3RNZW51LkRPTS5kYXRhKFwicGF0aFwiLCBuZXdQYXRoKVxyXG4gICAgICAgIHZhbHVlQXJyLmZvckVhY2goKG9uZU9wdGlvbik9PntcclxuICAgICAgICAgICAgdmFyIHN0ciA9b25lT3B0aW9uW1wiZGlzcGxheU5hbWVcIl0gIHx8IG9uZU9wdGlvbltcImVudW1WYWx1ZVwiXSBcclxuICAgICAgICAgICAgYVNlbGVjdE1lbnUuYWRkT3B0aW9uKHN0cilcclxuICAgICAgICB9KVxyXG4gICAgICAgIGFTZWxlY3RNZW51LmNhbGxCYWNrX2NsaWNrT3B0aW9uPShvcHRpb25UZXh0LG9wdGlvblZhbHVlLHJlYWxNb3VzZUNsaWNrKT0+e1xyXG4gICAgICAgICAgICBhU2VsZWN0TWVudS5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgICAgIGlmKHJlYWxNb3VzZUNsaWNrKSB0aGlzLmVkaXREVFByb3BlcnR5KG9yaWdpbkVsZW1lbnRJbmZvLGFTZWxlY3RNZW51LkRPTS5kYXRhKFwicGF0aFwiKSxvcHRpb25WYWx1ZSxcInN0cmluZ1wiKVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsPWdsb2JhbENhY2hlLnNlYXJjaFZhbHVlKG9yaWdpbkVsZW1lbnRJbmZvLG5ld1BhdGgpXHJcbiAgICAgICAgaWYodmFsIT1udWxsKXtcclxuICAgICAgICAgICAgYVNlbGVjdE1lbnUudHJpZ2dlck9wdGlvblZhbHVlKHZhbClcclxuICAgICAgICB9ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlU21hbGxLZXlEaXYoc3RyLHBhZGRpbmdUb3Ape1xyXG4gICAgICAgIHZhciBrZXlEaXYgPSAkKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmJsb2NrJz48ZGl2IGNsYXNzPSd3My1ib3JkZXInIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiNmNmY2ZjY7ZGlzcGxheTppbmxpbmU7cGFkZGluZzouMWVtIC4zZW0gLjFlbSAuM2VtO21hcmdpbi1yaWdodDouM2VtO2ZvbnQtc2l6ZToxMHB4Jz5cIitzdHIrXCI8L2Rpdj48L2xhYmVsPlwiKVxyXG4gICAgICAgIGtleURpdi5jc3MoXCJwYWRkaW5nLXRvcFwiLHBhZGRpbmdUb3ApXHJcbiAgICAgICAgcmV0dXJuIGtleURpdlxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDb25uZWN0aW9uU3RhdHVzKHN0YXR1cyxwYXJlbnREb20pIHtcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIHZhciBrZXlEaXY9dGhpcy5nZW5lcmF0ZVNtYWxsS2V5RGl2KFwiQ29ubmVjdGlvblwiLFwiLjVlbVwiKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoa2V5RGl2KVxyXG4gICAgICAgIHZhciBjb250ZW50RE9NID0gJCgnPHNwYW4gY2xhc3M9XCJmYS1zdGFja1wiIHN0eWxlPVwiZm9udC1zaXplOi41ZW07cGFkZGluZy1sZWZ0OjVweFwiPjwvc3Bhbj4nKVxyXG4gICAgICAgIGlmKHN0YXR1cykge1xyXG4gICAgICAgICAgICBjb250ZW50RE9NLmFkZENsYXNzKFwidzMtdGV4dC1saW1lXCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uaHRtbCgnPGkgY2xhc3M9XCJmYXMgZmEtc2lnbmFsIGZhLXN0YWNrLTJ4XCI+PC9pPicpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uYWRkQ2xhc3MoXCJ3My10ZXh0LXJlZFwiKVxyXG4gICAgICAgICAgICBjb250ZW50RE9NLmh0bWwoJzxpIGNsYXNzPVwiZmFzIGZhLXNpZ25hbCBmYS1zdGFjay0yeFwiPjwvaT48aSBjbGFzcz1cImZhcyBmYS1zbGFzaCBmYS1zdGFjay0yeFwiPjwvaT4nKVxyXG4gICAgICAgIH1cclxuICAgICAgICBrZXlEaXYuYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1N0YXRpY0luZm8ocGFyZW50LGpzb25JbmZvLHBhZGRpbmdUb3AsZm9udFNpemUsZm9udENvbG9yKXtcclxuICAgICAgICBmb250Q29sb3I9Zm9udENvbG9yfHxcImJsYWNrXCJcclxuICAgICAgICBmb3IodmFyIGluZCBpbiBqc29uSW5mbyl7XHJcbiAgICAgICAgICAgIHZhciBrZXlEaXY9dGhpcy5nZW5lcmF0ZVNtYWxsS2V5RGl2KGluZCxwYWRkaW5nVG9wKVxyXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kKGtleURpdilcclxuICAgIFxyXG4gICAgICAgICAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHtcImZvbnRTaXplXCI6Zm9udFNpemUsXCJjb2xvclwiOmZvbnRDb2xvcn0pXHJcbiAgICAgICAgICAgIGlmKGpzb25JbmZvW2luZF09PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgY29udGVudERPTS5jc3MoeyBcImNvbG9yXCI6IFwiZ3JheVwiLCBcImZvbnQtc2l6ZVwiOiBcIjlweFwiIH0pXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoXCJbZW1wdHldXCIpXHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHR5cGVvZihqc29uSW5mb1tpbmRdKT09PVwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKFwiZGlzcGxheVwiLFwiYmxvY2tcIilcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKFwicGFkZGluZy1sZWZ0XCIsXCIxZW1cIilcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8oY29udGVudERPTSxqc29uSW5mb1tpbmRdLFwiLjVlbVwiLGZvbnRTaXplKVxyXG4gICAgICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcInBhZGRpbmctdG9wXCIsXCIuMmVtXCIpXHJcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NLnRleHQoanNvbkluZm9baW5kXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAga2V5RGl2LmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmZXRjaFJlYWxFbGVtZW50SW5mbyhzaW5nbGVFbGVtZW50SW5mbyl7IC8vdGhlIGlucHV0IGlzIHBvc3NpYmx5IGZyb20gdG9wb2xvZ3kgdmlldyB3aGljaCBtaWdodCBub3QgYmUgcHJlY2lzZSBhYm91dCBwcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICAgIHZhciByZXR1cm5FbGVtZW50SW5mbz17fVxyXG4gICAgICAgIGlmKHNpbmdsZUVsZW1lbnRJbmZvPT1udWxsKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHNpbmdsZUVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHtcclxuICAgICAgICAgICAgcmV0dXJuRWxlbWVudEluZm89Z2xvYmFsQ2FjaGUuc3RvcmVkVHdpbnNbc2luZ2xlRWxlbWVudEluZm9bXCIkZHRJZFwiXV0gLy9ub3RlIHRoYXQgZHluYW1pY2FsIHByb3BlcnR5IHZhbHVlIGlzIG5vdCBzdG9yZWQgaW4gdG9wb2xvZ3kgbm9kZSwgc28gYWx3YXlzIGdldCByZWZyZXNoIGRhdGEgZnJvbSBnbG9iYWxjYWNoZVxyXG4gICAgICAgIH1lbHNlIGlmIChzaW5nbGVFbGVtZW50SW5mb1tcIiRzb3VyY2VJZFwiXSkge1xyXG4gICAgICAgICAgICB2YXIgYXJyPWdsb2JhbENhY2hlLnN0b3JlZE91dGJvdW5kUmVsYXRpb25zaGlwc1tzaW5nbGVFbGVtZW50SW5mb1tcIiRzb3VyY2VJZFwiXV1cclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBpZihhcnJbaV1bJyRyZWxhdGlvbnNoaXBJZCddPT1zaW5nbGVFbGVtZW50SW5mb1tcIiRyZWxhdGlvbnNoaXBJZFwiXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRWxlbWVudEluZm89YXJyW2ldXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSBpZihzaW5nbGVFbGVtZW50SW5mb1tcInNpbU5vZGVOYW1lXCJdKXtcclxuICAgICAgICAgICAgdmFyIGF0dGFjaFR3aW5JRD1zaW5nbGVFbGVtZW50SW5mb1tcInR3aW5JRFwiXVxyXG4gICAgICAgICAgICB2YXIgZGJ0d2luPWdsb2JhbENhY2hlLkRCVHdpbnNbYXR0YWNoVHdpbklEXVxyXG4gICAgICAgICAgICB2YXIgc2ltTm9kZU5hbWU9c2luZ2xlRWxlbWVudEluZm9bXCJzaW1Ob2RlTmFtZVwiXVxyXG4gICAgICAgICAgICBzaW5nbGVFbGVtZW50SW5mby5kZXRhaWw9ZGJ0d2luLnNpbXVsYXRlW3NpbU5vZGVOYW1lXVxyXG4gICAgICAgICAgICByZXR1cm5FbGVtZW50SW5mbz1zaW5nbGVFbGVtZW50SW5mb1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dXJuRWxlbWVudEluZm9cclxuICAgIH1cclxuXHJcbiAgICBkcmF3U2luZ2xlUmVsYXRpb25Qcm9wZXJ0aWVzKHNpbmdsZVJlbGF0aW9uSW5mbyxwYXJlbnREb20pIHtcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8ocGFyZW50RG9tLCB7XHJcbiAgICAgICAgICAgIFwic291cmNlSVwiOmdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbc2luZ2xlUmVsYXRpb25JbmZvW1wiJHNvdXJjZUlkXCJdXSxcclxuICAgICAgICAgICAgXCJ0YXJnZXRcIjogZ2xvYmFsQ2FjaGUudHdpbklETWFwVG9EaXNwbGF5TmFtZVtzaW5nbGVSZWxhdGlvbkluZm9bXCIkdGFyZ2V0SWRcIl1dLFxyXG4gICAgICAgICAgICBcIiRyZWxhdGlvbnNoaXBOYW1lXCI6IHNpbmdsZVJlbGF0aW9uSW5mb1tcIiRyZWxhdGlvbnNoaXBOYW1lXCJdXHJcbiAgICAgICAgfSwgXCIxZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHtcclxuICAgICAgICAgICAgXCIkcmVsYXRpb25zaGlwSWRcIjogc2luZ2xlUmVsYXRpb25JbmZvW1wiJHJlbGF0aW9uc2hpcElkXCJdXHJcbiAgICAgICAgfSwgXCIxZW1cIiwgXCIxMHB4XCIpXHJcbiAgICAgICAgdmFyIHJlbGF0aW9uc2hpcE5hbWUgPSBzaW5nbGVSZWxhdGlvbkluZm9bXCIkcmVsYXRpb25zaGlwTmFtZVwiXVxyXG4gICAgICAgIHZhciBzb3VyY2VNb2RlbCA9IHNpbmdsZVJlbGF0aW9uSW5mb1tcInNvdXJjZU1vZGVsXCJdXHJcblxyXG4gICAgICAgIHRoaXMuZHJhd0VkaXRhYmxlKHBhcmVudERvbSwgdGhpcy5nZXRSZWxhdGlvblNoaXBFZGl0YWJsZVByb3BlcnRpZXMocmVsYXRpb25zaGlwTmFtZSwgc291cmNlTW9kZWwpLCBzaW5nbGVSZWxhdGlvbkluZm8sIFtdKVxyXG4gICAgICAgIGZvciAodmFyIGluZCBpbiBzaW5nbGVSZWxhdGlvbkluZm9bXCIkbWV0YWRhdGFcIl0pIHtcclxuICAgICAgICAgICAgdmFyIHRtcE9iaiA9IHt9XHJcbiAgICAgICAgICAgIHRtcE9ialtpbmRdID0gc2luZ2xlUmVsYXRpb25JbmZvW1wiJG1ldGFkYXRhXCJdW2luZF1cclxuICAgICAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHRtcE9iaiwgXCIxZW1cIiwgXCIxMHB4XCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20se1wiJGV0YWdcIjpzaW5nbGVSZWxhdGlvbkluZm9bXCIkZXRhZ1wiXX0sXCIxZW1cIixcIjEwcHhcIixcIkRhcmtHcmF5XCIpXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UmVsYXRpb25TaGlwRWRpdGFibGVQcm9wZXJ0aWVzKHJlbGF0aW9uc2hpcE5hbWUsIHNvdXJjZU1vZGVsKSB7XHJcbiAgICAgICAgaWYgKCFtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbc291cmNlTW9kZWxdIHx8ICFtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbc291cmNlTW9kZWxdLnZhbGlkUmVsYXRpb25zaGlwc1tyZWxhdGlvbnNoaXBOYW1lXSkgcmV0dXJuXHJcbiAgICAgICAgcmV0dXJuIG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVsc1tzb3VyY2VNb2RlbF0udmFsaWRSZWxhdGlvbnNoaXBzW3JlbGF0aW9uc2hpcE5hbWVdLmVkaXRhYmxlUmVsYXRpb25zaGlwUHJvcGVydGllc1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBkcmF3U2ltRGF0YXNvdXJjZUluZm8oc2ltTm9kZUluZm8scGFyZW50RG9tKXtcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIHZhciBkYlR3aW49Z2xvYmFsQ2FjaGUuREJUd2luc1tzaW1Ob2RlSW5mby50d2luSURdXHJcbiAgICAgICAgdmFyIHR3aW5OYW1lPWdsb2JhbENhY2hlLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbc2ltTm9kZUluZm8udHdpbklEXVxyXG4gICAgICAgIGlmKCF0aGlzLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJEaXY9JChcIjxkaXYgY2xhc3M9J3czLWNvbnRhaW5lcicvPlwiKVxyXG4gICAgICAgICAgICBwYXJlbnREb20uYXBwZW5kKGNvbnRhaW5lckRpdilcclxuICAgICAgICAgICAgcGFyZW50RG9tPWNvbnRhaW5lckRpdiBcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJuYW1lXCI6IHR3aW5OYW1lIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKHBhcmVudERvbSwgeyBcIk1vZGVsXCI6IGRiVHdpbi5tb2RlbElEIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICBpZiAodGhpcy5yZWFkT25seSkgey8vaW4gZmxvYXQgaW5mbyBwYW5lbFxyXG4gICAgICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKHBhcmVudERvbSwgeyBcIlNpbXVsYXRlIFByb3BlcnR5XCI6IHNpbU5vZGVJbmZvLnByb3BlcnR5UGF0aCB9LCBcIi41ZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8ocGFyZW50RG9tLCB7IFwiQ3ljbGUgTGVuZ3RoXCI6IHNpbU5vZGVJbmZvLmN5Y2xlTGVuZ3RoIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJTYW1wbGluZ1wiOiBzaW1Ob2RlSW5mby5zYW1wbGVJbnRlcnZhbCB9LCBcIi41ZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1N0YXRpY0luZm8ocGFyZW50RG9tLCB7IFwiRm9ybXVsYVwiOiBzaW1Ob2RlSW5mby5mb3JtdWxhIH0sIFwiLjVlbVwiLCBcIjEzcHhcIilcclxuICAgICAgICB9ZWxzZXsgLy8gaW4gcmlnaHQgc2lkZSBpbmZvIHBhbmVsXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NpbURhdGFzb3VyY2VJbmZvX3Byb3BlcnR5UGF0aChwYXJlbnREb20sc2ltTm9kZUluZm8sZGJUd2luKVxyXG4gICAgICAgICAgICAvL2RyYXcgY3ljbGVMZW5ndGgsc2FtcGxlSW50ZXJ2YWwgYW5kIGZvcm11bGFcclxuICAgICAgICAgICAgdmFyIGRlbW9DaGFydD10aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19jaGFydChzaW1Ob2RlSW5mbyxwYXJlbnREb20pXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NpbURhdGFzb3VyY2VJbmZvX2lucHV0KFwiQ3ljbGUgTGVuZ3RoKF9UKVwiLFwiY3ljbGVMZW5ndGhcIixcIkN5Y2xlIHRpbWUgbGVuZ3RoIGluIHNlY29uZHNcIixwYXJlbnREb20sc2ltTm9kZUluZm8sZGJUd2luLGRlbW9DaGFydClcclxuICAgICAgICAgICAgdGhpcy5kcmF3U2ltRGF0YXNvdXJjZUluZm9faW5wdXQoXCJTYW1wbGluZ1wiLFwic2FtcGxlSW50ZXJ2YWxcIixcIlNhbXBsaW5nIHRpbWUgaW4gc2Vjb25kc1wiLHBhcmVudERvbSxzaW1Ob2RlSW5mbyxkYlR3aW4sZGVtb0NoYXJ0KSBcclxuICAgICAgICAgICAgdGhpcy5kcmF3U2ltRGF0YXNvdXJjZUluZm9fZm9ybXVsYShwYXJlbnREb20sc2ltTm9kZUluZm8sZGJUd2luLGRlbW9DaGFydClcclxuICAgICAgICAgICAgcGFyZW50RG9tLmFwcGVuZChkZW1vQ2hhcnQuY2FudmFzKSAvL21vdmUgY2hhcnQgdG8gdGhlIGVuZFxyXG4gICAgICAgICAgICB0aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19yZWZyZXNoQ2hhcnQoc2ltTm9kZUluZm8sZGVtb0NoYXJ0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3U2ltRGF0YXNvdXJjZUluZm9fcmVmcmVzaENoYXJ0KHNpbU5vZGVJbmZvLHRoZUNoYXJ0KXtcclxuICAgICAgICB2YXIgX1Q9cGFyc2VGbG9hdChzaW1Ob2RlSW5mby5kZXRhaWxbXCJjeWNsZUxlbmd0aFwiXSlcclxuICAgICAgICB2YXIgc2FtcGxpbmc9cGFyc2VGbG9hdChzaW1Ob2RlSW5mby5kZXRhaWxbXCJzYW1wbGVJbnRlcnZhbFwiXSlcclxuICAgICAgICB2YXIgZm9ybXVsYT1zaW1Ob2RlSW5mby5kZXRhaWxbXCJmb3JtdWxhXCJdXHJcbiAgICAgICAgdmFyIG51bU9mUG9pbnRzPXBhcnNlSW50KDIqX1Qvc2FtcGxpbmcpKzFcclxuICAgICAgICB0aGVDaGFydC5zZXRYTGVuZ3RoKG51bU9mUG9pbnRzKVxyXG5cclxuICAgICAgICBpZihfVD09MCB8fCBzYW1wbGluZz09MCB8fCBmb3JtdWxhPT1cIlwiIHx8IF9UPT1udWxsIHx8IHNhbXBsaW5nPT1udWxsIHx8IGZvcm11bGE9PW51bGwgfHwgX1Q8MCB8fCBzYW1wbGluZzwwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBfdD0wO1xyXG4gICAgICAgIHZhciBkYXRhQXJyPVtdXHJcbiAgICAgICAgdmFyIF9vdXRwdXQ9bnVsbDtcclxuICAgICAgICBmb3IodmFyIGk9MDtpPG51bU9mUG9pbnRzO2krKyl7XHJcbiAgICAgICAgICAgIHZhciBldmFsU3RyPWZvcm11bGErXCJcXG5fb3V0cHV0XCJcclxuICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgX291dHB1dD1ldmFsKGV2YWxTdHIpIC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGFBcnIucHVzaChfb3V0cHV0KVxyXG4gICAgICAgICAgICBfdCs9c2FtcGxpbmdcclxuICAgICAgICAgICAgaWYoX3Q+PV9UKV90PV90LV9UXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoZUNoYXJ0LnNldERhdGFBcnIoZGF0YUFycilcclxuICAgIH1cclxuXHJcbiAgICBkcmF3U2ltRGF0YXNvdXJjZUluZm9fY2hhcnQoc2ltTm9kZUluZm8scGFyZW50RG9tKXtcclxuICAgICAgICB2YXIgY3ljbGVMPSBzaW1Ob2RlSW5mby5kZXRhaWxbXCJjeWNsZUxlbmd0aFwiXVxyXG4gICAgICAgIHZhciBzYW1wbGluZz1zaW1Ob2RlSW5mby5kZXRhaWxbXCJzYW1wbGVJbnRlcnZhbFwiXVxyXG4gICAgICAgIHZhciBudW1PZlBvaW50cz0xMDBcclxuICAgICAgICB2YXIgZGVtb0NoYXJ0PW5ldyBzaW1wbGVDaGFydChwYXJlbnREb20sbnVtT2ZQb2ludHMse3dpZHRoOlwiMTAwJVwiLFwiaGVpZ2h0XCI6XCIxMzBweFwifSkgXHJcbiAgICAgICAgcmV0dXJuIGRlbW9DaGFydFxyXG4gICAgfVxyXG4gICAgZHJhd1NpbURhdGFzb3VyY2VJbmZvX2Zvcm11bGEocGFyZW50RG9tLHNpbU5vZGVJbmZvLGRiVHdpbixkZW1vQ2hhcnQpe1xyXG4gICAgICAgIHZhciBzY3JpcHRMYmw9dGhpcy5nZW5lcmF0ZVNtYWxsS2V5RGl2KFwiQ2FsY3VsYXRpb24gU2NyaXB0XCIsXCIycHhcIilcclxuICAgICAgICBzY3JpcHRMYmwuY3NzKFwibWFyZ2luLXRvcFwiLFwiMTBweFwiKVxyXG5cclxuICAgICAgICB2YXIgbGJsMj0kKCc8bGJsIHN0eWxlPVwiZm9udC1zaXplOjEwcHg7Y29sb3I6Z3JheVwiPihCdWlsZCBpbiB2YXJpYWJsZXM6X3QgX1QgX291dHB1dCk8L2xibD4nKVxyXG4gICAgICAgIHNjcmlwdExibC5hcHBlbmQobGJsMilcclxuXHJcbiAgICAgICAgdmFyIHBsYWNlSG9sZGVyU3RyPSdTYW1wbGUmIzE2MDtTY3JpcHQmIzU4OyYjMTA7JiMxMDtTSU4mIzE2MDtXYXZlJiMxMDtfb3V0cHV0PU1hdGguc2luKF90L19UKjIqMy4xNCkmIzEwOyYjMTA7VmFsdWUmIzE2MDtMaXN0JiMxMDt2YXImIzE2MDt2YWx1ZUxpc3Q9WzIsMy41LC0xLDEwLjMsOS4xXSYjMTA7dmFyJiMxNjA7aW5kZXg9KF90L19UKnZhbHVlTGlzdC5sZW5ndGgpLnRvRml4ZWQoMCkmIzEwO19vdXRwdXQ9dmFsdWVMaXN0W2luZGV4XSYjMTA7JiMxMDtTcXVhcmUmIzE2MDtXYXZlJiMxMDtfb3V0cHV0PTEtX291dHB1dCcgXHJcbiAgICAgICAgdmFyIHNjcmlwdFRleHRBcmVhPSQoJzx0ZXh0YXJlYSBjbGFzcz1cInczLWJvcmRlclwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiIHN0eWxlPVwib3V0bGluZTpub25lO2ZvbnQtc2l6ZToxMXB4O2hlaWdodDoxNDBweDt3aWR0aDoxMDAlO2ZvbnQtZmFtaWx5OlZlcmRhbmFcIiBwbGFjZWhvbGRlcj0nK3BsYWNlSG9sZGVyU3RyKyc+PC90ZXh0YXJlYT4nKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoc2NyaXB0TGJsLHNjcmlwdFRleHRBcmVhKVxyXG4gICAgICAgIHNjcmlwdFRleHRBcmVhLm9uKFwia2V5ZG93blwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRUb1RleHRBcmVhKCdcXHQnLHNjcmlwdFRleHRBcmVhKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBzY3JpcHRUZXh0QXJlYS5oaWdobGlnaHRXaXRoaW5UZXh0YXJlYSh7aGlnaGxpZ2h0OiBbXHJcbiAgICAgICAgICAgIHsgXCJoaWdobGlnaHRcIjogXCJfdFwiLCBcImNsYXNzTmFtZVwiOiBcIlB1cnBsZVwifSxcclxuICAgICAgICAgICAgeyBcImhpZ2hsaWdodFwiOiBcIl9UXCIsIFwiY2xhc3NOYW1lXCI6IFwiQ3lhblwifSxcclxuICAgICAgICAgICAgeyBcImhpZ2hsaWdodFwiOiBcIl9vdXRwdXRcIiwgXCJjbGFzc05hbWVcIjogXCJBbWJlclwifSxcclxuICAgICAgICBdfSk7XHJcbiAgICAgICAgdmFyIGNvbmZpcm1CdG49JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1hbWJlciB3My1yaXBwbGVcIiBzdHlsZT1cInBhZGRpbmc6MnB4IDEwcHg7ZGlzcGxheTpibG9ja1wiPkNvbW1pdCBTY3JpcHQ8L2J1dHRvbj4nKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoY29uZmlybUJ0bilcclxuICAgICAgICB2YXIgb3JpZ2luYWxWPXNpbU5vZGVJbmZvLmRldGFpbFtcImZvcm11bGFcIl1cclxuICAgICAgICBpZiAob3JpZ2luYWxWICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2NyaXB0VGV4dEFyZWEudmFsKG9yaWdpbmFsVilcclxuICAgICAgICAgICAgc2NyaXB0VGV4dEFyZWEuaGlnaGxpZ2h0V2l0aGluVGV4dGFyZWEoJ3VwZGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maXJtQnRuLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgICAgICBzaW1Ob2RlSW5mby5kZXRhaWxbXCJmb3JtdWxhXCJdID0gc2NyaXB0VGV4dEFyZWEudmFsKClcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvcj10aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19yZWZyZXNoQ2hhcnQoc2ltTm9kZUluZm8sZGVtb0NoYXJ0KVxyXG4gICAgICAgICAgICAgICAgaWYoZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3VwZGF0ZVR3aW5cIiwgXCJQT1NUXCJcclxuICAgICAgICAgICAgICAgICAgICAsIHsgXCJ0d2luSURcIjogc2ltTm9kZUluZm8udHdpbklELCBcInVwZGF0ZUluZm9cIjogSlNPTi5zdHJpbmdpZnkoeyBcInNpbXVsYXRlXCI6IGRiVHdpbi5zaW11bGF0ZSB9KSB9XHJcbiAgICAgICAgICAgICAgICAgICAgLCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdTaW1EYXRhc291cmNlSW5mb19pbnB1dChsYmxUZXh0LCBrZXlTdHIscGxhY2VIb2xkZXJTdHIsIHBhcmVudERvbSwgc2ltTm9kZUluZm8sIGRiVHdpbixkZW1vQ2hhcnQpIHtcclxuICAgICAgICB2YXIga2V5RGl2ID0gJChcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDouNWVtJz48ZGl2IHN0eWxlPSdkaXNwbGF5OmlubGluZTtwYWRkaW5nOi4xZW0gLjNlbSAuMWVtIC4zZW07IG1hcmdpbi1yaWdodDo1cHgnPlwiK2xibFRleHQrXCI8L2Rpdj48L2Rpdj5cIilcclxuICAgICAgICBwYXJlbnREb20uYXBwZW5kKGtleURpdilcclxuICAgICAgICB2YXIgY29udGVudERPTSA9ICQoXCI8bGFiZWwgc3R5bGU9J3BhZGRpbmctdG9wOi4yZW0nPjwvbGFiZWw+XCIpXHJcbiAgICAgICAga2V5RGl2LmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgICAgIHZhciBhSW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cInBhZGRpbmc6MnB4O3dpZHRoOjQwJTtvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmVcIiBwbGFjZWhvbGRlcj1cIicgKyBwbGFjZUhvbGRlclN0ciArICdcIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICAgICAgY29udGVudERPTS5hcHBlbmQoYUlucHV0KVxyXG4gICAgICAgIGNvbnRlbnRET00uYXBwZW5kKCQoJzxsYWJlbD5zZWM8L2xhYmVsPicpKSBcclxuICAgICAgICB2YXIgb3JpZ2luYWxWPXNpbU5vZGVJbmZvLmRldGFpbFtrZXlTdHJdIFxyXG4gICAgICAgIGlmIChvcmlnaW5hbFYgIT0gbnVsbCkgYUlucHV0LnZhbChvcmlnaW5hbFYpXHJcbiAgICAgICAgYUlucHV0LmNoYW5nZSgoZSkgPT4ge1xyXG4gICAgICAgICAgICBzaW1Ob2RlSW5mby5kZXRhaWxba2V5U3RyXSA9ICQoZS50YXJnZXQpLnZhbCgpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaW1EYXRhc291cmNlSW5mb19yZWZyZXNoQ2hhcnQoc2ltTm9kZUluZm8sZGVtb0NoYXJ0KVxyXG4gICAgICAgICAgICAgICAgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vdXBkYXRlVHdpblwiLCBcIlBPU1RcIlxyXG4gICAgICAgICAgICAgICAgICAgICwgeyBcInR3aW5JRFwiOiBzaW1Ob2RlSW5mby50d2luSUQsIFwidXBkYXRlSW5mb1wiOiBKU09OLnN0cmluZ2lmeSh7IFwic2ltdWxhdGVcIjogZGJUd2luLnNpbXVsYXRlIH0pIH1cclxuICAgICAgICAgICAgICAgICAgICAsIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGRyYXdTaW1EYXRhc291cmNlSW5mb19wcm9wZXJ0eVBhdGgocGFyZW50RG9tLHNpbU5vZGVJbmZvLGRiVHdpbil7XHJcbiAgICAgICAgdmFyIGtleURpdj0gJChcIjxsYWJlbCBzdHlsZT0nZGlzcGxheTpibG9jaztwYWRkaW5nLXRvcDouM2VtJz48ZGl2IHN0eWxlPSdkaXNwbGF5OmlubGluZTtwYWRkaW5nOi4xZW0gLjNlbSAuMWVtIC4zZW07IG1hcmdpbi1yaWdodDo1cHgnPlNpbXVsYXRlIFByb3BlcnR5PC9kaXY+PC9sYWJlbD5cIilcclxuICAgICAgICBwYXJlbnREb20uYXBwZW5kKGtleURpdikgICAgXHJcbiAgICAgICAgdmFyIGNvbnRlbnRET009JChcIjxsYWJlbCBzdHlsZT0ncGFkZGluZy10b3A6LjJlbSc+PC9sYWJlbD5cIilcclxuICAgICAgICBrZXlEaXYuYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICAgICAgdmFyIGFTZWxlY3RNZW51ID0gbmV3IHNpbXBsZVNlbGVjdE1lbnUoXCJcIiwgeyBidXR0b25DU1M6IHsgXCJwYWRkaW5nXCI6IFwiNHB4IDE2cHhcIiB9IH0pXHJcbiAgICAgICAgY29udGVudERPTS5hcHBlbmQoYVNlbGVjdE1lbnUuRE9NKVxyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzQXJyPW1vZGVsQW5hbHl6ZXIuZmV0Y2hQcm9wZXJ0eVBhdGhzT2ZNb2RlbChkYlR3aW4ubW9kZWxJRClcclxuICAgICAgICBwcm9wZXJ0aWVzQXJyLmZvckVhY2goKG9uZVByb3BlcnR5KSA9PiB7XHJcbiAgICAgICAgICAgIGFTZWxlY3RNZW51LmFkZE9wdGlvbihvbmVQcm9wZXJ0eS5qb2luKFwiLlwiKSxvbmVQcm9wZXJ0eSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHZhciBvcmlnaW5hbFBhdGg9c2ltTm9kZUluZm8uZGV0YWlsLnByb3BlcnR5UGF0aFxyXG4gICAgICAgIGFTZWxlY3RNZW51LmNhbGxCYWNrX2NsaWNrT3B0aW9uID0gKG9wdGlvblRleHQsIG9wdGlvblZhbHVlLCByZWFsTW91c2VDbGljaykgPT4ge1xyXG4gICAgICAgICAgICBhU2VsZWN0TWVudS5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgICAgIGlmKCFyZWFsTW91c2VDbGljaykgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZihvcmlnaW5hbFBhdGg9PW51bGwgfHwgb3JpZ2luYWxQYXRoLmpvaW4oKSE9b3B0aW9uVmFsdWUuam9pbil7XHJcbiAgICAgICAgICAgICAgICBzaW1Ob2RlSW5mby5kZXRhaWwucHJvcGVydHlQYXRoPW9wdGlvblZhbHVlXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3VwZGF0ZVR3aW5cIiwgXCJQT1NUXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLCB7XCJ0d2luSURcIjpzaW1Ob2RlSW5mby50d2luSUQsXCJ1cGRhdGVJbmZvXCI6SlNPTi5zdHJpbmdpZnkoe1wic2ltdWxhdGVcIjpkYlR3aW4uc2ltdWxhdGV9KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsUGF0aCAhPSBudWxsKSBhU2VsZWN0TWVudS50cmlnZ2VyT3B0aW9uVGV4dChvcmlnaW5hbFBhdGguam9pbihcIi5cIikpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGRyYXdTaW5nbGVOb2RlUHJvcGVydGllcyhzaW5nbGVEQlR3aW5JbmZvLHNpbmdsZUFEVFR3aW5JbmZvLHBhcmVudERvbSxub3RFbWJlZE1ldGFkYXRhKSB7XHJcbiAgICAgICAgLy9pbnN0ZWFkIG9mIGRyYXcgdGhlICRkdElkLCBkcmF3IGRpc3BsYXkgbmFtZSBpbnN0ZWFkXHJcbiAgICAgICAgLy90aGlzLmRyYXdTdGF0aWNJbmZvKHRoaXMuRE9NLHtcIiRkdElkXCI6c2luZ2xlRWxlbWVudEluZm9bXCIkZHRJZFwiXX0sXCIxZW1cIixcIjEzcHhcIilcclxuICAgICAgICBwYXJlbnREb209cGFyZW50RG9tfHx0aGlzLkRPTVxyXG4gICAgICAgIGNvbnN0IGNvbnN0RGVzaXJlZENvbG9yPVwidzMtYW1iZXJcIlxyXG4gICAgICAgIGNvbnN0IGNvbnN0UmVwb3J0Q29sb3I9XCJ3My1ibHVlXCJcclxuICAgICAgICBjb25zdCBjb25zdFRlbGVtZXRyeUNvbG9yPVwidzMtbGltZVwiXHJcbiAgICAgICAgY29uc3QgY29uc3RDb21tb25Db2xvcj1cInczLWRhcmstZ3JheVwiXHJcblxyXG4gICAgICAgIHZhciBtb2RlbElEID0gc2luZ2xlREJUd2luSW5mby5tb2RlbElEXHJcbiAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJuYW1lXCI6IHNpbmdsZURCVHdpbkluZm9bXCJkaXNwbGF5TmFtZVwiXSB9LCBcIi41ZW1cIiwgXCIxM3B4XCIpXHJcbiAgICAgICAgdmFyIHRoZURCTW9kZWwgPSBnbG9iYWxDYWNoZS5nZXRTaW5nbGVEQk1vZGVsQnlJRChtb2RlbElEKVxyXG4gICAgICAgIGlmICh0aGVEQk1vZGVsLmlzSW9URGV2aWNlTW9kZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q29ubmVjdGlvblN0YXR1cyhzaW5nbGVEQlR3aW5JbmZvW1wiY29ubmVjdFN0YXRlXCJdLHBhcmVudERvbSlcclxuICAgICAgICAgICAgdGhpcy5kcmF3U3RhdGljSW5mbyhwYXJlbnREb20sIHsgXCJDb25uZWN0aW9uIFN0YXRlIFRpbWVcIjogc2luZ2xlREJUd2luSW5mb1tcImNvbm5lY3RTdGF0ZVVwZGF0ZVRpbWVcIl0gfSwgXCIuNWVtXCIsIFwiMTBweFwiKVxyXG4gICAgICAgICAgICBwYXJlbnREb20uYXBwZW5kKCQoJzx0YWJsZSBzdHlsZT1cImZvbnQtc2l6ZTpzbWFsbGVyO21hcmdpbjozcHggMHB4XCI+PHRyPjx0ZCBjbGFzcz1cIicrY29uc3RUZWxlbWV0cnlDb2xvcisnXCI+Jm5ic3A7Jm5ic3A7PC90ZD48dGQ+dGVsZW1ldHJ5PC90ZD48dGQgY2xhc3M9XCInK2NvbnN0UmVwb3J0Q29sb3IrJ1wiPiZuYnNwOyZuYnNwOzwvdGQ+PHRkPnJlcG9ydDwvdGQ+PHRkIGNsYXNzPVwiJytjb25zdERlc2lyZWRDb2xvcisnXCI+Jm5ic3A7Jm5ic3A7PC90ZD48dGQ+ZGVzaXJlZDwvdGQ+PHRkIGNsYXNzPVwiJytjb25zdENvbW1vbkNvbG9yKydcIj4mbmJzcDsmbmJzcDs8L3RkPjx0ZD5jb21tb248L3RkPjwvdHI+PC90YWJsZT4nKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF0pIHtcclxuICAgICAgICAgICAgaWYgKHRoZURCTW9kZWwuaXNJb1REZXZpY2VNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmNHZXRLZXlMYmxDb2xvckNsYXNzID0gKHByb3BlcnR5UGF0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckNvZGVNYXBwaW5nID0ge31cclxuICAgICAgICAgICAgICAgICAgICB0aGVEQk1vZGVsLmRlc2lyZWRQcm9wZXJ0aWVzLmZvckVhY2goZGVzaXJlZFAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNvZGVNYXBwaW5nW0pTT04uc3RyaW5naWZ5KGRlc2lyZWRQLnBhdGgpXSA9IGNvbnN0RGVzaXJlZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB0aGVEQk1vZGVsLnJlcG9ydFByb3BlcnRpZXMuZm9yRWFjaChyZXBvcnRQID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JDb2RlTWFwcGluZ1tKU09OLnN0cmluZ2lmeShyZXBvcnRQLnBhdGgpXSA9IGNvbnN0UmVwb3J0Q29sb3JcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoZURCTW9kZWwudGVsZW1ldHJ5UHJvcGVydGllcy5mb3JFYWNoKHRlbGVtZXRyeVAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNvZGVNYXBwaW5nW0pTT04uc3RyaW5naWZ5KHRlbGVtZXRyeVAucGF0aCldID0gY29uc3RUZWxlbWV0cnlDb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhTdHIgPSBKU09OLnN0cmluZ2lmeShwcm9wZXJ0eVBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yQ29kZU1hcHBpbmdbcGF0aFN0cl0pIHJldHVybiBjb2xvckNvZGVNYXBwaW5nW3BhdGhTdHJdXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gY29uc3RDb21tb25Db2xvclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0VkaXRhYmxlKHBhcmVudERvbSwgbW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdLmVkaXRhYmxlUHJvcGVydGllcywgc2luZ2xlQURUVHdpbkluZm8sIFtdLCBmdW5jR2V0S2V5TGJsQ29sb3JDbGFzcylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtZXRhZGF0YUNvbnRlbnQgPSAkKFwiPGxhYmVsIHN0eWxlPSdkaXNwbGF5OmJsb2NrJz48L2xhYmVsPlwiKVxyXG4gICAgICAgIHZhciBleHBhbmRNZXRhQnRuPSQoXCI8ZGl2IGNsYXNzPSd3My1ib3JkZXIgdzMtYnV0dG9uIHczLWxpZ2h0LWdyYXknIHN0eWxlPSdwYWRkaW5nOi4xZW0gLjVlbTttYXJnaW4tcmlnaHQ6MWVtO2ZvbnQtc2l6ZToxMHB4Jz4uLi48L2Rpdj5cIilcclxuICAgICAgICBwYXJlbnREb20uYXBwZW5kKG1ldGFkYXRhQ29udGVudClcclxuICAgICAgICB2YXIgbWV0YURhdGFEaXY9JCgnPGRpdi8+JylcclxuICAgICAgICBtZXRhZGF0YUNvbnRlbnQuYXBwZW5kKGV4cGFuZE1ldGFCdG4sbWV0YURhdGFEaXYpXHJcbiAgICAgICAgbWV0YURhdGFEaXYuaGlkZSgpXHJcbiAgICAgICAgZXhwYW5kTWV0YUJ0bi5vbihcImNsaWNrXCIsKCk9PntleHBhbmRNZXRhQnRuLmhpZGUoKTttZXRhRGF0YURpdi5zaG93KCl9KVxyXG4gICAgICAgIGlmKG5vdEVtYmVkTWV0YWRhdGEpIGV4cGFuZE1ldGFCdG4udHJpZ2dlcihcImNsaWNrXCIpXHJcblxyXG5cclxuICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKG1ldGFEYXRhRGl2LCB7IFwiTW9kZWxcIjogbW9kZWxJRCB9LCBcIjFlbVwiLCBcIjEwcHhcIilcclxuICAgICAgICBmb3IgKHZhciBpbmQgaW4gc2luZ2xlQURUVHdpbkluZm9bXCIkbWV0YWRhdGFcIl0pIHtcclxuICAgICAgICAgICAgaWYgKGluZCA9PSBcIiRtb2RlbFwiKSBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIHRtcE9iaiA9IHt9XHJcbiAgICAgICAgICAgIHRtcE9ialtpbmRdID0gc2luZ2xlQURUVHdpbkluZm9bXCIkbWV0YWRhdGFcIl1baW5kXVxyXG4gICAgICAgICAgICB0aGlzLmRyYXdTdGF0aWNJbmZvKG1ldGFEYXRhRGl2LCB0bXBPYmosIFwiLjVlbVwiLCBcIjEwcHhcIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZWRpdERUUHJvcGVydHkob3JpZ2luRWxlbWVudEluZm8sIHBhdGgsIG5ld1ZhbCwgZGF0YVR5cGUpIHtcclxuICAgICAgICBpZiAoW1wiZG91YmxlXCIsIFwiZmxvYXRcIiwgXCJpbnRlZ2VyXCIsIFwibG9uZ1wiXS5pbmNsdWRlcyhkYXRhVHlwZSkpIG5ld1ZhbCA9IE51bWJlcihuZXdWYWwpXHJcbiAgICAgICAgaWYoZGF0YVR5cGU9PVwiYm9vbGVhblwiKXtcclxuICAgICAgICAgICAgaWYobmV3VmFsPT1cInRydWVcIikgbmV3VmFsPXRydWVcclxuICAgICAgICAgICAgZWxzZSBuZXdWYWw9ZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8veyBcIm9wXCI6IFwiYWRkXCIsIFwicGF0aFwiOiBcIi94XCIsIFwidmFsdWVcIjogMzAgfVxyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiXHJcbiAgICAgICAgICAgIHBhdGguZm9yRWFjaChzZWdtZW50ID0+IHsgc3RyICs9IFwiL1wiICsgc2VnbWVudCB9KVxyXG4gICAgICAgICAgICB2YXIganNvblBhdGNoID0gW3sgXCJvcFwiOiBcImFkZFwiLCBcInBhdGhcIjogc3RyLCBcInZhbHVlXCI6IG5ld1ZhbCB9XVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vaXQgaXMgYSBwcm9wZXJ0eSBpbnNpZGUgYSBvYmplY3QgdHlwZSBvZiByb290IHByb3BlcnR5LHVwZGF0ZSB0aGUgd2hvbGUgcm9vdCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICB2YXIgcm9vdFByb3BlcnR5ID0gcGF0aFswXVxyXG4gICAgICAgICAgICB2YXIgcGF0Y2hWYWx1ZSA9IG9yaWdpbkVsZW1lbnRJbmZvW3Jvb3RQcm9wZXJ0eV1cclxuICAgICAgICAgICAgaWYgKHBhdGNoVmFsdWUgPT0gbnVsbCkgcGF0Y2hWYWx1ZSA9IHt9XHJcbiAgICAgICAgICAgIGVsc2UgcGF0Y2hWYWx1ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGF0Y2hWYWx1ZSkpIC8vbWFrZSBhIGNvcHlcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVPcmlnaW5PYmplY3RWYWx1ZShwYXRjaFZhbHVlLCBwYXRoLnNsaWNlKDEpLCBuZXdWYWwpXHJcblxyXG4gICAgICAgICAgICB2YXIganNvblBhdGNoID0gW3sgXCJvcFwiOiBcImFkZFwiLCBcInBhdGhcIjogXCIvXCIgKyByb290UHJvcGVydHksIFwidmFsdWVcIjogcGF0Y2hWYWx1ZSB9XVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9yaWdpbkVsZW1lbnRJbmZvW1wiJGR0SWRcIl0pIHsgLy9lZGl0IGEgbm9kZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICB2YXIgdHdpbklEID0gb3JpZ2luRWxlbWVudEluZm9bXCIkZHRJZFwiXVxyXG4gICAgICAgICAgICB2YXIgcGF5TG9hZCA9IHsgXCJqc29uUGF0Y2hcIjogSlNPTi5zdHJpbmdpZnkoanNvblBhdGNoKSwgXCJ0d2luSURcIjogdHdpbklEIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbkVsZW1lbnRJbmZvW1wiJHJlbGF0aW9uc2hpcElkXCJdKSB7IC8vZWRpdCBhIHJlbGF0aW9uc2hpcCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICB2YXIgdHdpbklEID0gb3JpZ2luRWxlbWVudEluZm9bXCIkc291cmNlSWRcIl1cclxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uc2hpcElEID0gb3JpZ2luRWxlbWVudEluZm9bXCIkcmVsYXRpb25zaGlwSWRcIl1cclxuICAgICAgICAgICAgdmFyIHBheUxvYWQgPSB7IFwianNvblBhdGNoXCI6IEpTT04uc3RyaW5naWZ5KGpzb25QYXRjaCksIFwidHdpbklEXCI6IHR3aW5JRCwgXCJyZWxhdGlvbnNoaXBJRFwiOiByZWxhdGlvbnNoaXBJRCB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vY2hhbmdlQXR0cmlidXRlXCIsIFwiUE9TVFwiLCBwYXlMb2FkKVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlKG9yaWdpbkVsZW1lbnRJbmZvLCBwYXRoLCBuZXdWYWwpXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlT3JpZ2luT2JqZWN0VmFsdWUobm9kZUluZm8sIHBhdGhBcnIsIG5ld1ZhbCkge1xyXG4gICAgICAgIGlmIChwYXRoQXJyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICAgICAgdmFyIHRoZUpzb24gPSBub2RlSW5mb1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gcGF0aEFycltpXVxyXG5cclxuICAgICAgICAgICAgaWYgKGkgPT0gcGF0aEFyci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGVKc29uW2tleV0gPSBuZXdWYWxcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoZUpzb25ba2V5XSA9PSBudWxsKSB0aGVKc29uW2tleV0gPSB7fVxyXG4gICAgICAgICAgICB0aGVKc29uID0gdGhlSnNvbltrZXldXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5mb1BhbmVsOyIsImNvbnN0IG1zYWxIZWxwZXI9cmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGU9cmVxdWlyZShcIi4vZ2xvYmFsQ2FjaGVcIilcclxuXHJcbmZ1bmN0aW9uIGVkaXRQcm9qZWN0RGlhbG9nKCkge1xyXG4gICAgaWYoIXRoaXMuRE9NKXtcclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2JhY2tncm91bmQtY29sb3I6d2hpdGU7bGVmdDo1MCU7dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDoxMDFcIiBjbGFzcz1cInczLWNhcmQtMlwiPjwvZGl2PicpXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLm1ha2VET01EcmFnZ2FibGUodGhpcy5ET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbmVkaXRQcm9qZWN0RGlhbG9nLnByb3RvdHlwZS5wb3B1cCA9IGZ1bmN0aW9uIChwcm9qZWN0SW5mbykge1xyXG4gICAgdGhpcy5ET00uc2hvdygpXHJcbiAgICB0aGlzLkRPTS5lbXB0eSgpXHJcbiAgICB0aGlzLnByb2plY3RJbmZvPXByb2plY3RJbmZvXHJcblxyXG4gICAgdGhpcy5ET00uY3NzKHtcIndpZHRoXCI6XCI0MjBweFwiLFwicGFkZGluZy1ib3R0b21cIjpcIjNweFwifSlcclxuICAgIHRoaXMuRE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHg7bWFyZ2luLWJvdHRvbToycHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjJlbVwiPlByb2plY3QgU2V0dGluZzwvZGl2PjwvZGl2PicpKVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbTtwYWRkaW5nLXRvcDo0cHhcIj7DlzwvYnV0dG9uPicpXHJcbiAgICB0aGlzLkRPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKGNsb3NlQnV0dG9uKVxyXG4gICAgY2xvc2VCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7IHRoaXMuRE9NLmhpZGUoKSB9KVxyXG5cclxuICAgIHZhciByb3cxPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZChyb3cxKVxyXG4gICAgdmFyIGxhYmxlPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj5OYW1lIDwvZGl2PicpXHJcbiAgICByb3cxLmFwcGVuZChsYWJsZSlcclxuICAgIHZhciBuYW1lSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7IHdpZHRoOjcwJTsgZGlzcGxheTppbmxpbmU7bWFyZ2luLWxlZnQ6MnB4O21hcmdpbi1yaWdodDoycHhcIiAgcGxhY2Vob2xkZXI9XCJQcm9qZWN0IE5hbWUuLi5cIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7ICAgXHJcbiAgICByb3cxLmFwcGVuZChuYW1lSW5wdXQpXHJcbiAgICBuYW1lSW5wdXQudmFsKHByb2plY3RJbmZvLm5hbWUpXHJcbiAgICBuYW1lSW5wdXQub24oXCJjaGFuZ2VcIixhc3luYyAoKT0+e1xyXG4gICAgICAgIHZhciBuYW1lU3RyPW5hbWVJbnB1dC52YWwoKVxyXG4gICAgICAgIGlmKG5hbWVTdHI9PVwiXCIpIHtcclxuICAgICAgICAgICAgYWxlcnQoXCJOYW1lIGNhbiBub3QgYmUgZW1wdHkhXCIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5PXtcInByb2plY3RJRFwiOnByb2plY3RJbmZvLmlkLFwiYWNjb3VudHNcIjpbXSxcIm5ld1Byb2plY3ROYW1lXCI6bmFtZVN0cn1cclxuICAgICAgICByZXF1ZXN0Qm9keS5hY2NvdW50cz1yZXF1ZXN0Qm9keS5hY2NvdW50cy5jb25jYXQocHJvamVjdEluZm8uc2hhcmVXaXRoKVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImFjY291bnRNYW5hZ2VtZW50L2NoYW5nZU93blByb2plY3ROYW1lXCIsIFwiUE9TVFwiLCByZXF1ZXN0Qm9keSlcclxuICAgICAgICAgICAgbmFtZUlucHV0LmJsdXIoKVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcblxyXG5cclxuICAgIHZhciByb3cyPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZChyb3cyKVxyXG4gICAgdmFyIGxhYmxlPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj5TaGFyZSBXaXRoIDwvZGl2PicpXHJcbiAgICByb3cyLmFwcGVuZChsYWJsZSlcclxuICAgIHZhciBzaGFyZUFjY291bnRJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTsgd2lkdGg6NjAlOyBkaXNwbGF5OmlubGluZTttYXJnaW4tbGVmdDoycHg7bWFyZ2luLXJpZ2h0OjJweFwiICBwbGFjZWhvbGRlcj1cIkludml0ZWUgRW1haWwuLi5cIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7ICAgXHJcbiAgICByb3cyLmFwcGVuZChzaGFyZUFjY291bnRJbnB1dClcclxuICAgIHZhciBpbnZpdGVCdG49JCgnPGEgY2xhc3M9XCJ3My1idXR0b24gdzMtYm9yZGVyIHczLXJlZCB3My1ob3Zlci1hbWJlclwiIGhyZWY9XCIjXCI+SW52aXRlPC9hPicpIFxyXG4gICAgcm93Mi5hcHBlbmQoaW52aXRlQnRuKSBcclxuXHJcbiAgICB2YXIgc2hhcmVBY2NvdW50c0xpc3Q9JChcIjxkaXYgY2xhc3M9J3czLWJvcmRlciB3My1wYWRkaW5nJyBzdHlsZT0nbWFyZ2luOjFweCAxcHg7IGhlaWdodDoyMDBweDtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG8nPjxkaXY+XCIpXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQoc2hhcmVBY2NvdW50c0xpc3QpXHJcbiAgICB0aGlzLnNoYXJlQWNjb3VudHNMaXN0PXNoYXJlQWNjb3VudHNMaXN0O1xyXG4gICAgdGhpcy5kcmF3U2hhcmVkQWNjb3VudHMoKVxyXG5cclxuICAgIHNoYXJlQWNjb3VudElucHV0Lm9uKFwia2V5ZG93blwiLChldmVudCkgPT57XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHRoaXMuc2hhcmVXaXRoQWNjb3VudChzaGFyZUFjY291bnRJbnB1dClcclxuICAgIH0pO1xyXG4gICAgaW52aXRlQnRuLm9uKFwiY2xpY2tcIiwoKT0+eyB0aGlzLnNoYXJlV2l0aEFjY291bnQoc2hhcmVBY2NvdW50SW5wdXQpfSlcclxufVxyXG5cclxuZWRpdFByb2plY3REaWFsb2cucHJvdG90eXBlLnNoYXJlV2l0aEFjY291bnQ9YXN5bmMgZnVuY3Rpb24oYWNjb3VudElucHV0KXtcclxuICAgIHZhciBzaGFyZVRvQWNjb3VudD1hY2NvdW50SW5wdXQudmFsKClcclxuICAgIGlmKHNoYXJlVG9BY2NvdW50PT1cIlwiKSByZXR1cm47XHJcbiAgICB2YXIgdGhlSW5kZXg9IHRoaXMucHJvamVjdEluZm8uc2hhcmVXaXRoLmluZGV4T2Yoc2hhcmVUb0FjY291bnQpXHJcbiAgICBpZih0aGVJbmRleCE9LTEpIHJldHVybjtcclxuICAgIHZhciByZXF1ZXN0Qm9keT17XCJwcm9qZWN0SURcIjp0aGlzLnByb2plY3RJbmZvLmlkLFwic2hhcmVUb0FjY291bnRcIjpzaGFyZVRvQWNjb3VudH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvc2hhcmVQcm9qZWN0VG9cIiwgXCJQT1NUXCIsIHJlcXVlc3RCb2R5KVxyXG4gICAgICAgIHRoaXMuYWRkQWNjb3VudFRvU2hhcmVXaXRoKHNoYXJlVG9BY2NvdW50KVxyXG4gICAgICAgIHRoaXMuZHJhd1NoYXJlZEFjY291bnRzKClcclxuICAgICAgICBhY2NvdW50SW5wdXQudmFsKFwiXCIpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG59XHJcblxyXG5lZGl0UHJvamVjdERpYWxvZy5wcm90b3R5cGUuYWRkQWNjb3VudFRvU2hhcmVXaXRoPWZ1bmN0aW9uKHNoYXJlVG9BY2NvdW50SUQpe1xyXG4gICAgdmFyIHRoZUluZGV4PSB0aGlzLnByb2plY3RJbmZvLnNoYXJlV2l0aC5pbmRleE9mKHNoYXJlVG9BY2NvdW50SUQpXHJcbiAgICBpZih0aGVJbmRleD09LTEpIHRoaXMucHJvamVjdEluZm8uc2hhcmVXaXRoLnB1c2goc2hhcmVUb0FjY291bnRJRClcclxufVxyXG5cclxuZWRpdFByb2plY3REaWFsb2cucHJvdG90eXBlLmRyYXdTaGFyZWRBY2NvdW50cz1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5zaGFyZUFjY291bnRzTGlzdC5lbXB0eSgpXHJcbiAgICB2YXIgc2hhcmVkQWNjb3VudD10aGlzLnByb2plY3RJbmZvLnNoYXJlV2l0aFxyXG4gICAgc2hhcmVkQWNjb3VudC5mb3JFYWNoKG9uZUVtYWlsID0+IHtcclxuICAgICAgICB2YXIgYXJvdyA9ICQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9kaXY+JylcclxuICAgICAgICB0aGlzLnNoYXJlQWNjb3VudHNMaXN0LmFwcGVuZChhcm93KVxyXG4gICAgICAgIHZhciBsYWJsZSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj4nK29uZUVtYWlsKycgPC9kaXY+JylcclxuICAgICAgICBhcm93LmFwcGVuZChsYWJsZSlcclxuICAgICAgICB2YXIgcmVtb3ZlQnRuPSQoJzxhIGNsYXNzPVwidzMtYnV0dG9uIHczLWJvcmRlciB3My1yZWQgdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cIm1hcmdpbi1sZWZ0OjEwcHh5eVwiIGhyZWY9XCIjXCI+UmVtb3ZlPC9hPicpXHJcbiAgICAgICAgYXJvdy5hcHBlbmQocmVtb3ZlQnRuKVxyXG4gICAgICAgIHJlbW92ZUJ0bi5vbihcImNsaWNrXCIsYXN5bmMgKCk9PntcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RCb2R5PXtcInByb2plY3RJRFwiOnRoaXMucHJvamVjdEluZm8uaWQsXCJub3RTaGFyZVRvQWNjb3VudFwiOm9uZUVtYWlsfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvbm90U2hhcmVQcm9qZWN0VG9cIiwgXCJQT1NUXCIsIHJlcXVlc3RCb2R5KVxyXG4gICAgICAgICAgICAgICAgdmFyIHRoZUluZGV4ID0gdGhpcy5wcm9qZWN0SW5mby5zaGFyZVdpdGguaW5kZXhPZihvbmVFbWFpbClcclxuICAgICAgICAgICAgICAgIGlmICh0aGVJbmRleCAhPSAtMSkgdGhpcy5wcm9qZWN0SW5mby5zaGFyZVdpdGguc3BsaWNlKHRoZUluZGV4LCAxKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2hhcmVkQWNjb3VudHMoKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IGVkaXRQcm9qZWN0RGlhbG9nKCk7IiwiZnVuY3Rpb24gZ2xvYmFsQ2FjaGUoKXtcclxuICAgIHRoaXMuYWNjb3VudEluZm89bnVsbDtcclxuICAgIHRoaXMuam9pbmVkUHJvamVjdHNUb2tlbj1udWxsO1xyXG4gICAgdGhpcy5zaG93RmxvYXRJbmZvUGFuZWw9dHJ1ZVxyXG4gICAgdGhpcy5EQk1vZGVsc0FyciA9IFtdXHJcbiAgICB0aGlzLkRCVHdpbnMgPSB7fVxyXG4gICAgdGhpcy5tb2RlbElETWFwVG9OYW1lPXt9XHJcbiAgICB0aGlzLm1vZGVsTmFtZU1hcFRvSUQ9e31cclxuICAgIHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZT17fVxyXG4gICAgdGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEPXt9XHJcbiAgICB0aGlzLnN0b3JlZFR3aW5zID0ge31cclxuICAgIHRoaXMubGF5b3V0SlNPTj17fVxyXG4gICAgdGhpcy52aXN1YWxEZWZpbml0aW9uPXtcImRlZmF1bHRcIjp7XCJkZXRhaWxcIjp7fX19XHJcbiAgICB0aGlzLnN5bWJvbExpYnM9e31cclxuXHJcbiAgICB0aGlzLmNsaXBib2FyZE5vZGVTdHlsZT1udWxsXHJcblxyXG4gICAgdGhpcy5pbml0U3RvcmVkSW5mb3JtdGlvbigpXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5jaGVja1Rvb0xvbmdJZGxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHByZXZpb3VzVGltZT1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgdmFyIG1heERpZmY9MTAqNjAqMTAwMFxyXG5cclxuICAgIHZhciBwcmV2aW91c01vdXNlRG93bj1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgJChkb2N1bWVudCkucmVhZHkoICgpPT4ge1xyXG4gICAgICAgICQoZG9jdW1lbnQpLm1vdXNlZG93biggKGUpPT4ge1xyXG4gICAgICAgICAgICBwcmV2aW91c01vdXNlRG93bj1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSlcclxuXHJcbiAgICBzZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgIHZhciBjdXJyZW50VGltZT1uZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgICAgIHZhciBkaWZmMT1jdXJyZW50VGltZS1wcmV2aW91c1RpbWVcclxuICAgICAgICB2YXIgZGlmZjI9Y3VycmVudFRpbWUtcHJldmlvdXNNb3VzZURvd25cclxuICAgICAgICBpZihkaWZmMT5tYXhEaWZmIHx8IGRpZmYyPm1heERpZmYpe1xyXG4gICAgICAgICAgICAvL2xvZyBvdXQgYXMgaXQgbWVhbnMgdGhlIHBhZ2UganVzdCByZXN1bWVkIGZyb20gbG9uZyB0aW1lIGNvbXB1dGVyIHNsZWVwXHJcbiAgICAgICAgICAgIHRoaXMuc3RhbGxQYWdlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNUaW1lPWN1cnJlbnRUaW1lXHJcbiAgICB9LDYwMDAwKVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RhbGxQYWdlPWZ1bmN0aW9uKCl7XHJcbiAgICAkKCdib2R5JykuZW1wdHkoKVxyXG4gICAgZm9yKHZhciBpbmQgaW4gZ2xvYmFsKXtcclxuICAgICAgICBpZihpbmQ9PVwibG9jYXRpb25cIikgY29udGludWVcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGdsb2JhbFtpbmRdPW51bGxcclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgfVxyXG4gICAgfSBcclxuXHJcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcclxuICAgIHZhciBkZXN0VVJMPSB1cmwub3JpZ2luK1wiL3NwYWluZGV4Lmh0bWxcIlxyXG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoZGVzdFVSTCk7XHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5pbml0U3RvcmVkSW5mb3JtdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzID0ge30gXHJcbiAgICAvL3N0b3JlZCBkYXRhLCBzZXBlcmF0ZWx5IGZyb20gQURUIHNlcnZpY2UgYW5kIGZyb20gY29zbW9zREIgc2VydmljZVxyXG4gICAgdGhpcy5jdXJyZW50TGF5b3V0TmFtZT1udWxsICAgXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5maW5kUHJvamVjdEluZm89ZnVuY3Rpb24ocHJvamVjdElEKXtcclxuICAgIHZhciBqb2luZWRQcm9qZWN0cz10aGlzLmFjY291bnRJbmZvLmpvaW5lZFByb2plY3RzXHJcbiAgICBmb3IodmFyIGk9MDtpPGpvaW5lZFByb2plY3RzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBvbmVQcm9qZWN0PWpvaW5lZFByb2plY3RzW2ldXHJcbiAgICAgICAgaWYob25lUHJvamVjdC5pZD09cHJvamVjdElEKSByZXR1cm4gb25lUHJvamVjdFxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlQURUVHdpbnM9ZnVuY3Rpb24odHdpbnNEYXRhKXtcclxuICAgIHR3aW5zRGF0YS5mb3JFYWNoKChvbmVOb2RlKT0+e3RoaXMuc3RvcmVTaW5nbGVBRFRUd2luKG9uZU5vZGUpfSk7XHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5zdG9yZVNpbmdsZUFEVFR3aW49ZnVuY3Rpb24ob25lTm9kZSl7XHJcbiAgICB0aGlzLnN0b3JlZFR3aW5zW29uZU5vZGVbXCIkZHRJZFwiXV0gPSBvbmVOb2RlXHJcbiAgICBvbmVOb2RlW1wiZGlzcGxheU5hbWVcIl09IHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZVtvbmVOb2RlW1wiJGR0SWRcIl1dXHJcbiAgICAvL3RoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcIkFEVFR3aW5JbmZvVXBkYXRlXCIsXCJ0d2luSURcIjpvbmVOb2RlW1wiJGR0SWRcIl19KVxyXG59XHJcblxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlU2luZ2xlREJUd2luPWZ1bmN0aW9uKERCVHdpbil7XHJcbiAgICB0aGlzLkRCVHdpbnNbREJUd2luW1wiaWRcIl1dPURCVHdpblxyXG4gICAgdGhpcy50d2luSURNYXBUb0Rpc3BsYXlOYW1lW0RCVHdpbltcImlkXCJdXT1EQlR3aW5bXCJkaXNwbGF5TmFtZVwiXVxyXG4gICAgdGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEW0RCVHdpbltcImRpc3BsYXlOYW1lXCJdXT1EQlR3aW5bXCJpZFwiXVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVEQlR3aW5zQXJyPWZ1bmN0aW9uKERCVHdpbnNBcnIpe1xyXG4gICAgZm9yKHZhciBpbmQgaW4gdGhpcy5EQlR3aW5zKSBkZWxldGUgdGhpcy5EQlR3aW5zW2luZF1cclxuICAgIGZvcih2YXIgaW5kIGluIHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZSkgZGVsZXRlIHRoaXMudHdpbklETWFwVG9EaXNwbGF5TmFtZVtpbmRdXHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLnR3aW5EaXNwbGF5TmFtZU1hcFRvSUQpIGRlbGV0ZSB0aGlzLnR3aW5EaXNwbGF5TmFtZU1hcFRvSURbaW5kXVxyXG5cclxuICAgIHRoaXMubWVyZ2VEQlR3aW5zQXJyKERCVHdpbnNBcnIpXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5tZXJnZURCVHdpbnNBcnI9ZnVuY3Rpb24oREJUd2luc0Fycil7XHJcbiAgICBEQlR3aW5zQXJyLmZvckVhY2gob25lREJUd2luPT57XHJcbiAgICAgICAgdGhpcy5EQlR3aW5zW29uZURCVHdpbltcImlkXCJdXT1vbmVEQlR3aW5cclxuICAgICAgICB0aGlzLnR3aW5JRE1hcFRvRGlzcGxheU5hbWVbb25lREJUd2luW1wiaWRcIl1dPW9uZURCVHdpbltcImRpc3BsYXlOYW1lXCJdXHJcbiAgICAgICAgdGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEW29uZURCVHdpbltcImRpc3BsYXlOYW1lXCJdXT1vbmVEQlR3aW5bXCJpZFwiXVxyXG4gICAgfSlcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlVXNlckRhdGE9ZnVuY3Rpb24ocmVzKXtcclxuICAgIHJlcy5mb3JFYWNoKG9uZVJlc3BvbnNlPT57XHJcbiAgICAgICAgaWYob25lUmVzcG9uc2UudHlwZT09XCJqb2luZWRQcm9qZWN0c1Rva2VuXCIpIHRoaXMuam9pbmVkUHJvamVjdHNUb2tlbj1vbmVSZXNwb25zZS5qd3Q7XHJcbiAgICAgICAgZWxzZSBpZihvbmVSZXNwb25zZS50eXBlPT1cInVzZXJcIikgdGhpcy5hY2NvdW50SW5mbz1vbmVSZXNwb25zZVxyXG4gICAgfSlcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlUHJvamVjdE1vZGVsc0RhdGE9ZnVuY3Rpb24oREJNb2RlbHMsYWR0TW9kZWxzKXtcclxuICAgIHRoaXMuc3RvcmVEQk1vZGVsc0FycihEQk1vZGVscylcclxuXHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLm1vZGVsSURNYXBUb05hbWUpIGRlbGV0ZSB0aGlzLm1vZGVsSURNYXBUb05hbWVbaW5kXVxyXG4gICAgZm9yKHZhciBpbmQgaW4gdGhpcy5tb2RlbE5hbWVNYXBUb0lEKSBkZWxldGUgdGhpcy5tb2RlbE5hbWVNYXBUb0lEW2luZF1cclxuXHJcbiAgICB2YXIgdG1wTmFtZVRvT2JqID0ge31cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWR0TW9kZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID09IG51bGwpIGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID0gYWR0TW9kZWxzW2ldW1wiQGlkXCJdXHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChhZHRNb2RlbHNbaV1bXCJkaXNwbGF5TmFtZVwiXSkpIHtcclxuICAgICAgICAgICAgaWYgKGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdW1wiZW5cIl0pIGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID0gYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl1bXCJlblwiXVxyXG4gICAgICAgICAgICBlbHNlIGFkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdID0gSlNPTi5zdHJpbmdpZnkoYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0bXBOYW1lVG9PYmpbYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl1dICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy9yZXBlYXRlZCBtb2RlbCBkaXNwbGF5IG5hbWVcclxuICAgICAgICAgICAgYWR0TW9kZWxzW2ldW1wiZGlzcGxheU5hbWVcIl0gPSBhZHRNb2RlbHNbaV1bXCJAaWRcIl1cclxuICAgICAgICB9XHJcbiAgICAgICAgdG1wTmFtZVRvT2JqW2FkdE1vZGVsc1tpXVtcImRpc3BsYXlOYW1lXCJdXSA9IDFcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbElETWFwVG9OYW1lW2FkdE1vZGVsc1tpXVtcIkBpZFwiXV0gPSBhZHRNb2RlbHNbaV1bXCJkaXNwbGF5TmFtZVwiXVxyXG4gICAgICAgIHRoaXMubW9kZWxOYW1lTWFwVG9JRFthZHRNb2RlbHNbaV1bXCJkaXNwbGF5TmFtZVwiXV0gPSBhZHRNb2RlbHNbaV1bXCJAaWRcIl1cclxuICAgIH1cclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnN0b3JlUHJvamVjdFR3aW5zQW5kVmlzdWFsRGF0YT1mdW5jdGlvbihyZXNBcnIpe1xyXG4gICAgdmFyIGRidHdpbnM9W11cclxuICAgIGZvcih2YXIgaW5kIGluIHRoaXMudmlzdWFsRGVmaW5pdGlvbikgZGVsZXRlIHRoaXMudmlzdWFsRGVmaW5pdGlvbltpbmRdXHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLmxheW91dEpTT04pIGRlbGV0ZSB0aGlzLmxheW91dEpTT05baW5kXVxyXG4gICAgdGhpcy52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXT17XCJkZXRhaWxcIjp7fX1cclxuXHJcbiAgICByZXNBcnIuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBpZihlbGVtZW50LnR5cGU9PVwidmlzdWFsU2NoZW1hXCIpIHtcclxuICAgICAgICAgICAgLy9UT0RPOiBub3cgdGhlcmUgaXMgb25seSBvbmUgXCJkZWZhdWx0XCIgc2NoZW1hIHRvIHVzZSxjb25zaWRlciBhbGxvdyBjcmVhdGluZyBtb3JlIHVzZXIgZGVmaW5lIHZpc3VhbCBzY2hlbWFcclxuICAgICAgICAgICAgLy9UT0RPOiBvbmx5IGNob29zZSB0aGUgc2NoZW1hIGJlbG9uZ3MgdG8gc2VsZlxyXG4gICAgICAgICAgICB0aGlzLnJlY29yZFNpbmdsZVZpc3VhbFNjaGVtYShlbGVtZW50LmRldGFpbCxlbGVtZW50LmFjY291bnRJRCxlbGVtZW50Lm5hbWUsZWxlbWVudC5pc1NoYXJlZClcclxuICAgICAgICB9ZWxzZSBpZihlbGVtZW50LnR5cGU9PVwiVG9wb2xvZ3lcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZFNpbmdsZUxheW91dChlbGVtZW50LmRldGFpbCxlbGVtZW50LmFjY291bnRJRCxlbGVtZW50Lm5hbWUsZWxlbWVudC5pc1NoYXJlZClcclxuICAgICAgICB9ZWxzZSBpZihlbGVtZW50LnR5cGU9PVwiRFRUd2luXCIpIGRidHdpbnMucHVzaChlbGVtZW50KVxyXG4gICAgICAgIGVsc2UgaWYoZWxlbWVudC50eXBlPT1cInN5bWJvbHNcIil7XHJcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sTGlic1tlbGVtZW50LmRpc3BsYXlOYW1lXT1lbGVtZW50LmRldGFpbFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5zdG9yZURCVHdpbnNBcnIoZGJ0d2lucylcclxuXHJcbiAgICByZXNBcnIuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBpZihlbGVtZW50Lm9yaWdpbmFsU2NyaXB0IT1udWxsKSB7IFxyXG4gICAgICAgICAgICB2YXIgdHdpbklEPWVsZW1lbnQudHdpbklEXHJcbiAgICAgICAgICAgIHZhciBvbmVEQlR3aW49dGhpcy5EQlR3aW5zW3R3aW5JRF1cclxuICAgICAgICAgICAgaWYob25lREJUd2luKXtcclxuICAgICAgICAgICAgICAgIG9uZURCVHdpbltcIm9yaWdpbmFsU2NyaXB0XCJdPWVsZW1lbnRbXCJvcmlnaW5hbFNjcmlwdFwiXVxyXG4gICAgICAgICAgICAgICAgb25lREJUd2luW1wibGFzdEV4ZWN1dGlvblRpbWVcIl09ZWxlbWVudFtcImxhc3RFeGVjdXRpb25UaW1lXCJdXHJcbiAgICAgICAgICAgICAgICBvbmVEQlR3aW5bXCJhdXRob3JcIl09ZWxlbWVudFtcImF1dGhvclwiXVxyXG4gICAgICAgICAgICAgICAgb25lREJUd2luW1wiaW52YWxpZEZsYWdcIl09ZWxlbWVudFtcImludmFsaWRGbGFnXCJdXHJcbiAgICAgICAgICAgICAgICBvbmVEQlR3aW5bXCJpbnB1dHNcIl09ZWxlbWVudFtcImlucHV0c1wiXVxyXG4gICAgICAgICAgICAgICAgb25lREJUd2luW1wib3V0cHV0c1wiXT1lbGVtZW50W1wib3V0cHV0c1wiXVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUucmVjb3JkU2luZ2xlVmlzdWFsU2NoZW1hPWZ1bmN0aW9uKGRldGFpbCxhY2NvdW50SUQsb25hbWUsaXNTaGFyZWQpe1xyXG4gICAgaWYgKGFjY291bnRJRCA9PSB0aGlzLmFjY291bnRJbmZvLmlkKSB2YXIgdnNOYW1lID0gb25hbWVcclxuICAgIGVsc2UgdnNOYW1lID0gb25hbWUgKyBgKGZyb20gJHthY2NvdW50SUR9KWBcclxuICAgIHZhciBkaWN0ID0geyBcImRldGFpbFwiOiBkZXRhaWwsIFwiaXNTaGFyZWRcIjogaXNTaGFyZWQsIFwib3duZXJcIjogYWNjb3VudElELCBcIm9uYW1lXCI6IG9uYW1lfVxyXG4gICAgdGhpcy52aXN1YWxEZWZpbml0aW9uW3ZzTmFtZV09ZGljdFxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUucmVjb3JkU2luZ2xlTGF5b3V0PWZ1bmN0aW9uKGRldGFpbCxhY2NvdW50SUQsb25hbWUsaXNTaGFyZWQpe1xyXG4gICAgaWYgKGFjY291bnRJRCA9PSB0aGlzLmFjY291bnRJbmZvLmlkKSB2YXIgbGF5b3V0TmFtZSA9IG9uYW1lXHJcbiAgICBlbHNlIGxheW91dE5hbWUgPSBvbmFtZSArIGAoZnJvbSAke2FjY291bnRJRH0pYFxyXG4gICAgdmFyIGRpY3QgPSB7IFwiZGV0YWlsXCI6IGRldGFpbCwgXCJpc1NoYXJlZFwiOiBpc1NoYXJlZCwgXCJvd25lclwiOiBhY2NvdW50SUQsIFwibmFtZVwiOiBsYXlvdXROYW1lLCBcIm9uYW1lXCI6b25hbWUgfVxyXG4gICAgdGhpcy5sYXlvdXRKU09OW2xheW91dE5hbWVdID0gZGljdFxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuZ2V0REJUd2luc0J5TW9kZWxJRD1mdW5jdGlvbihtb2RlbElEKXtcclxuICAgIHZhciByZXN1bHRBcnI9W11cclxuICAgIGZvcih2YXIgaW5kIGluIHRoaXMuREJUd2lucyl7XHJcbiAgICAgICAgdmFyIGVsZT10aGlzLkRCVHdpbnNbaW5kXVxyXG4gICAgICAgIGlmKGVsZS5tb2RlbElEPT1tb2RlbElEKXtcclxuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goZWxlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRBcnI7XHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5nZXRTaW5nbGVEQlR3aW5CeU5hbWU9ZnVuY3Rpb24odHdpbk5hbWUpe1xyXG4gICAgdmFyIHR3aW5JRD10aGlzLnR3aW5EaXNwbGF5TmFtZU1hcFRvSURbdHdpbk5hbWVdXHJcbiAgICByZXR1cm4gdGhpcy5EQlR3aW5zW3R3aW5JRF1cclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLmdldFNpbmdsZURCVHdpbkJ5SW5kb29yRmVhdHVyZUlEPWZ1bmN0aW9uKGZlYXR1cmVJRCl7XHJcbiAgICBmb3IodmFyIGluZCBpbiB0aGlzLkRCVHdpbnMpe1xyXG4gICAgICAgIHZhciBlbGU9dGhpcy5EQlR3aW5zW2luZF1cclxuICAgICAgICBpZihlbGUuR0lTICYmIGVsZS5HSVMuaW5kb29yKXtcclxuICAgICAgICAgICAgaWYoZWxlLkdJUy5pbmRvb3IuSW5kb29yRmVhdHVyZUlEPT1mZWF0dXJlSUQpIHJldHVybiBlbGVcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLmdldFNpbmdsZURCTW9kZWxCeUlEPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgZm9yKHZhciBpPTA7aTx0aGlzLkRCTW9kZWxzQXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBlbGUgPSB0aGlzLkRCTW9kZWxzQXJyW2ldXHJcbiAgICAgICAgaWYoZWxlLmlkPT1tb2RlbElEKXtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVTaW5nbGVEQk1vZGVsPWZ1bmN0aW9uKHNpbmdsZURCTW9kZWxJbmZvKXtcclxuICAgIHZhciBtb2RlbElEID0gc2luZ2xlREJNb2RlbEluZm8uaWRcclxuICAgIGZvcih2YXIgaT0wO2k8dGhpcy5EQk1vZGVsc0Fyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIgZWxlID0gdGhpcy5EQk1vZGVsc0FycltpXVxyXG4gICAgICAgIGlmKGVsZS5pZD09bW9kZWxJRCl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaW5kIGluIGVsZSkgZGVsZXRlIGVsZVtpbmRdXHJcbiAgICAgICAgICAgIGZvcih2YXIgaW5kIGluIHNpbmdsZURCTW9kZWxJbmZvKSBlbGVbaW5kXT1zaW5nbGVEQk1vZGVsSW5mb1tpbmRdXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvL2l0IGlzIGEgbmV3IHNpbmdsZSBtb2RlbCBpZiBjb2RlIHJlYWNoZXMgaGVyZVxyXG4gICAgdGhpcy5EQk1vZGVsc0Fyci5wdXNoKHNpbmdsZURCTW9kZWxJbmZvKVxyXG4gICAgdGhpcy5zb3J0REJNb2RlbHNBcnIoKVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVEQk1vZGVsc0Fycj1mdW5jdGlvbihEQk1vZGVsc0Fycil7XHJcbiAgICB0aGlzLkRCTW9kZWxzQXJyLmxlbmd0aD0wXHJcbiAgICB0aGlzLkRCTW9kZWxzQXJyPXRoaXMuREJNb2RlbHNBcnIuY29uY2F0KERCTW9kZWxzQXJyKVxyXG4gICAgdGhpcy5zb3J0REJNb2RlbHNBcnIoKVxyXG4gICAgXHJcbn1cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnNvcnREQk1vZGVsc0Fycj1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5EQk1vZGVsc0Fyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IFxyXG4gICAgICAgIHZhciBhTmFtZT1hLmRpc3BsYXlOYW1lLnRvTG93ZXJDYXNlKClcclxuICAgICAgICB2YXIgYk5hbWU9Yi5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgcmV0dXJuIGFOYW1lLmxvY2FsZUNvbXBhcmUoYk5hbWUpIFxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuZ2V0U3RvcmVkQWxsSW5ib3VuZFJlbGF0aW9uc1NvdXJjZXM9ZnVuY3Rpb24odHdpbklEKXtcclxuICAgIHZhciBzcmNUd2lucz17fVxyXG4gICAgZm9yKHZhciBzcmNUd2luIGluIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzKXtcclxuICAgICAgICB2YXIgYXJyPXRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW3NyY1R3aW5dXHJcbiAgICAgICAgYXJyLmZvckVhY2gob25lUmVsYXRpb249PntcclxuICAgICAgICAgICAgaWYob25lUmVsYXRpb25bXCIkdGFyZ2V0SWRcIl09PXR3aW5JRCkgc3JjVHdpbnNbb25lUmVsYXRpb25bXCIkc291cmNlSWRcIl1dPTFcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNyY1R3aW5zO1xyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVUd2luUmVsYXRpb25zaGlwcz1mdW5jdGlvbihyZWxhdGlvbnNEYXRhKXtcclxuICAgIHJlbGF0aW9uc0RhdGEuZm9yRWFjaCgob25lUmVsYXRpb25zaGlwKT0+e1xyXG4gICAgICAgIHZhciB0d2luSUQ9b25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXVxyXG4gICAgICAgIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW3R3aW5JRF09W11cclxuICAgIH0pXHJcblxyXG4gICAgcmVsYXRpb25zRGF0YS5mb3JFYWNoKChvbmVSZWxhdGlvbnNoaXApPT57XHJcbiAgICAgICAgdGhpcy5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHNbb25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXV0ucHVzaChvbmVSZWxhdGlvbnNoaXApXHJcbiAgICB9KVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVUd2luUmVsYXRpb25zaGlwc19hcHBlbmQ9ZnVuY3Rpb24ocmVsYXRpb25zRGF0YSl7XHJcbiAgICByZWxhdGlvbnNEYXRhLmZvckVhY2goKG9uZVJlbGF0aW9uc2hpcCk9PntcclxuICAgICAgICBpZighdGhpcy5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHNbb25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXV0pXHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW29uZVJlbGF0aW9uc2hpcFsnJHNvdXJjZUlkJ11dPVtdXHJcbiAgICAgICAgdGhpcy5zdG9yZWRPdXRib3VuZFJlbGF0aW9uc2hpcHNbb25lUmVsYXRpb25zaGlwWyckc291cmNlSWQnXV0ucHVzaChvbmVSZWxhdGlvbnNoaXApXHJcbiAgICB9KVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUuc3RvcmVUd2luUmVsYXRpb25zaGlwc19yZW1vdmU9ZnVuY3Rpb24ocmVsYXRpb25zRGF0YSl7XHJcbiAgICByZWxhdGlvbnNEYXRhLmZvckVhY2goKG9uZVJlbGF0aW9uc2hpcCk9PntcclxuICAgICAgICB2YXIgc3JjSUQ9b25lUmVsYXRpb25zaGlwW1wic3JjSURcIl1cclxuICAgICAgICBpZih0aGlzLnN0b3JlZE91dGJvdW5kUmVsYXRpb25zaGlwc1tzcmNJRF0pe1xyXG4gICAgICAgICAgICB2YXIgYXJyPXRoaXMuc3RvcmVkT3V0Ym91bmRSZWxhdGlvbnNoaXBzW3NyY0lEXVxyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKGFycltpXVsnJHJlbGF0aW9uc2hpcElkJ109PW9uZVJlbGF0aW9uc2hpcFtcInJlbElEXCJdKXtcclxuICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKGksMSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5maW5kQWxsSW5wdXRzSW5TY3JpcHQ9ZnVuY3Rpb24oY2FsY1NjcmlwdCxmb3JtdWxhVHdpbk5hbWUpe1xyXG4gICAgLy9maW5kIGFsbCBwcm9wZXJ0aWVzIGluIHRoZSBzY3JpcHRcclxuICAgIGNhbGNTY3JpcHQrPVwiXFxuXCIgLy9tYWtlIHN1cmUgdGhlIGJlbG93IHBhdHRlcm5zIHVzaW5nIFwiW14uIF0gbm90IGZhaWwgYmVjYXVzZSBvZiBpdCBpcyB0aGUgZW5kIG9mIHN0cmluZyBcIlxyXG4gICAgdmFyIHBhdHQgPSAvX3NlbGYoPzw9X3NlbGYpXFxbXFxcIi4qPyg/PVxcXCJcXF1bXlxcW10pXFxcIlxcXS9nOyBcclxuICAgIHZhciBhbGxTZWxmUHJvcGVydGllcz1jYWxjU2NyaXB0Lm1hdGNoKHBhdHQpfHxbXTtcclxuICAgIHZhciBjb3VudEFsbFNlbGZUaW1lcz17fVxyXG4gICAgYWxsU2VsZlByb3BlcnRpZXMuZm9yRWFjaChvbmVTZWxmPT57XHJcbiAgICAgICAgaWYoY291bnRBbGxTZWxmVGltZXNbb25lU2VsZl0pIGNvdW50QWxsU2VsZlRpbWVzW29uZVNlbGZdKz0xXHJcbiAgICAgICAgZWxzZSBjb3VudEFsbFNlbGZUaW1lc1tvbmVTZWxmXT0xXHJcbiAgICB9KVxyXG5cclxuICAgIHZhciBwYXR0ID0gL190d2luVmFsKD88PV90d2luVmFsKVxcW1xcXCIuKj8oPz1cXFwiXFxdW15cXFtdKVxcXCJcXF0vZzsgXHJcbiAgICB2YXIgYWxsT3RoZXJUd2luUHJvcGVydGllcz1jYWxjU2NyaXB0Lm1hdGNoKHBhdHQpfHxbXTtcclxuICAgIHZhciBsaXN0QWxsT3RoZXJzPXt9XHJcbiAgICBhbGxPdGhlclR3aW5Qcm9wZXJ0aWVzLmZvckVhY2gob25lT3RoZXI9PntsaXN0QWxsT3RoZXJzW29uZU90aGVyXT0xIH0pXHJcblxyXG4gICAgLy9hbmFseXplIGFsbCB2YXJpYWJsZXMgdGhhdCBjYW4gbm90IGJlIGFzIGlucHV0IGFzIHRoZXkgYXJlIGNoYW5nZWQgZHVyaW5nIGNhbGN1YXRpb25cclxuICAgIC8vdGhleSBkaXNxdWFsaWZ5IGFzIGlucHV0IGFzIHRoZXkgd2lsbCB0cmlnZ2VyIGluZmluaXRlIGNhbGN1bGF0aW9uLCBhbGwgdGhlc2UgYmVsb25ncyB0byBfc2VsZlxyXG4gICAgdmFyIG91dHB1dHBhdHQgPSAvX3NlbGYoPzw9X3NlbGYpXFxbXFxcIlteO3tdKj9bXlxcPV0oPz1cXD1bXlxcPV0pL2c7XHJcbiAgICB2YXIgb3V0cHV0UHJvcGVydGllcz1jYWxjU2NyaXB0Lm1hdGNoKG91dHB1dHBhdHQpfHxbXTtcclxuICAgIHZhciBjb3VudE91dHB1dFRpbWVzPXt9XHJcbiAgICBvdXRwdXRQcm9wZXJ0aWVzLmZvckVhY2gob25lT3V0cHV0PT57XHJcbiAgICAgICAgaWYoY291bnRPdXRwdXRUaW1lc1tvbmVPdXRwdXRdKSBjb3VudE91dHB1dFRpbWVzW29uZU91dHB1dF0rPTFcclxuICAgICAgICBlbHNlIGNvdW50T3V0cHV0VGltZXNbb25lT3V0cHV0XT0xXHJcbiAgICB9KVxyXG4gICAgXHJcblxyXG4gICAgdmFyIGlucHV0UHJvcGVydGllc0Fycj1bXVxyXG4gICAgZm9yKHZhciBpbmQgaW4gbGlzdEFsbE90aGVycykgaW5wdXRQcm9wZXJ0aWVzQXJyLnB1c2goaW5kKVxyXG4gICAgZm9yKHZhciBpbmQgaW4gY291bnRBbGxTZWxmVGltZXMpe1xyXG4gICAgICAgIGlmKGNvdW50QWxsU2VsZlRpbWVzW2luZF0hPWNvdW50T3V0cHV0VGltZXNbaW5kXSkgaW5wdXRQcm9wZXJ0aWVzQXJyLnB1c2goaW5kKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXR1cm5BcnI9W11cclxuICAgIGlucHV0UHJvcGVydGllc0Fyci5mb3JFYWNoKG9uZVByb3BlcnR5PT57XHJcbiAgICAgICAgdmFyIG9uZUlucHV0T2JqPXt9IC8vdHdpbklELCBwYXRoLCB2YWx1ZVxyXG4gICAgICAgIHZhciBmZXRjaHByb3BlcnR5cGF0dCA9IC8oPzw9XFxbXFxcIikuKj8oPz1cXFwiXFxdKS9nO1xyXG4gICAgICAgIGlmKG9uZVByb3BlcnR5LnN0YXJ0c1dpdGgoXCJfc2VsZlwiKSl7XHJcbiAgICAgICAgICAgIG9uZUlucHV0T2JqLnBhdGg9b25lUHJvcGVydHkubWF0Y2goZmV0Y2hwcm9wZXJ0eXBhdHQpO1xyXG4gICAgICAgICAgICBvbmVJbnB1dE9iai50d2luTmFtZT1mb3JtdWxhVHdpbk5hbWUrXCIoc2VsZilcIlxyXG4gICAgICAgICAgICBvbmVJbnB1dE9iai50d2luTmFtZV9vcmlnaW49Zm9ybXVsYVR3aW5OYW1lXHJcbiAgICAgICAgICAgIHZhciB0d2luSUQ9dGhpcy50d2luRGlzcGxheU5hbWVNYXBUb0lEW2Zvcm11bGFUd2luTmFtZV1cclxuICAgICAgICAgICAgb25lSW5wdXRPYmoudmFsdWU9dGhpcy5zZWFyY2hWYWx1ZSh0aGlzLnN0b3JlZFR3aW5zW3R3aW5JRF0sb25lSW5wdXRPYmoucGF0aClcclxuICAgICAgICB9ZWxzZSBpZihvbmVQcm9wZXJ0eS5zdGFydHNXaXRoKFwiX3R3aW5WYWxcIikpe1xyXG4gICAgICAgICAgICB2YXIgYXJyPW9uZVByb3BlcnR5Lm1hdGNoKGZldGNocHJvcGVydHlwYXR0KTtcclxuICAgICAgICAgICAgdmFyIGZpcnN0RWxlPWFyclswXVxyXG4gICAgICAgICAgICBhcnIuc2hpZnQoKVxyXG4gICAgICAgICAgICBvbmVJbnB1dE9iai5wYXRoPWFyclxyXG4gICAgICAgICAgICB2YXIgdHdpbklEPXRoaXMudHdpbkRpc3BsYXlOYW1lTWFwVG9JRFtmaXJzdEVsZV1cclxuICAgICAgICAgICAgb25lSW5wdXRPYmoudmFsdWU9dGhpcy5zZWFyY2hWYWx1ZSh0aGlzLnN0b3JlZFR3aW5zW3R3aW5JRF0sb25lSW5wdXRPYmoucGF0aClcclxuICAgICAgICAgICAgb25lSW5wdXRPYmoudHdpbk5hbWU9b25lSW5wdXRPYmoudHdpbk5hbWVfb3JpZ2luPWZpcnN0RWxlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybkFyci5wdXNoKG9uZUlucHV0T2JqKVxyXG4gICAgfSlcclxuICAgIHJldHVybiByZXR1cm5BcnJcclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnNlYXJjaFZhbHVlPWZ1bmN0aW9uKG9yaWdpbkVsZW1lbnRJbmZvLHBhdGhBcnIpe1xyXG4gICAgaWYocGF0aEFyci5sZW5ndGg9PTApIHJldHVybiBudWxsO1xyXG4gICAgdmFyIHRoZUpzb249b3JpZ2luRWxlbWVudEluZm9cclxuICAgIGZvcih2YXIgaT0wO2k8cGF0aEFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIga2V5PXBhdGhBcnJbaV1cclxuICAgICAgICB0aGVKc29uPXRoZUpzb25ba2V5XVxyXG4gICAgICAgIGlmKHRoZUpzb249PW51bGwpIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoZUpzb24gLy9pdCBzaG91bGQgYmUgdGhlIGZpbmFsIHZhbHVlXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5zaGFwZVN2Zz1mdW5jdGlvbihzaGFwZSxjb2xvcixzZWNvbmRDb2xvcil7XHJcbiAgICB2YXIgc3ZnU3RhcnQ9JzxzdmcgeG1sbnM6c3ZnPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCIgZmlsbD1cIm5vbmVcIiB2ZXJzaW9uPVwiMS4xXCIgPidcclxuICAgIGlmKHNlY29uZENvbG9yKXtcclxuICAgICAgICBpZihjb2xvcj09XCJub25lXCIpIGNvbG9yPVwiZGFya0dyYXlcIiBcclxuICAgICAgICB2YXIgZ3JhZGllbnREZWZpbml0aW9uPSc8ZGVmcz4nK1xyXG4gICAgICAgICAgICAnPGxpbmVhckdyYWRpZW50IGlkPVwiZ3JhZDFcIiB4MT1cIjAlXCIgeTE9XCIwJVwiIHgyPVwiMCVcIiB5Mj1cIjEwMCVcIj4nK1xyXG4gICAgICAgICAgICAnPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdHlsZT1cInN0b3AtY29sb3I6Jytjb2xvcisnO3N0b3Atb3BhY2l0eToxXCIgLz4nK1xyXG4gICAgICAgICAgICAnPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3R5bGU9XCJzdG9wLWNvbG9yOicrY29sb3IrJztzdG9wLW9wYWNpdHk6MVwiIC8+JytcclxuICAgICAgICAgICAgJzxzdG9wIG9mZnNldD1cIjUxJVwiIHN0eWxlPVwic3RvcC1jb2xvcjonK3NlY29uZENvbG9yKyc7c3RvcC1vcGFjaXR5OjFcIiAvPicrXHJcbiAgICAgICAgICAgICc8L2xpbmVhckdyYWRpZW50PjwvZGVmcz4nXHJcbiAgICAgICAgc3ZnU3RhcnQrPWdyYWRpZW50RGVmaW5pdGlvblxyXG4gICAgfVxyXG4gICAgdmFyIGNvbG9yU3RyPShzZWNvbmRDb2xvcik/XCJ1cmwoI2dyYWQxKVwiOmNvbG9yXHJcbiAgICBpZihzaGFwZT09XCJlbGxpcHNlXCIpe1xyXG4gICAgICAgIHJldHVybiBzdmdTdGFydCsnPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI1MFwiICBmaWxsPVwiJytjb2xvclN0cisnXCIvPjwvc3ZnPidcclxuICAgIH1lbHNlIGlmKHNoYXBlPT1cImhleGFnb25cIil7XHJcbiAgICAgICAgcmV0dXJuIHN2Z1N0YXJ0Kyc8cG9seWdvbiBwb2ludHM9XCI1MCAwLCA5My4zIDI1LCA5My4zIDc1LCA1MCAxMDAsIDYuNyA3NSwgNi43IDI1XCIgIGZpbGw9XCInK2NvbG9yU3RyKydcIiAvPjwvc3ZnPidcclxuICAgIH1lbHNlIGlmKHNoYXBlPT1cInJlY3RhbmdsZVwiKXtcclxuICAgICAgICByZXR1cm4gc3ZnU3RhcnQrJzxyZWN0IHg9XCIxMFwiIHk9XCIxMFwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgd2lkdGg9XCI4MFwiIGhlaWdodD1cIjgwXCIgZmlsbD1cIicrY29sb3JTdHIrJ1wiIC8+PC9zdmc+J1xyXG4gICAgfVxyXG59XHJcblxyXG5nbG9iYWxDYWNoZS5wcm90b3R5cGUubWFrZURPTURyYWdnYWJsZT1mdW5jdGlvbihkb20saWdub3JlQ2hpbGREb21UeXBlKXtcclxuICAgIGlnbm9yZUNoaWxkRG9tVHlwZT1pZ25vcmVDaGlsZERvbVR5cGV8fFtcIkxBQkVMXCIsXCJURFwiLFwiQlwiLFwiQVwiLFwiSU5QVVRcIixcIlBSRVwiXVxyXG4gICAgZG9tLm9uKCdtb3VzZWRvd24nLChlKT0+e1xyXG4gICAgICAgIGlmKGlnbm9yZUNoaWxkRG9tVHlwZS5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIT0tMSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBkb21PZmZzZXQ9ZG9tLm9mZnNldCgpXHJcbiAgICAgICAgZG9tLm1vdXNlU3RhcnREcmFnT2Zmc2V0PVtkb21PZmZzZXQubGVmdC1lLmNsaWVudFgsIGRvbU9mZnNldC50b3AtZS5jbGllbnRZXVxyXG4gICAgICAgICQoJ2JvZHknKS5vbignbW91c2V1cCcsKCk9PntcclxuICAgICAgICAgICAgZG9tLm1vdXNlU3RhcnREcmFnT2Zmc2V0PW51bGxcclxuICAgICAgICAgICAgJCgnYm9keScpLm9mZignbW91c2Vtb3ZlJylcclxuICAgICAgICAgICAgJCgnYm9keScpLm9mZignbW91c2V1cCcpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAkKCdib2R5Jykub24oJ21vdXNlbW92ZScsKGUpPT57XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICAgICBpZihkb20ubW91c2VTdGFydERyYWdPZmZzZXQpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0xlZnQ9IGUuY2xpZW50WCtkb20ubW91c2VTdGFydERyYWdPZmZzZXRbMF1cclxuICAgICAgICAgICAgICAgIHZhciBuZXdUb3A9ZS5jbGllbnRZK2RvbS5tb3VzZVN0YXJ0RHJhZ09mZnNldFsxXVxyXG4gICAgICAgICAgICAgICAgZG9tLmNzcyh7XCJsZWZ0XCI6bmV3TGVmdCtcInB4XCIsXCJ0b3BcIjpuZXdUb3ArXCJweFwiLFwidHJhbnNmb3JtXCI6XCJub25lXCJ9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbn1cclxuXHJcbmdsb2JhbENhY2hlLnByb3RvdHlwZS5nZW5lcmF0ZU1vZGVsSWNvbiA9IGZ1bmN0aW9uIChtb2RlbElELGRpbWVuc2lvbixpc0ZpeFNpemUpIHtcclxuICAgIHZhciBkYk1vZGVsSW5mbyA9IHRoaXMuZ2V0U2luZ2xlREJNb2RlbEJ5SUQobW9kZWxJRClcclxuICAgIHZhciBjb2xvckNvZGUgPSBcImRhcmtHcmF5XCJcclxuICAgIHZhciBzaGFwZSA9IFwiZWxsaXBzZVwiXHJcbiAgICB2YXIgYXZhcnRhID0gbnVsbFxyXG4gICAgZGltZW5zaW9uID0gZGltZW5zaW9ufHwyMDtcclxuICAgIGlmICh0aGlzLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFttb2RlbElEXSkge1xyXG4gICAgICAgIHZhciB2aXN1YWxKc29uID0gdGhpcy52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxbbW9kZWxJRF1cclxuICAgICAgICB2YXIgY29sb3JDb2RlID0gdmlzdWFsSnNvbi5jb2xvciB8fCBcImRhcmtHcmF5XCJcclxuICAgICAgICB2YXIgc2Vjb25kQ29sb3JDb2RlID0gdmlzdWFsSnNvbi5zZWNvbmRDb2xvclxyXG4gICAgICAgIHZhciBzaGFwZSA9IHZpc3VhbEpzb24uc2hhcGUgfHwgXCJlbGxpcHNlXCJcclxuICAgICAgICB2YXIgYXZhcnRhID0gdmlzdWFsSnNvbi5hdmFydGFcclxuICAgICAgICBpZighaXNGaXhTaXplKXtcclxuICAgICAgICAgICAgaWYgKHZpc3VhbEpzb24uZGltZW5zaW9uUmF0aW8pIGRpbWVuc2lvbiAqPSBwYXJzZUZsb2F0KHZpc3VhbEpzb24uZGltZW5zaW9uUmF0aW8pXHJcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPiA2MCkgZGltZW5zaW9uID0gNjAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGljb25ET01EaW1lbnNpb24gPSBNYXRoLm1heChkaW1lbnNpb24sIDIwKSAvL290aGVyIHdpc2UgaXQgaXMgdG9vIHNtYWxsIHRvIGJlIGluIHZlcnRpY2FsIG1pZGRsZSBvZiBwYXJlbnQgZGl2XHJcbiAgICB2YXIgaWNvbkRPTSA9ICQoXCI8ZGl2IHN0eWxlPSd3aWR0aDpcIiArIGljb25ET01EaW1lbnNpb24gKyBcInB4O2hlaWdodDpcIiArIGljb25ET01EaW1lbnNpb24gKyBcInB4O2Zsb2F0OmxlZnQ7cG9zaXRpb246cmVsYXRpdmUnPjwvZGl2PlwiKVxyXG4gICAgaWYgKGRiTW9kZWxJbmZvICYmIGRiTW9kZWxJbmZvLmlzSW9URGV2aWNlTW9kZWwpIHtcclxuICAgICAgICB2YXIgaW90RGl2ID0gJChcIjxkaXYgY2xhc3M9J3czLWJvcmRlcicgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi01cHg7cGFkZGluZzowcHggMnB4O3RvcDotN3B4O2JvcmRlci1yYWRpdXM6IDNweDtmb250LXNpemU6N3B4Jz5Jb1Q8L2Rpdj5cIilcclxuICAgICAgICBpY29uRE9NLmFwcGVuZChpb3REaXYpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGltZ1NyYyA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnNoYXBlU3ZnKHNoYXBlLCBjb2xvckNvZGUsIHNlY29uZENvbG9yQ29kZSkpXHJcbiAgICB2YXIgc2hhcGVJbWcgPSAkKFwiPGltZyBzcmM9J2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiICsgaW1nU3JjICsgXCInPjwvaW1nPlwiKVxyXG4gICAgc2hhcGVJbWcuY3NzKHsgXCJ3aWR0aFwiOiBkaW1lbnNpb24gKyBcInB4XCIsIFwiaGVpZ2h0XCI6IGRpbWVuc2lvbiArIFwicHhcIiB9KVxyXG4gICAgaWYgKGRpbWVuc2lvbiA8IGljb25ET01EaW1lbnNpb24pIHtcclxuICAgICAgICBzaGFwZUltZy5jc3MoeyBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIiwgXCJ0b3BcIjogKGljb25ET01EaW1lbnNpb24gLSBkaW1lbnNpb24pIC8gMiArIFwicHhcIiwgXCJsZWZ0XCI6IChpY29uRE9NRGltZW5zaW9uIC0gZGltZW5zaW9uKSAvIDIgKyBcInB4XCIgfSlcclxuICAgIH1cclxuICAgIGljb25ET00uYXBwZW5kKHNoYXBlSW1nKVxyXG4gICAgaWYgKGF2YXJ0YSkge1xyXG4gICAgICAgIHZhciBhdmFydGFpbWcgPSAkKGA8aW1nIHN0eWxlPSdtYXgtd2lkdGg6JHtkaW1lbnNpb24gKiAwLjc1fXB4O21heC1oZWlnaHQ6JHtkaW1lbnNpb24gKiAwLjc1fXB4O3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6NTAlO3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKScgc3JjPScke2F2YXJ0YX0nPjwvaW1nPmApXHJcbiAgICAgICAgaWNvbkRPTS5hcHBlbmQoYXZhcnRhaW1nKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGljb25ET01cclxufVxyXG5cclxuZ2xvYmFsQ2FjaGUucHJvdG90eXBlLnV1aWR2ND1mdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xyXG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBnbG9iYWxDYWNoZSgpOyIsImNvbnN0IG1zYWxIZWxwZXI9cmVxdWlyZShcIi4uL21zYWxIZWxwZXJcIilcclxuLy9UaGlzIGlzIGEgc2luZ2xldG9uIGNsYXNzXHJcblxyXG5mdW5jdGlvbiBtb2RlbEFuYWx5emVyKCl7XHJcbiAgICB0aGlzLkRURExNb2RlbHM9e31cclxuICAgIHRoaXMucmVsYXRpb25zaGlwVHlwZXM9e31cclxufVxyXG5cclxubW9kZWxBbmFseXplci5wcm90b3R5cGUuY2xlYXJBbGxNb2RlbHM9ZnVuY3Rpb24oKXtcclxuICAgIC8vY29uc29sZS5sb2coXCJjbGVhciBhbGwgbW9kZWwgaW5mb1wiKVxyXG4gICAgZm9yKHZhciBpZCBpbiB0aGlzLkRURExNb2RlbHMpIGRlbGV0ZSB0aGlzLkRURExNb2RlbHNbaWRdXHJcbn1cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLnJlc2V0QWxsTW9kZWxzPWZ1bmN0aW9uKCl7XHJcbiAgICBmb3IodmFyIG1vZGVsSUQgaW4gdGhpcy5EVERMTW9kZWxzKXtcclxuICAgICAgICB2YXIganNvblN0cj10aGlzLkRURExNb2RlbHNbbW9kZWxJRF1bXCJvcmlnaW5hbFwiXVxyXG4gICAgICAgIHRoaXMuRFRETE1vZGVsc1ttb2RlbElEXT1KU09OLnBhcnNlKGpzb25TdHIpXHJcbiAgICAgICAgdGhpcy5EVERMTW9kZWxzW21vZGVsSURdW1wib3JpZ2luYWxcIl09anNvblN0clxyXG4gICAgfVxyXG59XHJcblxyXG5cclxubW9kZWxBbmFseXplci5wcm90b3R5cGUuYWRkTW9kZWxzPWZ1bmN0aW9uKGFycil7XHJcbiAgICBhcnIuZm9yRWFjaCgoZWxlKT0+e1xyXG4gICAgICAgIHZhciBtb2RlbElEPSBlbGVbXCJAaWRcIl1cclxuICAgICAgICBlbGVbXCJvcmlnaW5hbFwiXT1KU09OLnN0cmluZ2lmeShlbGUpXHJcbiAgICAgICAgdGhpcy5EVERMTW9kZWxzW21vZGVsSURdPWVsZVxyXG4gICAgfSlcclxufVxyXG5cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLnJlY29yZEFsbEJhc2VDbGFzc2VzPSBmdW5jdGlvbiAocGFyZW50T2JqLCBiYXNlQ2xhc3NJRCkge1xyXG4gICAgdmFyIGJhc2VDbGFzcyA9IHRoaXMuRFRETE1vZGVsc1tiYXNlQ2xhc3NJRF1cclxuICAgIGlmIChiYXNlQ2xhc3MgPT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgIHBhcmVudE9ialtiYXNlQ2xhc3NJRF09MVxyXG5cclxuICAgIHZhciBmdXJ0aGVyQmFzZUNsYXNzSURzID0gYmFzZUNsYXNzLmV4dGVuZHM7XHJcbiAgICBpZiAoZnVydGhlckJhc2VDbGFzc0lEcyA9PSBudWxsKSByZXR1cm47XHJcbiAgICBpZihBcnJheS5pc0FycmF5KGZ1cnRoZXJCYXNlQ2xhc3NJRHMpKSB2YXIgdG1wQXJyPWZ1cnRoZXJCYXNlQ2xhc3NJRHNcclxuICAgIGVsc2UgdG1wQXJyPVtmdXJ0aGVyQmFzZUNsYXNzSURzXVxyXG4gICAgdG1wQXJyLmZvckVhY2goKGVhY2hCYXNlKSA9PiB7IHRoaXMucmVjb3JkQWxsQmFzZUNsYXNzZXMocGFyZW50T2JqLCBlYWNoQmFzZSkgfSlcclxufVxyXG5cclxubW9kZWxBbmFseXplci5wcm90b3R5cGUuZXhwYW5kRWRpdGFibGVQcm9wZXJ0aWVzRnJvbUJhc2VDbGFzcyA9IGZ1bmN0aW9uIChwYXJlbnRPYmosIGJhc2VDbGFzc0lEKSB7XHJcbiAgICB2YXIgYmFzZUNsYXNzID0gdGhpcy5EVERMTW9kZWxzW2Jhc2VDbGFzc0lEXVxyXG4gICAgaWYgKGJhc2VDbGFzcyA9PSBudWxsKSByZXR1cm47XHJcbiAgICBpZiAoYmFzZUNsYXNzLmVkaXRhYmxlUHJvcGVydGllcykge1xyXG4gICAgICAgIGZvciAodmFyIGluZCBpbiBiYXNlQ2xhc3MuZWRpdGFibGVQcm9wZXJ0aWVzKSBwYXJlbnRPYmpbaW5kXSA9IGJhc2VDbGFzcy5lZGl0YWJsZVByb3BlcnRpZXNbaW5kXVxyXG4gICAgfVxyXG4gICAgdmFyIGZ1cnRoZXJCYXNlQ2xhc3NJRHMgPSBiYXNlQ2xhc3MuZXh0ZW5kcztcclxuICAgIGlmIChmdXJ0aGVyQmFzZUNsYXNzSURzID09IG51bGwpIHJldHVybjtcclxuICAgIGlmKEFycmF5LmlzQXJyYXkoZnVydGhlckJhc2VDbGFzc0lEcykpIHZhciB0bXBBcnI9ZnVydGhlckJhc2VDbGFzc0lEc1xyXG4gICAgZWxzZSB0bXBBcnI9W2Z1cnRoZXJCYXNlQ2xhc3NJRHNdXHJcbiAgICB0bXBBcnIuZm9yRWFjaCgoZWFjaEJhc2UpID0+IHsgdGhpcy5leHBhbmRFZGl0YWJsZVByb3BlcnRpZXNGcm9tQmFzZUNsYXNzKHBhcmVudE9iaiwgZWFjaEJhc2UpIH0pXHJcbn1cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLmV4cGFuZFZhbGlkUmVsYXRpb25zaGlwVHlwZXNGcm9tQmFzZUNsYXNzID0gZnVuY3Rpb24gKHBhcmVudE9iaiwgYmFzZUNsYXNzSUQpIHtcclxuICAgIHZhciBiYXNlQ2xhc3MgPSB0aGlzLkRURExNb2RlbHNbYmFzZUNsYXNzSURdXHJcbiAgICBpZiAoYmFzZUNsYXNzID09IG51bGwpIHJldHVybjtcclxuICAgIGlmIChiYXNlQ2xhc3MudmFsaWRSZWxhdGlvbnNoaXBzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kIGluIGJhc2VDbGFzcy52YWxpZFJlbGF0aW9uc2hpcHMpIHtcclxuICAgICAgICAgICAgaWYocGFyZW50T2JqW2luZF09PW51bGwpIHBhcmVudE9ialtpbmRdID0gdGhpcy5yZWxhdGlvbnNoaXBUeXBlc1tpbmRdW2Jhc2VDbGFzc0lEXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBmdXJ0aGVyQmFzZUNsYXNzSURzID0gYmFzZUNsYXNzLmV4dGVuZHM7XHJcbiAgICBpZiAoZnVydGhlckJhc2VDbGFzc0lEcyA9PSBudWxsKSByZXR1cm47XHJcbiAgICBpZihBcnJheS5pc0FycmF5KGZ1cnRoZXJCYXNlQ2xhc3NJRHMpKSB2YXIgdG1wQXJyPWZ1cnRoZXJCYXNlQ2xhc3NJRHNcclxuICAgIGVsc2UgdG1wQXJyPVtmdXJ0aGVyQmFzZUNsYXNzSURzXVxyXG4gICAgdG1wQXJyLmZvckVhY2goKGVhY2hCYXNlKSA9PiB7IHRoaXMuZXhwYW5kVmFsaWRSZWxhdGlvbnNoaXBUeXBlc0Zyb21CYXNlQ2xhc3MocGFyZW50T2JqLCBlYWNoQmFzZSkgfSlcclxufVxyXG5cclxubW9kZWxBbmFseXplci5wcm90b3R5cGUuZXhwYW5kRWRpdGFibGVQcm9wZXJ0aWVzPWZ1bmN0aW9uKHBhcmVudE9iaixkYXRhSW5mbyxlbWJlZGRlZFNjaGVtYSl7XHJcbiAgICBkYXRhSW5mby5mb3JFYWNoKChvbmVDb250ZW50KT0+e1xyXG4gICAgICAgIGlmKG9uZUNvbnRlbnRbXCJAdHlwZVwiXT09XCJSZWxhdGlvbnNoaXBcIikgcmV0dXJuO1xyXG4gICAgICAgIGlmKG9uZUNvbnRlbnRbXCJAdHlwZVwiXT09XCJQcm9wZXJ0eVwiXHJcbiAgICAgICAgfHwoQXJyYXkuaXNBcnJheShvbmVDb250ZW50W1wiQHR5cGVcIl0pICYmIG9uZUNvbnRlbnRbXCJAdHlwZVwiXS5pbmNsdWRlcyhcIlByb3BlcnR5XCIpKVxyXG4gICAgICAgIHx8IG9uZUNvbnRlbnRbXCJAdHlwZVwiXT09bnVsbCkge1xyXG4gICAgICAgICAgICBpZih0eXBlb2Yob25lQ29udGVudFtcInNjaGVtYVwiXSkgIT0gJ29iamVjdCcgJiYgZW1iZWRkZWRTY2hlbWFbb25lQ29udGVudFtcInNjaGVtYVwiXV0hPW51bGwpIG9uZUNvbnRlbnRbXCJzY2hlbWFcIl09ZW1iZWRkZWRTY2hlbWFbb25lQ29udGVudFtcInNjaGVtYVwiXV1cclxuXHJcbiAgICAgICAgICAgIGlmKHR5cGVvZihvbmVDb250ZW50W1wic2NoZW1hXCJdKSA9PT0gJ29iamVjdCcgJiYgb25lQ29udGVudFtcInNjaGVtYVwiXVtcIkB0eXBlXCJdPT1cIk9iamVjdFwiKXtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdQYXJlbnQ9e31cclxuICAgICAgICAgICAgICAgIHBhcmVudE9ialtvbmVDb250ZW50W1wibmFtZVwiXV09bmV3UGFyZW50XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEVkaXRhYmxlUHJvcGVydGllcyhuZXdQYXJlbnQsb25lQ29udGVudFtcInNjaGVtYVwiXVtcImZpZWxkc1wiXSxlbWJlZGRlZFNjaGVtYSlcclxuICAgICAgICAgICAgfWVsc2UgaWYodHlwZW9mKG9uZUNvbnRlbnRbXCJzY2hlbWFcIl0pID09PSAnb2JqZWN0JyAmJiBvbmVDb250ZW50W1wic2NoZW1hXCJdW1wiQHR5cGVcIl09PVwiRW51bVwiKXtcclxuICAgICAgICAgICAgICAgIHBhcmVudE9ialtvbmVDb250ZW50W1wibmFtZVwiXV09b25lQ29udGVudFtcInNjaGVtYVwiXVtcImVudW1WYWx1ZXNcIl1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRPYmpbb25lQ29udGVudFtcIm5hbWVcIl1dPW9uZUNvbnRlbnRbXCJzY2hlbWFcIl1cclxuICAgICAgICAgICAgfSAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufVxyXG5cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLmFuYWx5emU9ZnVuY3Rpb24oKXtcclxuICAgIC8vY29uc29sZS5sb2coXCJhbmFseXplIG1vZGVsIGluZm9cIilcclxuICAgIC8vYW5hbHl6ZSBhbGwgcmVsYXRpb25zaGlwIHR5cGVzXHJcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnJlbGF0aW9uc2hpcFR5cGVzKSBkZWxldGUgdGhpcy5yZWxhdGlvbnNoaXBUeXBlc1tpZF1cclxuICAgIGZvciAodmFyIG1vZGVsSUQgaW4gdGhpcy5EVERMTW9kZWxzKSB7XHJcbiAgICAgICAgdmFyIGVsZSA9IHRoaXMuRFRETE1vZGVsc1ttb2RlbElEXVxyXG4gICAgICAgIHZhciBlbWJlZGRlZFNjaGVtYSA9IHt9XHJcbiAgICAgICAgaWYgKGVsZS5zY2hlbWFzKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGUuc2NoZW1hcykpIHRlbXBBcnIgPSBlbGUuc2NoZW1hc1xyXG4gICAgICAgICAgICBlbHNlIHRlbXBBcnIgPSBbZWxlLnNjaGVtYXNdXHJcbiAgICAgICAgICAgIHRlbXBBcnIuZm9yRWFjaCgoZWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbWJlZGRlZFNjaGVtYVtlbGVbXCJAaWRcIl1dID0gZWxlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29udGVudEFyciA9IGVsZS5jb250ZW50c1xyXG4gICAgICAgIGlmICghY29udGVudEFycikgY29udGludWU7XHJcbiAgICAgICAgY29udGVudEFyci5mb3JFYWNoKChvbmVDb250ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbmVDb250ZW50W1wiQHR5cGVcIl0gPT0gXCJSZWxhdGlvbnNoaXBcIikge1xyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMucmVsYXRpb25zaGlwVHlwZXNbb25lQ29udGVudFtcIm5hbWVcIl1dKSB0aGlzLnJlbGF0aW9uc2hpcFR5cGVzW29uZUNvbnRlbnRbXCJuYW1lXCJdXT0ge31cclxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpb25zaGlwVHlwZXNbb25lQ29udGVudFtcIm5hbWVcIl1dW21vZGVsSURdID0gb25lQ29udGVudFxyXG4gICAgICAgICAgICAgICAgb25lQ29udGVudC5lZGl0YWJsZVJlbGF0aW9uc2hpcFByb3BlcnRpZXMgPSB7fVxyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob25lQ29udGVudC5wcm9wZXJ0aWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kRWRpdGFibGVQcm9wZXJ0aWVzKG9uZUNvbnRlbnQuZWRpdGFibGVSZWxhdGlvbnNoaXBQcm9wZXJ0aWVzLCBvbmVDb250ZW50LnByb3BlcnRpZXMsIGVtYmVkZGVkU2NoZW1hKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvL2FuYWx5emUgZWFjaCBtb2RlbCdzIHByb3BlcnR5IHRoYXQgY2FuIGJlIGVkaXRlZFxyXG4gICAgZm9yKHZhciBtb2RlbElEIGluIHRoaXMuRFRETE1vZGVscyl7IC8vZXhwYW5kIHBvc3NpYmxlIGVtYmVkZGVkIHNjaGVtYSB0byBlZGl0YWJsZVByb3BlcnRpZXMsIGFsc28gZXh0cmFjdCBwb3NzaWJsZSByZWxhdGlvbnNoaXAgdHlwZXMgZm9yIHRoaXMgbW9kZWxcclxuICAgICAgICB2YXIgZWxlPXRoaXMuRFRETE1vZGVsc1ttb2RlbElEXVxyXG4gICAgICAgIHZhciBlbWJlZGRlZFNjaGVtYT17fVxyXG4gICAgICAgIGlmKGVsZS5zY2hlbWFzKXtcclxuICAgICAgICAgICAgdmFyIHRlbXBBcnI7XHJcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZWxlLnNjaGVtYXMpKSB0ZW1wQXJyPWVsZS5zY2hlbWFzXHJcbiAgICAgICAgICAgIGVsc2UgdGVtcEFycj1bZWxlLnNjaGVtYXNdXHJcbiAgICAgICAgICAgIHRlbXBBcnIuZm9yRWFjaCgoZWxlKT0+e1xyXG4gICAgICAgICAgICAgICAgZW1iZWRkZWRTY2hlbWFbZWxlW1wiQGlkXCJdXT1lbGVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlLmVkaXRhYmxlUHJvcGVydGllcz17fVxyXG4gICAgICAgIGVsZS52YWxpZFJlbGF0aW9uc2hpcHM9e31cclxuICAgICAgICBlbGUuaW5jbHVkZWRDb21wb25lbnRzPVtdXHJcbiAgICAgICAgZWxlLmFsbEJhc2VDbGFzc2VzPXt9XHJcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlbGUuY29udGVudHMpKXtcclxuICAgICAgICAgICAgdGhpcy5leHBhbmRFZGl0YWJsZVByb3BlcnRpZXMoZWxlLmVkaXRhYmxlUHJvcGVydGllcyxlbGUuY29udGVudHMsZW1iZWRkZWRTY2hlbWEpXHJcblxyXG4gICAgICAgICAgICBlbGUuY29udGVudHMuZm9yRWFjaCgob25lQ29udGVudCk9PntcclxuICAgICAgICAgICAgICAgIGlmKG9uZUNvbnRlbnRbXCJAdHlwZVwiXT09XCJSZWxhdGlvbnNoaXBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZS52YWxpZFJlbGF0aW9uc2hpcHNbb25lQ29udGVudFtcIm5hbWVcIl1dPXRoaXMucmVsYXRpb25zaGlwVHlwZXNbb25lQ29udGVudFtcIm5hbWVcIl1dW21vZGVsSURdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvcih2YXIgbW9kZWxJRCBpbiB0aGlzLkRURExNb2RlbHMpey8vZXhwYW5kIGNvbXBvbmVudCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdmFyIGVsZT10aGlzLkRURExNb2RlbHNbbW9kZWxJRF1cclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGVsZS5jb250ZW50cykpe1xyXG4gICAgICAgICAgICBlbGUuY29udGVudHMuZm9yRWFjaChvbmVDb250ZW50PT57XHJcbiAgICAgICAgICAgICAgICBpZihvbmVDb250ZW50W1wiQHR5cGVcIl09PVwiQ29tcG9uZW50XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lPW9uZUNvbnRlbnRbXCJuYW1lXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudENsYXNzPW9uZUNvbnRlbnRbXCJzY2hlbWFcIl1cclxuICAgICAgICAgICAgICAgICAgICBlbGUuZWRpdGFibGVQcm9wZXJ0aWVzW2NvbXBvbmVudE5hbWVdPXt9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRFZGl0YWJsZVByb3BlcnRpZXNGcm9tQmFzZUNsYXNzKGVsZS5lZGl0YWJsZVByb3BlcnRpZXNbY29tcG9uZW50TmFtZV0sY29tcG9uZW50Q2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlLmluY2x1ZGVkQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudE5hbWUpXHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IodmFyIG1vZGVsSUQgaW4gdGhpcy5EVERMTW9kZWxzKXsvL2V4cGFuZCBiYXNlIGNsYXNzIHByb3BlcnRpZXMgdG8gZWRpdGFibGVQcm9wZXJ0aWVzIGFuZCB2YWxpZCByZWxhdGlvbnNoaXAgdHlwZXMgdG8gdmFsaWRSZWxhdGlvbnNoaXBzXHJcbiAgICAgICAgdmFyIGVsZT10aGlzLkRURExNb2RlbHNbbW9kZWxJRF1cclxuICAgICAgICB2YXIgYmFzZUNsYXNzSURzPWVsZS5leHRlbmRzO1xyXG4gICAgICAgIGlmKGJhc2VDbGFzc0lEcz09bnVsbCkgY29udGludWU7XHJcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShiYXNlQ2xhc3NJRHMpKSB2YXIgdG1wQXJyPWJhc2VDbGFzc0lEc1xyXG4gICAgICAgIGVsc2UgdG1wQXJyPVtiYXNlQ2xhc3NJRHNdXHJcbiAgICAgICAgdG1wQXJyLmZvckVhY2goKGVhY2hCYXNlKT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZEFsbEJhc2VDbGFzc2VzKGVsZS5hbGxCYXNlQ2xhc3NlcyxlYWNoQmFzZSlcclxuICAgICAgICAgICAgdGhpcy5leHBhbmRFZGl0YWJsZVByb3BlcnRpZXNGcm9tQmFzZUNsYXNzKGVsZS5lZGl0YWJsZVByb3BlcnRpZXMsZWFjaEJhc2UpXHJcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kVmFsaWRSZWxhdGlvbnNoaXBUeXBlc0Zyb21CYXNlQ2xhc3MoZWxlLnZhbGlkUmVsYXRpb25zaGlwcyxlYWNoQmFzZSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vY29uc29sZS5sb2codGhpcy5EVERMTW9kZWxzKVxyXG4gICAgLy9jb25zb2xlLmxvZyh0aGlzLnJlbGF0aW9uc2hpcFR5cGVzKVxyXG59XHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5saXN0TW9kZWxzRm9yRGVsZXRlTW9kZWw9ZnVuY3Rpb24obW9kZWxJRCl7XHJcbiAgICB2YXIgY2hpbGRNb2RlbElEcz1bXVxyXG4gICAgZm9yKHZhciBhSUQgaW4gdGhpcy5EVERMTW9kZWxzKXtcclxuICAgICAgICB2YXIgYU1vZGVsPXRoaXMuRFRETE1vZGVsc1thSURdXHJcbiAgICAgICAgaWYoYU1vZGVsLmFsbEJhc2VDbGFzc2VzICYmIGFNb2RlbC5hbGxCYXNlQ2xhc3Nlc1ttb2RlbElEXSkgY2hpbGRNb2RlbElEcy5wdXNoKGFNb2RlbFtcIkBpZFwiXSlcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZE1vZGVsSURzXHJcbn1cclxuXHJcbm1vZGVsQW5hbHl6ZXIucHJvdG90eXBlLmRlbGV0ZU1vZGVsPWFzeW5jIGZ1bmN0aW9uKG1vZGVsSUQsZnVuY0FmdGVyRWFjaFN1Y2Nlc3NEZWxldGUsZnVuY0FmdGVyRmFpbCxjb21wbGV0ZUZ1bmMpe1xyXG4gICAgdmFyIHJlbGF0ZWRNb2RlbElEcz10aGlzLmxpc3RNb2RlbHNGb3JEZWxldGVNb2RlbChtb2RlbElEKVxyXG4gICAgdmFyIG1vZGVsTGV2ZWw9W11cclxuICAgIHJlbGF0ZWRNb2RlbElEcy5mb3JFYWNoKG9uZUlEPT57XHJcbiAgICAgICAgdmFyIGNoZWNrTW9kZWw9dGhpcy5EVERMTW9kZWxzW29uZUlEXVxyXG4gICAgICAgIG1vZGVsTGV2ZWwucHVzaCh7XCJtb2RlbElEXCI6b25lSUQsXCJsZXZlbFwiOk9iamVjdC5rZXlzKGNoZWNrTW9kZWwuYWxsQmFzZUNsYXNzZXMpLmxlbmd0aH0pXHJcbiAgICB9KVxyXG4gICAgbW9kZWxMZXZlbC5wdXNoKHtcIm1vZGVsSURcIjptb2RlbElELFwibGV2ZWxcIjowfSlcclxuICAgIG1vZGVsTGV2ZWwuc29ydChmdW5jdGlvbiAoYSwgYikge3JldHVybiBiW1wibGV2ZWxcIl0tYVtcImxldmVsXCJdIH0pO1xyXG4gICAgXHJcbiAgICBmb3IodmFyIGk9MDtpPG1vZGVsTGV2ZWwubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdmFyIGFNb2RlbElEPW1vZGVsTGV2ZWxbaV0ubW9kZWxJRFxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vZGVsZXRlTW9kZWxcIiwgXCJQT1NUXCIsIHsgXCJtb2RlbFwiOiBhTW9kZWxJRCB9LFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5EVERMTW9kZWxzW2FNb2RlbElEXVxyXG4gICAgICAgICAgICBpZihmdW5jQWZ0ZXJFYWNoU3VjY2Vzc0RlbGV0ZSkgZnVuY0FmdGVyRWFjaFN1Y2Nlc3NEZWxldGUoYU1vZGVsSUQpXHJcbiAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgICB2YXIgZGVsZXRlZE1vZGVscz1bXVxyXG4gICAgICAgICAgICB2YXIgYWxlcnRTdHI9XCJEZWxldGUgbW9kZWwgaXMgaW5jb21wbGV0ZS4gRGVsZXRlZCBNb2RlbDpcIlxyXG4gICAgICAgICAgICBmb3IodmFyIGo9MDtqPGk7aisrKXtcclxuICAgICAgICAgICAgICAgIGFsZXJ0U3RyKz0gbW9kZWxMZXZlbFtqXS5tb2RlbElEK1wiIFwiXHJcbiAgICAgICAgICAgICAgICBkZWxldGVkTW9kZWxzLnB1c2gobW9kZWxMZXZlbFtqXS5tb2RlbElEKVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBhbGVydFN0cis9XCIuIEZhaWwgdG8gZGVsZXRlIFwiK2FNb2RlbElEK1wiLiBFcnJvciBpcyBcIitlXHJcbiAgICAgICAgICAgIGlmKGZ1bmNBZnRlckZhaWwpIGZ1bmNBZnRlckZhaWwoZGVsZXRlZE1vZGVscylcclxuICAgICAgICAgICAgYWxlcnQoZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihjb21wbGV0ZUZ1bmMpIGNvbXBsZXRlRnVuYygpXHJcbn1cclxuXHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5mZXRjaFByb3BlcnR5UGF0aHNPZk1vZGVsPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgdmFyIHByb3BlcnRpZXM9dGhpcy5EVERMTW9kZWxzW21vZGVsSURdLmVkaXRhYmxlUHJvcGVydGllc1xyXG4gICAgdmFyIHByb3BlcnR5UGF0aHM9W11cclxuICAgIHRoaXMuYW5hbHl6ZVByb3BlcnR5UGF0aChwcm9wZXJ0aWVzLFtdLHByb3BlcnR5UGF0aHMpXHJcbiAgICByZXR1cm4gcHJvcGVydHlQYXRoc1xyXG59XHJcblxyXG5tb2RlbEFuYWx5emVyLnByb3RvdHlwZS5hbmFseXplUHJvcGVydHlQYXRoPWZ1bmN0aW9uIChqc29uSW5mbyxwYXRoQXJyLHByb3BlcnR5UGF0aHMpe1xyXG4gICAgZm9yKHZhciBpbmQgaW4ganNvbkluZm8pe1xyXG4gICAgICAgIHZhciBuZXdQYXRoPXBhdGhBcnIuY29uY2F0KFtpbmRdKVxyXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGpzb25JbmZvW2luZF0pICYmIHR5cGVvZihqc29uSW5mb1tpbmRdKT09PVwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmFseXplUHJvcGVydHlQYXRoKGpzb25JbmZvW2luZF0sbmV3UGF0aCxwcm9wZXJ0eVBhdGhzKVxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgcHJvcGVydHlQYXRocy5wdXNoKG5ld1BhdGgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBtb2RlbEFuYWx5emVyKCk7IiwiY29uc3QgbW9kZWxBbmFseXplcj1yZXF1aXJlKFwiLi9tb2RlbEFuYWx5emVyXCIpXHJcbmNvbnN0IHNpbXBsZVNlbGVjdE1lbnU9IHJlcXVpcmUoXCIuL3NpbXBsZVNlbGVjdE1lbnVcIilcclxuY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBzaW1wbGVDb25maXJtRGlhbG9nPXJlcXVpcmUoXCIuL3NpbXBsZUNvbmZpcm1EaWFsb2dcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGU9cmVxdWlyZShcIi4vZ2xvYmFsQ2FjaGVcIilcclxuXHJcbmZ1bmN0aW9uIG1vZGVsRWRpdG9yRGlhbG9nKCkge1xyXG4gICAgaWYoIXRoaXMuRE9NKXtcclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2JhY2tncm91bmQtY29sb3I6d2hpdGU7bGVmdDo1MCU7dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDoxMDBcIiBjbGFzcz1cInczLWNhcmQtMlwiPjwvZGl2PicpXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLm1ha2VET01EcmFnZ2FibGUodGhpcy5ET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZGVsRWRpdG9yRGlhbG9nLnByb3RvdHlwZS5wb3B1cCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ET00uc2hvdygpXHJcbiAgICB0aGlzLkRPTS5lbXB0eSgpXHJcbiAgICB0aGlzLmNvbnRlbnRET00gPSAkKCc8ZGl2IHN0eWxlPVwid2lkdGg6NjY1cHhcIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKHRoaXMuY29udGVudERPTSlcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQoJCgnPGRpdiBzdHlsZT1cImhlaWdodDo0MHB4XCIgY2xhc3M9XCJ3My1iYXIgdzMtcmVkXCI+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtXCIgc3R5bGU9XCJmb250LXNpemU6MS41ZW1cIj5EaWdpdGFsIFR3aW4gTW9kZWwgRWRpdG9yPC9kaXY+PC9kaXY+JykpXHJcbiAgICB2YXIgY2xvc2VCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJpZ2h0XCIgc3R5bGU9XCJmb250LXNpemU6MmVtO3BhZGRpbmctdG9wOjRweFwiPsOXPC9idXR0b24+JylcclxuICAgIHRoaXMuY29udGVudERPTS5jaGlsZHJlbignOmZpcnN0JykuYXBwZW5kKGNsb3NlQnV0dG9uKVxyXG4gICAgY2xvc2VCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7IHRoaXMuRE9NLmhpZGUoKSB9KVxyXG5cclxuICAgIHZhciBidXR0b25Sb3c9JCgnPGRpdiAgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyXCI+PC9kaXY+JylcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQoYnV0dG9uUm93KVxyXG4gICAgdmFyIGltcG9ydEJ1dHRvbiA9JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1jYXJkIHczLWRlZXAtb3JhbmdlIHczLWhvdmVyLWxpZ2h0LWdyZWVuIHczLXJpZ2h0XCIgc3R5bGU9XCJoZWlnaHQ6MTAwJVwiPkltcG9ydDwvYnV0dG9uPicpXHJcbiAgICB0aGlzLmltcG9ydEJ1dHRvbj1pbXBvcnRCdXR0b25cclxuICAgIGJ1dHRvblJvdy5hcHBlbmQoaW1wb3J0QnV0dG9uKVxyXG5cclxuICAgIGltcG9ydEJ1dHRvbi5vbihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcclxuICAgICAgICB2YXIgY3VycmVudE1vZGVsSUQ9dGhpcy5kdGRsb2JqW1wiQGlkXCJdXHJcbiAgICAgICAgaWYobW9kZWxBbmFseXplci5EVERMTW9kZWxzW2N1cnJlbnRNb2RlbElEXT09bnVsbCkgdGhpcy5pbXBvcnRNb2RlbEFycihbdGhpcy5kdGRsb2JqXSlcclxuICAgICAgICBlbHNlIHRoaXMucmVwbGFjZU1vZGVsKCkgICAgICAgXHJcbiAgICB9KVxyXG5cclxuICAgIHZhciBsYWJsZT0kKCc8ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtb3BhY2l0eVwiIHN0eWxlPVwicGFkZGluZy1yaWdodDo1cHg7Zm9udC1zaXplOjEuMmVtO1wiPk1vZGVsIFRlbXBsYXRlPC9kaXY+JylcclxuICAgIGJ1dHRvblJvdy5hcHBlbmQobGFibGUpXHJcbiAgICB2YXIgbW9kZWxUZW1wbGF0ZVNlbGVjdG9yPW5ldyBzaW1wbGVTZWxlY3RNZW51KFwiIFwiLHt3aXRoQm9yZGVyOjEsZm9udFNpemU6XCIxLjJlbVwiLGNvbG9yQ2xhc3M6XCJ3My1saWdodC1ncmF5XCIsYnV0dG9uQ1NTOntcInBhZGRpbmdcIjpcIjVweCAxMHB4XCJ9LFwib3B0aW9uTGlzdEhlaWdodFwiOjMwMH0pXHJcbiAgICBidXR0b25Sb3cuYXBwZW5kKG1vZGVsVGVtcGxhdGVTZWxlY3Rvci5ET00pXHJcbiAgICBtb2RlbFRlbXBsYXRlU2VsZWN0b3IuY2FsbEJhY2tfY2xpY2tPcHRpb249KG9wdGlvblRleHQsb3B0aW9uVmFsdWUpPT57XHJcbiAgICAgICAgbW9kZWxUZW1wbGF0ZVNlbGVjdG9yLmNoYW5nZU5hbWUob3B0aW9uVGV4dClcclxuICAgICAgICB0aGlzLmNob29zZVRlbXBsYXRlKG9wdGlvblZhbHVlKVxyXG4gICAgfVxyXG4gICAgbW9kZWxUZW1wbGF0ZVNlbGVjdG9yLmFkZE9wdGlvbihcIk5ldyBNb2RlbC4uLlwiLFwiTmV3XCIpXHJcbiAgICBmb3IodmFyIG1vZGVsTmFtZSBpbiBtb2RlbEFuYWx5emVyLkRURExNb2RlbHMpe1xyXG4gICAgICAgIG1vZGVsVGVtcGxhdGVTZWxlY3Rvci5hZGRPcHRpb24obW9kZWxOYW1lKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYW5lbEhlaWdodD1cIjQ1MHB4XCJcclxuICAgIHZhciByb3cyPSQoJzxkaXYgY2xhc3M9XCJ3My1jZWxsLXJvd1wiIHN0eWxlPVwibWFyZ2luOjJweFwiPjwvZGl2PicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKHJvdzIpXHJcbiAgICB2YXIgbGVmdFNwYW49JCgnPGRpdiBjbGFzcz1cInczLWNhcmRcIiBzdHlsZT1cInBhZGRpbmc6NXB4O3dpZHRoOjMzMHB4O3BhZGRpbmctcmlnaHQ6NXB4O2hlaWdodDonK3BhbmVsSGVpZ2h0Kyc7b3ZlcmZsb3c6YXV0b1wiPjwvZGl2PicpXHJcbiAgICByb3cyLmFwcGVuZChsZWZ0U3BhbilcclxuICAgIHRoaXMubGVmdFNwYW49bGVmdFNwYW5cclxuXHJcbiAgICB2YXIgcmlnaHRTcGFuPSQoJzxkaXYgY2xhc3M9XCJ3My1jb250YWluZXIgdzMtY2VsbFwiPjwvZGl2PicpXHJcbiAgICByb3cyLmFwcGVuZChyaWdodFNwYW4pIFxyXG4gICAgdmFyIGR0ZGxTY3JpcHRQYW5lbD0kKCc8ZGl2IGNsYXNzPVwidzMtY2FyZC0yIHczLXdoaXRlXCIgc3R5bGU9XCJvdmVyZmxvdzphdXRvO21hcmdpbi10b3A6MnB4O3dpZHRoOjMxMHB4O2hlaWdodDonK3BhbmVsSGVpZ2h0KydcIj48L2Rpdj4nKVxyXG4gICAgcmlnaHRTcGFuLmFwcGVuZChkdGRsU2NyaXB0UGFuZWwpXHJcbiAgICB0aGlzLmR0ZGxTY3JpcHRQYW5lbD1kdGRsU2NyaXB0UGFuZWxcclxuXHJcbiAgICBtb2RlbFRlbXBsYXRlU2VsZWN0b3IudHJpZ2dlck9wdGlvbkluZGV4KDApXHJcbn1cclxuXHJcbm1vZGVsRWRpdG9yRGlhbG9nLnByb3RvdHlwZS5yZXBsYWNlTW9kZWw9ZnVuY3Rpb24oKXtcclxuICAgIC8vZGVsZXRlIHRoZSBvbGQgc2FtZSBuYW1lIG1vZGVsLCB0aGVuIGNyZWF0ZSBpdCBhZ2FpblxyXG4gICAgdmFyIGN1cnJlbnRNb2RlbElEPXRoaXMuZHRkbG9ialtcIkBpZFwiXVxyXG5cclxuICAgIHZhciByZWxhdGVkTW9kZWxJRHM9bW9kZWxBbmFseXplci5saXN0TW9kZWxzRm9yRGVsZXRlTW9kZWwoY3VycmVudE1vZGVsSUQpXHJcblxyXG4gICAgdmFyIGRpYWxvZ1N0ciA9IChyZWxhdGVkTW9kZWxJRHMubGVuZ3RoID09IDApID8gKFwiVHdpbnMgd2lsbCBiZSBpbXBhY3QgdW5kZXIgbW9kZWwgXFxcIlwiICsgY3VycmVudE1vZGVsSUQgKyBcIlxcXCJcIikgOlxyXG4gICAgICAgIChjdXJyZW50TW9kZWxJRCArIFwiIGlzIGJhc2UgbW9kZWwgb2YgXCIgKyByZWxhdGVkTW9kZWxJRHMuam9pbihcIiwgXCIpICsgXCIuIFR3aW5zIHVuZGVyIHRoZXNlIG1vZGVscyB3aWxsIGJlIGltcGFjdC5cIilcclxuICAgIHZhciBjb25maXJtRGlhbG9nRGl2ID0gbmV3IHNpbXBsZUNvbmZpcm1EaWFsb2coKVxyXG4gICAgY29uZmlybURpYWxvZ0Rpdi5zaG93KFxyXG4gICAgICAgIHsgd2lkdGg6IFwiMzUwcHhcIiB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGl0bGU6IFwiV2FybmluZ1wiXHJcbiAgICAgICAgICAgICwgY29udGVudDogZGlhbG9nU3RyXHJcbiAgICAgICAgICAgICwgYnV0dG9uczogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQ2xhc3M6IFwidzMtcmVkIHczLWhvdmVyLXBpbmtcIiwgdGV4dDogXCJDb25maXJtXCIsIFwiY2xpY2tGdW5jXCI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1SZXBsYWNlTW9kZWwoY3VycmVudE1vZGVsSUQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLWdyYXlcIiwgdGV4dDogXCJDYW5jZWxcIiwgXCJjbGlja0Z1bmNcIjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcbiAgICApICAgIFxyXG59XHJcblxyXG5tb2RlbEVkaXRvckRpYWxvZy5wcm90b3R5cGUuaW1wb3J0TW9kZWxBcnI9YXN5bmMgZnVuY3Rpb24obW9kZWxUb0JlSW1wb3J0ZWQsZm9yUmVwbGFjaW5nLGFmdGVyRmFpbHVyZSl7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2ltcG9ydE1vZGVsc1wiLCBcIlBPU1RcIiwgeyBcIm1vZGVsc1wiOiBKU09OLnN0cmluZ2lmeShtb2RlbFRvQmVJbXBvcnRlZCkgfSxcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICBpZihmb3JSZXBsYWNpbmcpIGFsZXJ0KFwiTW9kZWwgXCIgKyB0aGlzLmR0ZGxvYmpbXCJkaXNwbGF5TmFtZVwiXSArIFwiIGlzIG1vZGlmaWVkIHN1Y2Nlc3NmdWxseSFcIilcclxuICAgICAgICBlbHNlIGFsZXJ0KFwiTW9kZWwgXCIgKyB0aGlzLmR0ZGxvYmpbXCJkaXNwbGF5TmFtZVwiXSArIFwiIGlzIGNyZWF0ZWQhXCIpXHJcblxyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcIkFEVE1vZGVsRWRpdGVkXCIgfSlcclxuICAgICAgICBtb2RlbEFuYWx5emVyLmFkZE1vZGVscyhtb2RlbFRvQmVJbXBvcnRlZCkgLy9hZGQgc28gaW1tZWRpYXRsZXkgdGhlIGxpc3QgY2FuIHNob3cgdGhlIG5ldyBtb2RlbHNcclxuICAgICAgICB0aGlzLnBvcHVwKCkgLy9yZWZyZXNoIGNvbnRlbnRcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICBpZihhZnRlckZhaWx1cmUpIGFmdGVyRmFpbHVyZSgpXHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICB9IFxyXG59XHJcblxyXG5tb2RlbEVkaXRvckRpYWxvZy5wcm90b3R5cGUuY29uZmlybVJlcGxhY2VNb2RlbD1mdW5jdGlvbihtb2RlbElEKXtcclxuICAgIHZhciByZWxhdGVkTW9kZWxJRHM9bW9kZWxBbmFseXplci5saXN0TW9kZWxzRm9yRGVsZXRlTW9kZWwobW9kZWxJRClcclxuICAgIHZhciBiYWNrdXBNb2RlbHM9W11cclxuICAgIHJlbGF0ZWRNb2RlbElEcy5mb3JFYWNoKG9uZUlEPT57XHJcbiAgICAgICAgYmFja3VwTW9kZWxzLnB1c2goSlNPTi5wYXJzZShtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbb25lSURdW1wib3JpZ2luYWxcIl0pKVxyXG4gICAgfSlcclxuICAgIGJhY2t1cE1vZGVscy5wdXNoKHRoaXMuZHRkbG9iailcclxuICAgIHZhciBiYWNrdXBNb2RlbHNTdHI9ZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGJhY2t1cE1vZGVscykpXHJcblxyXG4gICAgdmFyIGZ1bmNBZnRlckZhaWw9KGRlbGV0ZWRNb2RlbElEcyk9PntcclxuICAgICAgICB2YXIgcG9tID0gJChcIjxhPjwvYT5cIilcclxuICAgICAgICBwb20uYXR0cignaHJlZicsICdkYXRhOnRleHQvcGxhaW47Y2hhcnNldD11dGYtOCwnICsgYmFja3VwTW9kZWxzU3RyKTtcclxuICAgICAgICBwb20uYXR0cignZG93bmxvYWQnLCBcImV4cG9ydE1vZGVsc0FmdGVyRmFpbGVkT3BlcmF0aW9uLmpzb25cIik7XHJcbiAgICAgICAgcG9tWzBdLmNsaWNrKClcclxuICAgIH1cclxuICAgIHZhciBmdW5jQWZ0ZXJFYWNoU3VjY2Vzc0RlbGV0ZSA9IChlYWNoRGVsZXRlZE1vZGVsSUQsZWFjaE1vZGVsTmFtZSkgPT4ge31cclxuICAgIFxyXG4gICAgdmFyIGNvbXBsZXRlRnVuYz0oKT0+eyBcclxuICAgICAgICAvL2ltcG9ydCBhbGwgdGhlIG1vZGVscyBhZ2FpblxyXG4gICAgICAgIHRoaXMuaW1wb3J0TW9kZWxBcnIoYmFja3VwTW9kZWxzLFwiZm9yUmVwbGFjaW5nXCIsZnVuY0FmdGVyRmFpbClcclxuICAgIH1cclxuICAgIG1vZGVsQW5hbHl6ZXIuZGVsZXRlTW9kZWwobW9kZWxJRCxmdW5jQWZ0ZXJFYWNoU3VjY2Vzc0RlbGV0ZSxmdW5jQWZ0ZXJGYWlsLGNvbXBsZXRlRnVuYylcclxufVxyXG5cclxuXHJcblxyXG5tb2RlbEVkaXRvckRpYWxvZy5wcm90b3R5cGUuY2hvb3NlVGVtcGxhdGU9ZnVuY3Rpb24odGVtcGFsdGVOYW1lKXtcclxuICAgIGlmKHRlbXBhbHRlTmFtZSE9XCJOZXdcIil7XHJcbiAgICAgICAgdGhpcy5kdGRsb2JqPUpTT04ucGFyc2UobW9kZWxBbmFseXplci5EVERMTW9kZWxzW3RlbXBhbHRlTmFtZV1bXCJvcmlnaW5hbFwiXSlcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuZHRkbG9iaiA9IHtcclxuICAgICAgICAgICAgXCJAaWRcIjogXCJkdG1pOmFOYW1lU3BhY2U6YU1vZGVsSUQ7MVwiLFxyXG4gICAgICAgICAgICBcIkBjb250ZXh0XCI6IFtcImR0bWk6ZHRkbDpjb250ZXh0OzJcIl0sXHJcbiAgICAgICAgICAgIFwiQHR5cGVcIjogXCJJbnRlcmZhY2VcIixcclxuICAgICAgICAgICAgXCJkaXNwbGF5TmFtZVwiOiBcIk5ldyBNb2RlbFwiLFxyXG4gICAgICAgICAgICBcImNvbnRlbnRzXCI6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcIkB0eXBlXCI6IFwiUHJvcGVydHlcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhdHRyaWJ1dGUxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzY2hlbWFcIjogXCJkb3VibGVcIlxyXG4gICAgICAgICAgICAgICAgfSx7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJAdHlwZVwiOiBcIlJlbGF0aW9uc2hpcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxpbmtcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5sZWZ0U3Bhbi5lbXB0eSgpXHJcblxyXG4gICAgdGhpcy5yZWZyZXNoRFRETCgpXHJcbiAgICB0aGlzLmxlZnRTcGFuLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwidzMtYmFyXCI+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtIHczLXRvb2x0aXBcIiBzdHlsZT1cImZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nLWxlZnQ6MnB4O2ZvbnQtd2VpZ2h0OmJvbGQ7Y29sb3I6Z3JheVwiPk1vZGVsIElEICYgTmFtZTxwIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpsZWZ0O2ZvbnQtd2VpZ2h0Om5vcm1hbDt0b3A6LTEwcHg7d2lkdGg6MjAwcHhcIiBjbGFzcz1cInczLXRleHQgdzMtdGFnIHczLXRpbnlcIj5tb2RlbCBJRCBjb250YWlucyBuYW1lc3BhY2UsIGEgbW9kZWwgc3RyaW5nIGFuZCBhIHZlcnNpb24gbnVtYmVyPC9wPjwvZGl2PjwvZGl2PicpKVxyXG4gICAgbmV3IGlkUm93KHRoaXMuZHRkbG9iaix0aGlzLmxlZnRTcGFuLCgpPT57dGhpcy5yZWZyZXNoRFRETCgpfSlcclxuICAgIG5ldyBkaXNwbGF5TmFtZVJvdyh0aGlzLmR0ZGxvYmosdGhpcy5sZWZ0U3BhbiwoKT0+e3RoaXMucmVmcmVzaERUREwoKX0pXHJcblxyXG4gICAgaWYoIXRoaXMuZHRkbG9ialtcImNvbnRlbnRzXCJdKXRoaXMuZHRkbG9ialtcImNvbnRlbnRzXCJdPVtdXHJcbiAgICBuZXcgcGFyYW1ldGVyc1Jvdyh0aGlzLmR0ZGxvYmpbXCJjb250ZW50c1wiXSx0aGlzLmxlZnRTcGFuLCgpPT57dGhpcy5yZWZyZXNoRFRETCgpfSx0aGlzLkRPTS5vZmZzZXQoKSlcclxuICAgIG5ldyByZWxhdGlvbnNSb3codGhpcy5kdGRsb2JqW1wiY29udGVudHNcIl0sdGhpcy5sZWZ0U3BhbiwoKT0+e3RoaXMucmVmcmVzaERUREwoKX0sdGhpcy5ET00ub2Zmc2V0KCkpXHJcbiAgICBuZXcgY29tcG9uZW50c1Jvdyh0aGlzLmR0ZGxvYmpbXCJjb250ZW50c1wiXSx0aGlzLmxlZnRTcGFuLCgpPT57dGhpcy5yZWZyZXNoRFRETCgpfSlcclxuXHJcbiAgICBpZighdGhpcy5kdGRsb2JqW1wiZXh0ZW5kc1wiXSl0aGlzLmR0ZGxvYmpbXCJleHRlbmRzXCJdPVtdXHJcbiAgICBuZXcgYmFzZUNsYXNzZXNSb3codGhpcy5kdGRsb2JqW1wiZXh0ZW5kc1wiXSx0aGlzLmxlZnRTcGFuLCgpPT57dGhpcy5yZWZyZXNoRFRETCgpfSlcclxufVxyXG5cclxubW9kZWxFZGl0b3JEaWFsb2cucHJvdG90eXBlLnJlZnJlc2hEVERMPWZ1bmN0aW9uKCl7XHJcbiAgICAvL2l0IHdpbGwgcmVmcmVzaCB0aGUgZ2VuZXJhdGVkIERUREwgc2FtcGxlLCBpdCB3aWxsIGFsc28gY2hhbmdlIHRoZSBpbXBvcnQgYnV0dG9uIHRvIHNob3cgXCJDcmVhdGVcIiBvciBcIk1vZGlmeVwiXHJcbiAgICB2YXIgY3VycmVudE1vZGVsSUQ9dGhpcy5kdGRsb2JqW1wiQGlkXCJdXHJcbiAgICBpZihtb2RlbEFuYWx5emVyLkRURExNb2RlbHNbY3VycmVudE1vZGVsSURdPT1udWxsKSB0aGlzLmltcG9ydEJ1dHRvbi50ZXh0KFwiQ3JlYXRlXCIpXHJcbiAgICBlbHNlIHRoaXMuaW1wb3J0QnV0dG9uLnRleHQoXCJNb2RpZnlcIilcclxuXHJcbiAgICB0aGlzLmR0ZGxTY3JpcHRQYW5lbC5lbXB0eSgpXHJcbiAgICB0aGlzLmR0ZGxTY3JpcHRQYW5lbC5hcHBlbmQoJCgnPGRpdiBzdHlsZT1cImhlaWdodDoyMHB4O3dpZHRoOjEwMHB4XCIgY2xhc3M9XCJ3My1iYXIgdzMtZ3JheVwiPkdlbmVyYXRlZCBEVERMPC9kaXY+JykpXHJcbiAgICB0aGlzLmR0ZGxTY3JpcHRQYW5lbC5hcHBlbmQoJCgnPHByZSBzdHlsZT1cImNvbG9yOmdyYXlcIj4nK0pTT04uc3RyaW5naWZ5KHRoaXMuZHRkbG9iaixudWxsLDIpKyc8L3ByZT4nKSlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgbW9kZWxFZGl0b3JEaWFsb2coKTtcclxuXHJcblxyXG5mdW5jdGlvbiBiYXNlQ2xhc3Nlc1JvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYpe1xyXG4gICAgdmFyIHJvd0RPTT0kKCc8ZGl2IGNsYXNzPVwidzMtYmFyXCI+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtICB3My10b29sdGlwXCIgc3R5bGU9XCJmb250LXNpemU6MS4yZW07cGFkZGluZy1sZWZ0OjJweDtmb250LXdlaWdodDpib2xkO2NvbG9yOmdyYXlcIj5CYXNlIENsYXNzZXM8cCBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246bGVmdDt0b3A6LTEwcHg7Zm9udC13ZWlnaHQ6bm9ybWFsO3dpZHRoOjIwMHB4XCIgY2xhc3M9XCJ3My10ZXh0IHczLXRhZyB3My10aW55XCI+QmFzZSBjbGFzcyBtb2RlbFxcJ3MgcGFyYW1ldGVycyBhbmQgcmVsYXRpb25zaGlwIHR5cGUgYXJlIGluaGVyaXRlZDwvcD48L2Rpdj48L2Rpdj4nKVxyXG5cclxuICAgIHZhciBhZGRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yZWQgdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4O2ZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjRweCA4cHhcIj4rPC9idXR0b24+JylcclxuICAgIHJvd0RPTS5hcHBlbmQoYWRkQnV0dG9uKVxyXG4gICAgcGFyZW50RE9NLmFwcGVuZChyb3dET00pXHJcbiAgICB2YXIgY29udGVudERPTT0kKCc8ZGl2IHN0eWxlPVwicGFkZGluZy1sZWZ0OjEwcHhcIj48L2Rpdj4nKVxyXG4gICAgcm93RE9NLmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgYWRkQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHZhciBuZXdPYmogPSBcInVua25vd25cIlxyXG4gICAgICAgIGR0ZGxPYmoucHVzaChuZXdPYmopXHJcbiAgICAgICAgbmV3IHNpbmdsZUJhc2VjbGFzc1JvdyhuZXdPYmosY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9iailcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuICAgIC8vY2hlY2sgZXhpc3RlZCBjb250ZW50IGluaXRpYWxseSBmcm9tIHRlbXBsYXRlIGFuZCB0cmlnZ2VyIHRoZWlyIGRyYXdpbmdcclxuICAgIGR0ZGxPYmouZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBuZXcgc2luZ2xlQmFzZWNsYXNzUm93KGVsZW1lbnQsY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9iailcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaW5nbGVCYXNlY2xhc3NSb3coZHRkbE9iaixwYXJlbnRET00scmVmcmVzaERURExGLHBhcmVudER0ZGxPYmope1xyXG4gICAgdmFyIERPTSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1jZWxsLXJvd1wiPjwvZGl2PicpXHJcbiAgICB2YXIgYmFzZUNsYXNzTmFtZUlucHV0PSQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPVwib3V0bGluZTpub25lO2Rpc3BsYXk6aW5saW5lO3dpZHRoOjIyMHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwiYmFzZSBtb2RlbCBpZFwiLz4nKS5hZGRDbGFzcyhcInczLWJhci1pdGVtIHczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIHZhciByZW1vdmVCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJjb2xvcjpncmF5O21hcmdpbi1sZWZ0OjNweDttYXJnaW4tdG9wOjJweDtmb250LXNpemU6MS4yZW07cGFkZGluZzoycHhcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoIGZhLWxnXCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICBET00uYXBwZW5kKGJhc2VDbGFzc05hbWVJbnB1dCxyZW1vdmVCdXR0b24pXHJcblxyXG4gICAgcmVtb3ZlQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIGZvciAodmFyIGkgPTA7aTwgcGFyZW50RHRkbE9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50RHRkbE9ialtpXSA9PSBkdGRsT2JqKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnREdGRsT2JqLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERPTS5yZW1vdmUoKVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9KVxyXG5cclxuICAgIHBhcmVudERPTS5hcHBlbmQoRE9NKVxyXG5cclxuICAgIGJhc2VDbGFzc05hbWVJbnB1dC52YWwoZHRkbE9iailcclxuICAgIGJhc2VDbGFzc05hbWVJbnB1dC5vbihcImNoYW5nZVwiLCgpPT57XHJcbiAgICAgICAgZm9yICh2YXIgaSA9MDtpPCBwYXJlbnREdGRsT2JqLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnREdGRsT2JqW2ldID09IGR0ZGxPYmopIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudER0ZGxPYmpbaV09YmFzZUNsYXNzTmFtZUlucHV0LnZhbCgpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9uZW50c1JvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYpe1xyXG4gICAgdmFyIHJvd0RPTT0kKCc8ZGl2IGNsYXNzPVwidzMtYmFyXCI+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtICB3My10b29sdGlwXCIgc3R5bGU9XCJmb250LXNpemU6MS4yZW07cGFkZGluZy1sZWZ0OjJweDtmb250LXdlaWdodDpib2xkO2NvbG9yOmdyYXlcIj5Db21wb25lbnRzPHAgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmxlZnQ7dG9wOi0xMHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDt3aWR0aDoyMDBweFwiIGNsYXNzPVwidzMtdGV4dCB3My10YWcgdzMtdGlueVwiPkNvbXBvbmVudCBtb2RlbFxcJ3MgcGFyYW1ldGVycyBhcmUgZW1iZWRkZWQgdW5kZXIgYSBuYW1lPC9wPjwvZGl2PjwvZGl2PicpXHJcblxyXG4gICAgdmFyIGFkZEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJlZCB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwibWFyZ2luLXRvcDoycHg7Zm9udC1zaXplOjEuMmVtO3BhZGRpbmc6NHB4IDhweFwiPis8L2J1dHRvbj4nKVxyXG4gICAgcm93RE9NLmFwcGVuZChhZGRCdXR0b24pXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKHJvd0RPTSlcclxuICAgIHZhciBjb250ZW50RE9NPSQoJzxkaXYgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6MTBweFwiPjwvZGl2PicpXHJcbiAgICByb3dET00uYXBwZW5kKGNvbnRlbnRET00pXHJcblxyXG4gICAgYWRkQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHZhciBuZXdPYmogPSB7XHJcbiAgICAgICAgICAgIFwiQHR5cGVcIjogXCJDb21wb25lbnRcIixcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU29tZUNvbXBvbmVudFwiLFxyXG4gICAgICAgICAgICBcInNjaGVtYVwiOlwiZHRtaTpzb21lQ29tcG9uZW50TW9kZWw7MVwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGR0ZGxPYmoucHVzaChuZXdPYmopXHJcbiAgICAgICAgbmV3IHNpbmdsZUNvbXBvbmVudFJvdyhuZXdPYmosY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9iailcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuICAgIC8vY2hlY2sgZXhpc3RlZCBjb250ZW50IGluaXRpYWxseSBmcm9tIHRlbXBsYXRlIGFuZCB0cmlnZ2VyIHRoZWlyIGRyYXdpbmdcclxuICAgIGR0ZGxPYmouZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBpZihlbGVtZW50W1wiQHR5cGVcIl0hPVwiQ29tcG9uZW50XCIpIHJldHVyblxyXG4gICAgICAgIG5ldyBzaW5nbGVDb21wb25lbnRSb3coZWxlbWVudCxjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqKVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbmdsZUNvbXBvbmVudFJvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYscGFyZW50RHRkbE9iail7XHJcbiAgICB2YXIgRE9NID0gJCgnPGRpdiBjbGFzcz1cInczLWNlbGwtcm93XCI+PC9kaXY+JylcclxuICAgIHZhciBjb21wb25lbnROYW1lSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmU7d2lkdGg6MTAwcHg7cGFkZGluZzo0cHhcIiAgcGxhY2Vob2xkZXI9XCJjb21wb25lbnQgbmFtZVwiLz4nKS5hZGRDbGFzcyhcInczLWJhci1pdGVtIHczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIHZhciBzY2hlbWFJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDoxNjBweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cImNvbXBvbmVudCBtb2RlbCBpZC4uLlwiLz4nKS5hZGRDbGFzcyhcInczLWJhci1pdGVtIHczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIHZhciByZW1vdmVCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJjb2xvcjpncmF5O21hcmdpbi1sZWZ0OjNweDttYXJnaW4tdG9wOjJweDtmb250LXNpemU6MS4yZW07cGFkZGluZzoycHhcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoIGZhLWxnXCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICBET00uYXBwZW5kKGNvbXBvbmVudE5hbWVJbnB1dCxzY2hlbWFJbnB1dCxyZW1vdmVCdXR0b24pXHJcblxyXG4gICAgcmVtb3ZlQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIGZvciAodmFyIGkgPTA7aTwgcGFyZW50RHRkbE9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50RHRkbE9ialtpXSA9PT0gZHRkbE9iaikge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50RHRkbE9iai5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBET00ucmVtb3ZlKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKERPTSlcclxuXHJcbiAgICBjb21wb25lbnROYW1lSW5wdXQudmFsKGR0ZGxPYmpbXCJuYW1lXCJdKVxyXG4gICAgc2NoZW1hSW5wdXQudmFsKGR0ZGxPYmpbXCJzY2hlbWFcIl18fFwiXCIpXHJcblxyXG4gICAgY29tcG9uZW50TmFtZUlucHV0Lm9uKFwiY2hhbmdlXCIsKCk9PntcclxuICAgICAgICBkdGRsT2JqW1wibmFtZVwiXT1jb21wb25lbnROYW1lSW5wdXQudmFsKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuICAgIHNjaGVtYUlucHV0Lm9uKFwiY2hhbmdlXCIsKCk9PntcclxuICAgICAgICBkdGRsT2JqW1wic2NoZW1hXCJdPXNjaGVtYUlucHV0LnZhbCgpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbGF0aW9uc1JvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYsZGlhbG9nT2Zmc2V0KXtcclxuICAgIHZhciByb3dET009JCgnPGRpdiBjbGFzcz1cInczLWJhclwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My10b29sdGlwXCIgc3R5bGU9XCJmb250LXNpemU6MS4yZW07cGFkZGluZy1sZWZ0OjJweDtmb250LXdlaWdodDpib2xkO2NvbG9yOmdyYXlcIj5SZWxhdGlvbnNoaXAgVHlwZXM8cCBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246bGVmdDt0b3A6LTEwcHg7Zm9udC13ZWlnaHQ6bm9ybWFsO3dpZHRoOjIwMHB4XCIgY2xhc3M9XCJ3My10ZXh0IHczLXRhZyB3My10aW55XCI+UmVsYXRpb25zaGlwIGNhbiBoYXZlIGl0cyBvd24gcGFyYW1ldGVyczwvcD48L2Rpdj48L2Rpdj4nKVxyXG5cclxuXHJcbiAgICB2YXIgYWRkQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmVkIHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJtYXJnaW4tdG9wOjJweDtmb250LXNpemU6MS4yZW07cGFkZGluZzo0cHggOHB4XCI+KzwvYnV0dG9uPicpXHJcbiAgICByb3dET00uYXBwZW5kKGFkZEJ1dHRvbilcclxuICAgIHBhcmVudERPTS5hcHBlbmQocm93RE9NKVxyXG4gICAgdmFyIGNvbnRlbnRET009JCgnPGRpdiBzdHlsZT1cInBhZGRpbmctbGVmdDoxMHB4XCI+PC9kaXY+JylcclxuICAgIHJvd0RPTS5hcHBlbmQoY29udGVudERPTSlcclxuXHJcbiAgICBhZGRCdXR0b24ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgdmFyIG5ld09iaiA9IHtcclxuICAgICAgICAgICAgXCJAdHlwZVwiOiBcIlJlbGF0aW9uc2hpcFwiLFxyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZWxhdGlvbjFcIixcclxuICAgICAgICB9XHJcbiAgICAgICAgZHRkbE9iai5wdXNoKG5ld09iailcclxuICAgICAgICBuZXcgc2luZ2xlUmVsYXRpb25UeXBlUm93KG5ld09iaixjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqLGRpYWxvZ09mZnNldClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuXHJcbiAgICAvL2NoZWNrIGV4aXN0ZWQgY29udGVudCBpbml0aWFsbHkgZnJvbSB0ZW1wbGF0ZSBhbmQgdHJpZ2dlciB0aGVpciBkcmF3aW5nXHJcbiAgICBkdGRsT2JqLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgaWYoZWxlbWVudFtcIkB0eXBlXCJdIT1cIlJlbGF0aW9uc2hpcFwiKSByZXR1cm5cclxuICAgICAgICBuZXcgc2luZ2xlUmVsYXRpb25UeXBlUm93KGVsZW1lbnQsY29udGVudERPTSxyZWZyZXNoRFRETEYsZHRkbE9iaixkaWFsb2dPZmZzZXQpXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2luZ2xlUmVsYXRpb25UeXBlUm93KGR0ZGxPYmoscGFyZW50RE9NLHJlZnJlc2hEVERMRixwYXJlbnREdGRsT2JqLGRpYWxvZ09mZnNldCl7XHJcbiAgICB2YXIgRE9NID0gJCgnPGRpdiBjbGFzcz1cInczLWNlbGwtcm93XCI+PC9kaXY+JylcclxuICAgIHZhciByZWxhdGlvbk5hbWVJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDo5MHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwicmVsYXRpb24gbmFtZVwiLz4nKS5hZGRDbGFzcyhcInczLWJhci1pdGVtIHczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIHZhciB0YXJnZXRNb2RlbElEPSQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPVwib3V0bGluZTpub25lO2Rpc3BsYXk6aW5saW5lO3dpZHRoOjE0MHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwiKG9wdGlvbmFsKXRhcmdldCBtb2RlbFwiLz4nKS5hZGRDbGFzcyhcInczLWJhci1pdGVtIHczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIHZhciBhZGRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwiY29sb3I6Z3JheTttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXRvcDoycHg7Zm9udC1zaXplOjEuMmVtO3BhZGRpbmc6MnB4XCI+PGkgY2xhc3M9XCJmYSBmYS1jb2cgZmEtbGdcIj48L2k+PC9idXR0b24+JylcclxuICAgIHZhciByZW1vdmVCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLWhvdmVyLWFtYmVyXCIgc3R5bGU9XCJjb2xvcjpncmF5O21hcmdpbi1sZWZ0OjNweDttYXJnaW4tdG9wOjJweDtmb250LXNpemU6MS4yZW07cGFkZGluZzoycHhcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoIGZhLWxnXCI+PC9pPjwvYnV0dG9uPicpXHJcbiAgICBET00uYXBwZW5kKHJlbGF0aW9uTmFtZUlucHV0LHRhcmdldE1vZGVsSUQsYWRkQnV0dG9uLHJlbW92ZUJ1dHRvbilcclxuXHJcbiAgICByZW1vdmVCdXR0b24ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgZm9yICh2YXIgaSA9MDtpPCBwYXJlbnREdGRsT2JqLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnREdGRsT2JqW2ldID09PSBkdGRsT2JqKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnREdGRsT2JqLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERPTS5yZW1vdmUoKVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9KVxyXG5cclxuICAgIHZhciBjb250ZW50RE9NPSQoJzxkaXYgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6MTBweFwiPjwvZGl2PicpXHJcbiAgICBET00uYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKERPTSlcclxuXHJcbiAgICByZWxhdGlvbk5hbWVJbnB1dC52YWwoZHRkbE9ialtcIm5hbWVcIl0pXHJcbiAgICB0YXJnZXRNb2RlbElELnZhbChkdGRsT2JqW1widGFyZ2V0XCJdfHxcIlwiKVxyXG5cclxuICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICBpZighIGR0ZGxPYmpbXCJwcm9wZXJ0aWVzXCJdKSBkdGRsT2JqW1wicHJvcGVydGllc1wiXT1bXVxyXG4gICAgICAgIHZhciBuZXdPYmogPSB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm5ld1BcIixcclxuICAgICAgICAgICAgXCJzY2hlbWFcIjogXCJkb3VibGVcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBkdGRsT2JqW1wicHJvcGVydGllc1wiXS5wdXNoKG5ld09iailcclxuICAgICAgICBuZXcgc2luZ2xlUGFyYW1ldGVyUm93KG5ld09iaixjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqW1wicHJvcGVydGllc1wiXSxudWxsLGRpYWxvZ09mZnNldClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuXHJcbiAgICByZWxhdGlvbk5hbWVJbnB1dC5vbihcImNoYW5nZVwiLCgpPT57XHJcbiAgICAgICAgZHRkbE9ialtcIm5hbWVcIl09cmVsYXRpb25OYW1lSW5wdXQudmFsKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuICAgIHRhcmdldE1vZGVsSUQub24oXCJjaGFuZ2VcIiwoKT0+e1xyXG4gICAgICAgIGlmKHRhcmdldE1vZGVsSUQudmFsKCk9PVwiXCIpIGRlbGV0ZSBkdGRsT2JqW1widGFyZ2V0XCJdXHJcbiAgICAgICAgZWxzZSBkdGRsT2JqW1widGFyZ2V0XCJdPXRhcmdldE1vZGVsSUQudmFsKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuICAgIGlmKGR0ZGxPYmpbXCJwcm9wZXJ0aWVzXCJdICYmIGR0ZGxPYmpbXCJwcm9wZXJ0aWVzXCJdLmxlbmd0aD4wKXtcclxuICAgICAgICB2YXIgcHJvcGVydGllcz1kdGRsT2JqW1wicHJvcGVydGllc1wiXVxyXG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChvbmVQcm9wZXJ0eT0+e1xyXG4gICAgICAgICAgICBuZXcgc2luZ2xlUGFyYW1ldGVyUm93KG9uZVByb3BlcnR5LGNvbnRlbnRET00scmVmcmVzaERURExGLGR0ZGxPYmpbXCJwcm9wZXJ0aWVzXCJdLG51bGwsZGlhbG9nT2Zmc2V0KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcmFtZXRlcnNSb3coZHRkbE9iaixwYXJlbnRET00scmVmcmVzaERURExGLGRpYWxvZ09mZnNldCl7XHJcbiAgICB2YXIgcm93RE9NPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nLWxlZnQ6MnB4O2ZvbnQtd2VpZ2h0OmJvbGQ7Y29sb3I6Z3JheVwiPlBhcmFtZXRlcnM8L2Rpdj48L2Rpdj4nKVxyXG4gICAgdmFyIGFkZEJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJlZCB3My1ob3Zlci1hbWJlclwiIHN0eWxlPVwibWFyZ2luLXRvcDoycHg7Zm9udC1zaXplOjEuMmVtO3BhZGRpbmc6NHB4IDhweFwiPis8L2J1dHRvbj4nKVxyXG4gICAgcm93RE9NLmFwcGVuZChhZGRCdXR0b24pXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKHJvd0RPTSlcclxuICAgIHZhciBjb250ZW50RE9NPSQoJzxkaXYgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6MTBweFwiPjwvZGl2PicpXHJcbiAgICByb3dET00uYXBwZW5kKGNvbnRlbnRET00pXHJcbiAgICBhZGRCdXR0b24ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgdmFyIG5ld09iaiA9IHtcclxuICAgICAgICAgICAgXCJAdHlwZVwiOiBcIlByb3BlcnR5XCIsXHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm5ld1BcIixcclxuICAgICAgICAgICAgXCJzY2hlbWFcIjogXCJkb3VibGVcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBkdGRsT2JqLnB1c2gobmV3T2JqKVxyXG4gICAgICAgIG5ldyBzaW5nbGVQYXJhbWV0ZXJSb3cobmV3T2JqLGNvbnRlbnRET00scmVmcmVzaERURExGLGR0ZGxPYmosXCJ0b3BMZXZlbFwiLGRpYWxvZ09mZnNldClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuXHJcbiAgICAvL2NoZWNrIGV4aXN0ZWQgY29udGVudCBpbml0aWFsbHkgZnJvbSB0ZW1wbGF0ZSBhbmQgdHJpZ2dlciB0aGVpciBkcmF3aW5nXHJcbiAgICBkdGRsT2JqLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgaWYoZWxlbWVudFtcIkB0eXBlXCJdIT1cIlByb3BlcnR5XCIpIHJldHVyblxyXG4gICAgICAgIG5ldyBzaW5nbGVQYXJhbWV0ZXJSb3coZWxlbWVudCxjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqLFwidG9wTGV2ZWxcIixkaWFsb2dPZmZzZXQpXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2luZ2xlUGFyYW1ldGVyUm93KGR0ZGxPYmoscGFyZW50RE9NLHJlZnJlc2hEVERMRixwYXJlbnREdGRsT2JqLHRvcExldmVsLGRpYWxvZ09mZnNldCl7XHJcbiAgICB2YXIgRE9NID0gJCgnPGRpdiBjbGFzcz1cInczLWNlbGwtcm93XCI+PC9kaXY+JylcclxuICAgIHZhciBwYXJhbWV0ZXJOYW1lSW5wdXQ9JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmU7d2lkdGg6MTAwcHg7cGFkZGluZzo0cHhcIiAgcGxhY2Vob2xkZXI9XCJwYXJhbWV0ZXIgbmFtZVwiLz4nKS5hZGRDbGFzcyhcInczLWJhci1pdGVtIHczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIHZhciBlbnVtVmFsdWVJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDoxMDBweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cInN0cjEsc3RyMiwuLi5cIi8+JykuYWRkQ2xhc3MoXCJ3My1iYXItaXRlbSB3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgYWRkQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1iYXItaXRlbSB3My1idXR0b24gdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cImNvbG9yOmdyYXk7bWFyZ2luLWxlZnQ6M3B4O21hcmdpbi10b3A6MnB4O2ZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjJweFwiPjxpIGNsYXNzPVwiZmEgZmEtcGx1cyBmYS1sZ1wiPjwvaT48L2J1dHRvbj4nKVxyXG4gICAgdmFyIHJlbW92ZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cImNvbG9yOmdyYXk7bWFyZ2luLWxlZnQ6M3B4O21hcmdpbi10b3A6MnB4O2ZvbnQtc2l6ZToxLjJlbTtwYWRkaW5nOjJweFwiPjxpIGNsYXNzPVwiZmEgZmEtdHJhc2ggZmEtbGdcIj48L2k+PC9idXR0b24+JylcclxuICAgIHZhciBwdHlwZVNlbGVjdG9yPW5ldyBzaW1wbGVTZWxlY3RNZW51KFwiIFwiLHt3aXRoQm9yZGVyOjEsZm9udFNpemU6XCIxZW1cIixjb2xvckNsYXNzOlwidzMtbGlnaHQtZ3JheSB3My1iYXItaXRlbVwiLGJ1dHRvbkNTUzp7XCJwYWRkaW5nXCI6XCI0cHggNXB4XCJ9LFwib3B0aW9uTGlzdEhlaWdodFwiOjMwMCxcImlzQ2xpY2thYmxlXCI6MSxcIm9wdGlvbkxpc3RNYXJnaW5Ub3BcIjotMTUwLFwib3B0aW9uTGlzdE1hcmdpbkxlZnRcIjo2MCxcclxuICAgIFwiYWRqdXN0UG9zaXRpb25BbmNob3JcIjpkaWFsb2dPZmZzZXR9KVxyXG4gICAgcHR5cGVTZWxlY3Rvci5hZGRPcHRpb25BcnIoW1wic3RyaW5nXCIsXCJmbG9hdFwiLFwiaW50ZWdlclwiLFwiRW51bVwiLFwiT2JqZWN0XCIsXCJkb3VibGVcIixcImJvb2xlYW5cIixcImRhdGVcIixcImRhdGVUaW1lXCIsXCJkdXJhdGlvblwiLFwibG9uZ1wiLFwidGltZVwiXSlcclxuICAgIERPTS5hcHBlbmQocGFyYW1ldGVyTmFtZUlucHV0LHB0eXBlU2VsZWN0b3IuRE9NLGVudW1WYWx1ZUlucHV0LGFkZEJ1dHRvbixyZW1vdmVCdXR0b24pXHJcblxyXG4gICAgcmVtb3ZlQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIGZvciAodmFyIGkgPTA7aTwgcGFyZW50RHRkbE9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50RHRkbE9ialtpXSA9PT0gZHRkbE9iaikge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50RHRkbE9iai5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBET00ucmVtb3ZlKClcclxuICAgICAgICByZWZyZXNoRFRETEYoKVxyXG4gICAgfSlcclxuICAgIFxyXG4gICAgdmFyIGNvbnRlbnRET009JCgnPGRpdiBzdHlsZT1cInBhZGRpbmctbGVmdDoxMHB4XCI+PC9kaXY+JylcclxuICAgIERPTS5hcHBlbmQoY29udGVudERPTSlcclxuICAgIHBhcmVudERPTS5hcHBlbmQoRE9NKVxyXG5cclxuICAgIHBhcmFtZXRlck5hbWVJbnB1dC52YWwoZHRkbE9ialtcIm5hbWVcIl0pXHJcbiAgICBwdHlwZVNlbGVjdG9yLmNhbGxCYWNrX2NsaWNrT3B0aW9uPShvcHRpb25UZXh0LG9wdGlvblZhbHVlLHJlYWxNb3VzZUNsaWNrKT0+e1xyXG4gICAgICAgIHB0eXBlU2VsZWN0b3IuY2hhbmdlTmFtZShvcHRpb25UZXh0KVxyXG4gICAgICAgIGNvbnRlbnRET00uZW1wdHkoKS8vY2xlYXIgYWxsIGNvbnRlbnQgZG9tIGNvbnRlbnRcclxuICAgICAgICBpZihyZWFsTW91c2VDbGljayl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaW5kIGluIGR0ZGxPYmopIGRlbGV0ZSBkdGRsT2JqW2luZF0gICAgLy9jbGVhciBhbGwgb2JqZWN0IGNvbnRlbnRcclxuICAgICAgICAgICAgaWYodG9wTGV2ZWwpIGR0ZGxPYmpbXCJAdHlwZVwiXT1cIlByb3BlcnR5XCJcclxuICAgICAgICAgICAgZHRkbE9ialtcIm5hbWVcIl09cGFyYW1ldGVyTmFtZUlucHV0LnZhbCgpXHJcbiAgICAgICAgfSBcclxuICAgICAgICBpZihvcHRpb25UZXh0PT1cIkVudW1cIil7XHJcbiAgICAgICAgICAgIGVudW1WYWx1ZUlucHV0LnZhbChcIlwiKVxyXG4gICAgICAgICAgICBlbnVtVmFsdWVJbnB1dC5zaG93KCk7XHJcbiAgICAgICAgICAgIGFkZEJ1dHRvbi5oaWRlKClcclxuICAgICAgICAgICAgaWYocmVhbE1vdXNlQ2xpY2spIGR0ZGxPYmpbXCJzY2hlbWFcIl09e1wiQHR5cGVcIjogXCJFbnVtXCIsXCJ2YWx1ZVNjaGVtYVwiOiBcInN0cmluZ1wifVxyXG4gICAgICAgIH1lbHNlIGlmKG9wdGlvblRleHQ9PVwiT2JqZWN0XCIpe1xyXG4gICAgICAgICAgICBlbnVtVmFsdWVJbnB1dC5oaWRlKCk7XHJcbiAgICAgICAgICAgIGFkZEJ1dHRvbi5zaG93KClcclxuICAgICAgICAgICAgaWYocmVhbE1vdXNlQ2xpY2spIGR0ZGxPYmpbXCJzY2hlbWFcIl09e1wiQHR5cGVcIjogXCJPYmplY3RcIn1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgaWYocmVhbE1vdXNlQ2xpY2spIGR0ZGxPYmpbXCJzY2hlbWFcIl09b3B0aW9uVGV4dFxyXG4gICAgICAgICAgICBlbnVtVmFsdWVJbnB1dC5oaWRlKCk7XHJcbiAgICAgICAgICAgIGFkZEJ1dHRvbi5oaWRlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH1cclxuICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICBpZighIGR0ZGxPYmpbXCJzY2hlbWFcIl1bXCJmaWVsZHNcIl0pIGR0ZGxPYmpbXCJzY2hlbWFcIl1bXCJmaWVsZHNcIl09W11cclxuICAgICAgICB2YXIgbmV3T2JqID0ge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJuZXdQXCIsXHJcbiAgICAgICAgICAgIFwic2NoZW1hXCI6IFwiZG91YmxlXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZHRkbE9ialtcInNjaGVtYVwiXVtcImZpZWxkc1wiXS5wdXNoKG5ld09iailcclxuICAgICAgICBuZXcgc2luZ2xlUGFyYW1ldGVyUm93KG5ld09iaixjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqW1wic2NoZW1hXCJdW1wiZmllbGRzXCJdLG51bGwsZGlhbG9nT2Zmc2V0KVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9KVxyXG5cclxuICAgIHBhcmFtZXRlck5hbWVJbnB1dC5vbihcImNoYW5nZVwiLCgpPT57XHJcbiAgICAgICAgZHRkbE9ialtcIm5hbWVcIl09cGFyYW1ldGVyTmFtZUlucHV0LnZhbCgpXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH0pXHJcbiAgICBlbnVtVmFsdWVJbnB1dC5vbihcImNoYW5nZVwiLCgpPT57XHJcbiAgICAgICAgdmFyIHZhbHVlQXJyPWVudW1WYWx1ZUlucHV0LnZhbCgpLnNwbGl0KFwiLFwiKVxyXG4gICAgICAgIGR0ZGxPYmpbXCJzY2hlbWFcIl1bXCJlbnVtVmFsdWVzXCJdPVtdXHJcbiAgICAgICAgdmFsdWVBcnIuZm9yRWFjaChhVmFsPT57XHJcbiAgICAgICAgICAgIGR0ZGxPYmpbXCJzY2hlbWFcIl1bXCJlbnVtVmFsdWVzXCJdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IGFWYWwucmVwbGFjZShcIiBcIixcIlwiKSwgLy9yZW1vdmUgYWxsIHRoZSBzcGFjZSBpbiBuYW1lXHJcbiAgICAgICAgICAgICAgICBcImVudW1WYWx1ZVwiOiBhVmFsXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9KVxyXG4gICAgaWYodHlwZW9mKGR0ZGxPYmpbXCJzY2hlbWFcIl0pICE9ICdvYmplY3QnKSB2YXIgc2NoZW1hPWR0ZGxPYmpbXCJzY2hlbWFcIl1cclxuICAgIGVsc2Ugc2NoZW1hPWR0ZGxPYmpbXCJzY2hlbWFcIl1bXCJAdHlwZVwiXVxyXG4gICAgcHR5cGVTZWxlY3Rvci50cmlnZ2VyT3B0aW9uVmFsdWUoc2NoZW1hKVxyXG4gICAgaWYoc2NoZW1hPT1cIkVudW1cIil7XHJcbiAgICAgICAgdmFyIGVudW1BcnI9ZHRkbE9ialtcInNjaGVtYVwiXVtcImVudW1WYWx1ZXNcIl1cclxuICAgICAgICBpZihlbnVtQXJyIT1udWxsKXtcclxuICAgICAgICAgICAgdmFyIGlucHV0U3RyPVwiXCJcclxuICAgICAgICAgICAgZW51bUFyci5mb3JFYWNoKG9uZUVudW1WYWx1ZT0+e2lucHV0U3RyKz1vbmVFbnVtVmFsdWUuZW51bVZhbHVlK1wiLFwifSlcclxuICAgICAgICAgICAgaW5wdXRTdHI9aW5wdXRTdHIuc2xpY2UoMCwgLTEpLy9yZW1vdmUgdGhlIGxhc3QgXCIsXCJcclxuICAgICAgICAgICAgZW51bVZhbHVlSW5wdXQudmFsKGlucHV0U3RyKVxyXG4gICAgICAgIH1cclxuICAgIH1lbHNlIGlmKHNjaGVtYT09XCJPYmplY3RcIil7XHJcbiAgICAgICAgdmFyIGZpZWxkcz1kdGRsT2JqW1wic2NoZW1hXCJdW1wiZmllbGRzXCJdXHJcbiAgICAgICAgZmllbGRzLmZvckVhY2gob25lRmllbGQ9PntcclxuICAgICAgICAgICAgbmV3IHNpbmdsZVBhcmFtZXRlclJvdyhvbmVGaWVsZCxjb250ZW50RE9NLHJlZnJlc2hEVERMRixkdGRsT2JqW1wic2NoZW1hXCJdW1wiZmllbGRzXCJdLG51bGwsZGlhbG9nT2Zmc2V0KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpZFJvdyhkdGRsT2JqLHBhcmVudERPTSxyZWZyZXNoRFRETEYpe1xyXG4gICAgdmFyIERPTSA9ICQoJzxkaXYgY2xhc3M9XCJ3My1jZWxsLXJvd1wiPjwvZGl2PicpXHJcbiAgICB2YXIgbGFiZWwxPSQoJzxkaXYgY2xhc3M9XCJ3My1vcGFjaXR5XCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZVwiPmR0bWk6PC9kaXY+JylcclxuICAgIHZhciBkb21haW5JbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDo4OHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwiTmFtZXNwYWNlXCIvPicpLmFkZENsYXNzKFwidzMtaW5wdXQgdzMtYm9yZGVyXCIpO1xyXG4gICAgdmFyIG1vZGVsSURJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZTt3aWR0aDoxMzJweDtwYWRkaW5nOjRweFwiICBwbGFjZWhvbGRlcj1cIk1vZGVsSURcIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB2YXIgdmVyc2lvbklucHV0PSQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPVwib3V0bGluZTpub25lO2Rpc3BsYXk6aW5saW5lO3dpZHRoOjYwcHg7cGFkZGluZzo0cHhcIiAgcGxhY2Vob2xkZXI9XCJ2ZXJzaW9uXCIvPicpLmFkZENsYXNzKFwidzMtaW5wdXQgdzMtYm9yZGVyXCIpO1xyXG4gICAgRE9NLmFwcGVuZChsYWJlbDEsZG9tYWluSW5wdXQsJCgnPGRpdiBjbGFzcz1cInczLW9wYWNpdHlcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lXCI+OjwvZGl2PicpLG1vZGVsSURJbnB1dCwkKCc8ZGl2IGNsYXNzPVwidzMtb3BhY2l0eVwiIHN0eWxlPVwiZGlzcGxheTppbmxpbmVcIj47PC9kaXY+JyksdmVyc2lvbklucHV0KVxyXG4gICAgcGFyZW50RE9NLmFwcGVuZChET00pXHJcblxyXG4gICAgdmFyIHZhbHVlQ2hhbmdlPSgpPT57XHJcbiAgICAgICAgdmFyIHN0cj1gZHRtaToke2RvbWFpbklucHV0LnZhbCgpfToke21vZGVsSURJbnB1dC52YWwoKX07JHt2ZXJzaW9uSW5wdXQudmFsKCl9YFxyXG4gICAgICAgIGR0ZGxPYmpbXCJAaWRcIl09c3RyXHJcbiAgICAgICAgcmVmcmVzaERURExGKClcclxuICAgIH1cclxuICAgIGRvbWFpbklucHV0Lm9uKFwiY2hhbmdlXCIsdmFsdWVDaGFuZ2UpXHJcbiAgICBtb2RlbElESW5wdXQub24oXCJjaGFuZ2VcIix2YWx1ZUNoYW5nZSlcclxuICAgIHZlcnNpb25JbnB1dC5vbihcImNoYW5nZVwiLHZhbHVlQ2hhbmdlKVxyXG5cclxuICAgIHZhciBzdHI9ZHRkbE9ialtcIkBpZFwiXVxyXG4gICAgaWYoc3RyIT1cIlwiICYmIHN0ciE9bnVsbCl7XHJcbiAgICAgICAgdmFyIGFycjE9c3RyLnNwbGl0KFwiO1wiKVxyXG4gICAgICAgIGlmKGFycjEubGVuZ3RoIT0yKSByZXR1cm47XHJcbiAgICAgICAgdmVyc2lvbklucHV0LnZhbChhcnIxWzFdKVxyXG4gICAgICAgIHZhciBhcnIyPWFycjFbMF0uc3BsaXQoXCI6XCIpXHJcbiAgICAgICAgZG9tYWluSW5wdXQudmFsKGFycjJbMV0pXHJcbiAgICAgICAgYXJyMi5zaGlmdCgpOyBhcnIyLnNoaWZ0KClcclxuICAgICAgICBtb2RlbElESW5wdXQudmFsKGFycjIuam9pbihcIjpcIikpXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc3BsYXlOYW1lUm93KGR0ZGxPYmoscGFyZW50RE9NLHJlZnJlc2hEVERMRil7XHJcbiAgICB2YXIgRE9NID0gJCgnPGRpdiBjbGFzcz1cInczLWNlbGwtcm93XCI+PC9kaXY+JylcclxuICAgIHZhciBsYWJlbDE9JCgnPGRpdiBjbGFzcz1cInczLW9wYWNpdHlcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lXCI+RGlzcGxheSBOYW1lOjwvZGl2PicpXHJcbiAgICB2YXIgbmFtZUlucHV0PSQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPVwib3V0bGluZTpub25lO2Rpc3BsYXk6aW5saW5lO3dpZHRoOjE1MHB4O3BhZGRpbmc6NHB4XCIgIHBsYWNlaG9sZGVyPVwiTW9kZWxJRFwiLz4nKS5hZGRDbGFzcyhcInczLWlucHV0IHczLWJvcmRlclwiKTtcclxuICAgIERPTS5hcHBlbmQobGFiZWwxLG5hbWVJbnB1dClcclxuICAgIHBhcmVudERPTS5hcHBlbmQoRE9NKVxyXG4gICAgdmFyIHZhbHVlQ2hhbmdlPSgpPT57XHJcbiAgICAgICAgZHRkbE9ialtcImRpc3BsYXlOYW1lXCJdPW5hbWVJbnB1dC52YWwoKVxyXG4gICAgICAgIHJlZnJlc2hEVERMRigpXHJcbiAgICB9XHJcbiAgICBuYW1lSW5wdXQub24oXCJjaGFuZ2VcIix2YWx1ZUNoYW5nZSlcclxuICAgIHZhciBzdHI9ZHRkbE9ialtcImRpc3BsYXlOYW1lXCJdXHJcbiAgICBpZihzdHIhPVwiXCIgJiYgc3RyIT1udWxsKSBuYW1lSW5wdXQudmFsKHN0cilcclxufSIsImNvbnN0IG1vZGVsQW5hbHl6ZXI9cmVxdWlyZShcIi4vbW9kZWxBbmFseXplclwiKVxyXG5jb25zdCBzaW1wbGVUcmVlPSByZXF1aXJlKFwiLi9zaW1wbGVUcmVlXCIpXHJcbmNvbnN0IHNpbXBsZUNvbmZpcm1EaWFsb2cgPSByZXF1aXJlKFwiLi9zaW1wbGVDb25maXJtRGlhbG9nXCIpXHJcbmNvbnN0IG1vZGVsRWRpdG9yRGlhbG9nID0gcmVxdWlyZShcIi4vbW9kZWxFZGl0b3JEaWFsb2dcIilcclxuY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBtc2FsSGVscGVyPXJlcXVpcmUoXCIuLi9tc2FsSGVscGVyXCIpXHJcbmNvbnN0IHNpbXBsZUV4cGFuZGFibGVTZWN0aW9uPSByZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlRXhwYW5kYWJsZVNlY3Rpb25cIilcclxuY29uc3Qgc2ltcGxlU2VsZWN0TWVudT1yZXF1aXJlKFwiLi4vc2hhcmVkU291cmNlRmlsZXMvc2ltcGxlU2VsZWN0TWVudVwiKVxyXG5mdW5jdGlvbiBtb2RlbE1hbmFnZXJEaWFsb2coKSB7XHJcbiAgICBpZighdGhpcy5ET00pe1xyXG4gICAgICAgIHRoaXMuRE9NID0gJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtsZWZ0OjUwJTt0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTt6LWluZGV4Ojk5XCIgY2xhc3M9XCJ3My1jYXJkLTJcIj48L2Rpdj4nKVxyXG4gICAgICAgIHRoaXMuRE9NLmNzcyhcIm92ZXJmbG93XCIsXCJoaWRkZW5cIilcclxuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICAgICAgdGhpcy5ET00uaGlkZSgpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUubWFrZURPTURyYWdnYWJsZSh0aGlzLkRPTSlcclxuICAgIH1cclxuICAgIHRoaXMuc2hvd1JlbGF0aW9uVmlzdWFsaXphdGlvblNldHRpbmdzPXRydWU7XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUucG9wdXAgPSBhc3luYyBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgdGhpcy5ET00uZW1wdHkoKVxyXG4gICAgdGhpcy5jb250ZW50RE9NID0gJCgnPGRpdiBzdHlsZT1cIndpZHRoOjcwMHB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmNvbnRlbnRET00pXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuNWVtXCI+RGlnaXRhbCBUd2luIE1vZGVsczwvZGl2PjwvZGl2PicpKVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbTtwYWRkaW5nLXRvcDo0cHhcIj7DlzwvYnV0dG9uPicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLkRPTS5oaWRlKCkgfSlcclxuXHJcbiAgICB2YXIgaW1wb3J0TW9kZWxzQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1jYXJkIHczLWRlZXAtb3JhbmdlIHczLWhvdmVyLWxpZ2h0LWdyZWVuXCIgc3R5bGU9XCJoZWlnaHQ6MTAwJVwiPkltcG9ydDwvYnV0dG9uPicpXHJcbiAgICB2YXIgYWN0dWFsSW1wb3J0TW9kZWxzQnRuID0kKCc8aW5wdXQgdHlwZT1cImZpbGVcIiBuYW1lPVwibW9kZWxGaWxlc1wiIG11bHRpcGxlPVwibXVsdGlwbGVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPjwvaW5wdXQ+JylcclxuICAgIHZhciBtb2RlbEVkaXRvckJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtY2FyZCB3My1kZWVwLW9yYW5nZSB3My1ob3Zlci1saWdodC1ncmVlblwiIHN0eWxlPVwiaGVpZ2h0OjEwMCVcIj5DcmVhdGUvTW9kaWZ5IE1vZGVsPC9idXR0b24+JylcclxuICAgIHZhciBleHBvcnRNb2RlbEJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWNhcmQgdzMtZGVlcC1vcmFuZ2UgdzMtaG92ZXItbGlnaHQtZ3JlZW5cIiBzdHlsZT1cImhlaWdodDoxMDAlXCI+RXhwb3J0IEFsbCBNb2RlbHM8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQoaW1wb3J0TW9kZWxzQnRuLGFjdHVhbEltcG9ydE1vZGVsc0J0biwgbW9kZWxFZGl0b3JCdG4sZXhwb3J0TW9kZWxCdG4pXHJcbiAgICBpbXBvcnRNb2RlbHNCdG4ub24oXCJjbGlja1wiLCAoKT0+e1xyXG4gICAgICAgIGFjdHVhbEltcG9ydE1vZGVsc0J0bi50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgfSk7XHJcbiAgICBhY3R1YWxJbXBvcnRNb2RlbHNCdG4uY2hhbmdlKGFzeW5jIChldnQpPT57XHJcbiAgICAgICAgdmFyIGZpbGVzID0gZXZ0LnRhcmdldC5maWxlczsgLy8gRmlsZUxpc3Qgb2JqZWN0XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkTW9kZWxGaWxlc0NvbnRlbnRBbmRJbXBvcnQoZmlsZXMpXHJcbiAgICAgICAgYWN0dWFsSW1wb3J0TW9kZWxzQnRuLnZhbChcIlwiKVxyXG4gICAgfSlcclxuICAgIG1vZGVsRWRpdG9yQnRuLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIG1vZGVsRWRpdG9yRGlhbG9nLnBvcHVwKClcclxuICAgIH0pXHJcbiAgICBleHBvcnRNb2RlbEJ0bi5vbihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICB2YXIgbW9kZWxBcnI9W11cclxuICAgICAgICBmb3IodmFyIG1vZGVsSUQgaW4gbW9kZWxBbmFseXplci5EVERMTW9kZWxzKSBtb2RlbEFyci5wdXNoKEpTT04ucGFyc2UobW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdW1wib3JpZ2luYWxcIl0pKVxyXG4gICAgICAgIHZhciBwb20gPSAkKFwiPGE+PC9hPlwiKVxyXG4gICAgICAgIHBvbS5hdHRyKCdocmVmJywgJ2RhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobW9kZWxBcnIpKSk7XHJcbiAgICAgICAgcG9tLmF0dHIoJ2Rvd25sb2FkJywgXCJleHBvcnRNb2RlbHMuanNvblwiKTtcclxuICAgICAgICBwb21bMF0uY2xpY2soKVxyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgcm93Mj0kKCc8ZGl2IGNsYXNzPVwidzMtY2VsbC1yb3dcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQocm93MilcclxuICAgIHZhciBsZWZ0U3Bhbj0kKCc8ZGl2IGNsYXNzPVwidzMtY2VsbFwiIHN0eWxlPVwid2lkdGg6MjQwcHg7cGFkZGluZy1yaWdodDo1cHhcIj48L2Rpdj4nKVxyXG4gICAgcm93Mi5hcHBlbmQobGVmdFNwYW4pXHJcbiAgICBsZWZ0U3Bhbi5hcHBlbmQoJCgnPGRpdiBzdHlsZT1cImhlaWdodDozMHB4XCIgY2xhc3M9XCJ3My1iYXIgdzMtcmVkXCI+PGRpdiBjbGFzcz1cInczLWJhci1pdGVtXCIgc3R5bGU9XCJcIj5Nb2RlbHM8L2Rpdj48L2Rpdj4nKSlcclxuICAgIFxyXG4gICAgdmFyIG1vZGVsTGlzdCA9ICQoJzx1bCBjbGFzcz1cInczLXVsIHczLWhvdmVyYWJsZVwiPicpXHJcbiAgICBtb2RlbExpc3QuY3NzKHtcIm92ZXJmbG93LXhcIjpcImhpZGRlblwiLFwib3ZlcmZsb3cteVwiOlwiYXV0b1wiLFwiaGVpZ2h0XCI6XCI0MjBweFwiLCBcImJvcmRlclwiOlwic29saWQgMXB4IGxpZ2h0Z3JheVwifSlcclxuICAgIGxlZnRTcGFuLmFwcGVuZChtb2RlbExpc3QpXHJcbiAgICB0aGlzLm1vZGVsTGlzdCA9IG1vZGVsTGlzdDtcclxuICAgIFxyXG4gICAgdmFyIHJpZ2h0U3Bhbj0kKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyIHczLWNlbGxcIiBzdHlsZT1cInBhZGRpbmc6MHB4XCI+PC9kaXY+JylcclxuICAgIHJvdzIuYXBwZW5kKHJpZ2h0U3BhbikgXHJcbiAgICB2YXIgcGFuZWxDYXJkT3V0PSQoJzxkaXYgY2xhc3M9XCJ3My1jYXJkLTIgdzMtd2hpdGVcIiBzdHlsZT1cIm1hcmdpbi10b3A6MnB4XCI+PC9kaXY+JylcclxuXHJcbiAgICB0aGlzLm1vZGVsQnV0dG9uQmFyPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cImhlaWdodDozNXB4XCI+PC9kaXY+JylcclxuICAgIHBhbmVsQ2FyZE91dC5hcHBlbmQodGhpcy5tb2RlbEJ1dHRvbkJhcilcclxuXHJcbiAgICByaWdodFNwYW4uYXBwZW5kKHBhbmVsQ2FyZE91dClcclxuICAgIHZhciBwYW5lbENhcmQ9JCgnPGRpdiBzdHlsZT1cIndpZHRoOjQ2MHB4O2hlaWdodDo0MTJweDtvdmVyZmxvdzphdXRvO21hcmdpbi10b3A6MnB4XCI+PC9kaXY+JylcclxuICAgIHBhbmVsQ2FyZE91dC5hcHBlbmQocGFuZWxDYXJkKVxyXG4gICAgdGhpcy5wYW5lbENhcmQ9cGFuZWxDYXJkO1xyXG5cclxuICAgIHRoaXMubW9kZWxCdXR0b25CYXIuZW1wdHkoKVxyXG4gICAgcGFuZWxDYXJkLmh0bWwoXCI8YSBzdHlsZT0nZGlzcGxheTpibG9jaztmb250LXN0eWxlOml0YWxpYztjb2xvcjpncmF5O3BhZGRpbmctbGVmdDo1cHgnPkNob29zZSBhIG1vZGVsIHRvIHZpZXcgaW5mb21yYXRpb248L2E+XCIpXHJcblxyXG4gICAgdGhpcy5saXN0TW9kZWxzKClcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5yZXNpemVJbWdGaWxlID0gYXN5bmMgZnVuY3Rpb24odGhlRmlsZSxtYXhfc2l6ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgdmFyIHRtcEltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdG1wSW1nLm9ubG9hZCA9ICAoKT0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0bXBJbWcud2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdG1wSW1nLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gbWF4X3NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAqPSBtYXhfc2l6ZSAvIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBtYXhfc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPiBtYXhfc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKj0gbWF4X3NpemUgLyBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtYXhfc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0bXBJbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhVXJsKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG1wSW1nLnNyYyA9IHJlYWRlci5yZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwodGhlRmlsZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZWplY3QoZSlcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmZpbGxSaWdodFNwYW49YXN5bmMgZnVuY3Rpb24obW9kZWxJRCl7XHJcbiAgICB0aGlzLnBhbmVsQ2FyZC5lbXB0eSgpXHJcbiAgICB0aGlzLm1vZGVsQnV0dG9uQmFyLmVtcHR5KClcclxuXHJcbiAgICB2YXIgZGVsQnRuID0gJCgnPGJ1dHRvbiBzdHlsZT1cIm1hcmdpbi1ib3R0b206MnB4XCIgY2xhc3M9XCJ3My1yaXBwbGUgdzMtYnV0dG9uIHczLWxpZ2h0LWdyYXkgdzMtaG92ZXItcGluayB3My1ib3JkZXItcmlnaHRcIj5EZWxldGUgTW9kZWw8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5tb2RlbEJ1dHRvbkJhci5hcHBlbmQoZGVsQnRuKVxyXG5cclxuXHJcbiAgICB2YXIgaW1wb3J0UGljQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1saWdodC1ncmF5IHczLWhvdmVyLWFtYmVyIHczLWJvcmRlci1yaWdodFwiPlVwbG9hZCBBdmFydGE8L2J1dHRvbj4nKVxyXG4gICAgdmFyIGFjdHVhbEltcG9ydFBpY0J0biA9ICQoJzxpbnB1dCB0eXBlPVwiZmlsZVwiIG5hbWU9XCJpbWdcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPjwvaW5wdXQ+JylcclxuICAgIHZhciBjaG9vc2VBdmFydGFCdG4gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1saWdodC1ncmF5IHczLWhvdmVyLXBpbmsgdzMtYm9yZGVyLXJpZ2h0XCI+Q2hvb3NlIEEgU3ltYm9sPC9idXR0b24+JylcclxuICAgIFxyXG4gICAgdmFyIGNsZWFyQXZhcnRhQnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtbGlnaHQtZ3JheSB3My1ob3Zlci1waW5rIHczLWJvcmRlci1yaWdodFwiPkNsZWFyIEF2YXJ0YTwvYnV0dG9uPicpXHJcbiAgICB0aGlzLm1vZGVsQnV0dG9uQmFyLmFwcGVuZChpbXBvcnRQaWNCdG4sIGFjdHVhbEltcG9ydFBpY0J0bixjaG9vc2VBdmFydGFCdG4sIGNsZWFyQXZhcnRhQnRuKVxyXG4gICAgaW1wb3J0UGljQnRuLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgIGFjdHVhbEltcG9ydFBpY0J0bi50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWN0dWFsSW1wb3J0UGljQnRuLmNoYW5nZShhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgdmFyIGZpbGVzID0gZXZ0LnRhcmdldC5maWxlczsgLy8gRmlsZUxpc3Qgb2JqZWN0XHJcbiAgICAgICAgdmFyIHRoZUZpbGUgPSBmaWxlc1swXVxyXG5cclxuICAgICAgICBpZiAodGhlRmlsZS50eXBlID09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBhd2FpdCB0aGlzLnJlYWRPbmVGaWxlKHRoZUZpbGUpXHJcbiAgICAgICAgICAgIHZhciBkYXRhVXJsID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCcgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoZUZpbGUudHlwZS5tYXRjaCgnaW1hZ2UuKicpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhVXJsID0gYXdhaXQgdGhpcy5yZXNpemVJbWdGaWxlKHRoZUZpbGUsIDI1NilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY29uZmlybURpYWxvZ0RpdiA9IG5ldyBzaW1wbGVDb25maXJtRGlhbG9nKClcclxuICAgICAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5zaG93KHsgd2lkdGg6IFwiMjAwcHhcIiB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIk5vdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICwgY29udGVudDogXCJQbGVhc2UgaW1wb3J0IGltYWdlIGZpbGUgKHBuZyxqcGcsc3ZnIGFuZCBzbyBvbilcIlxyXG4gICAgICAgICAgICAgICAgICAgICwgYnV0dG9uczogW3sgY29sb3JDbGFzczogXCJ3My1ncmF5XCIsIHRleHQ6IFwiT2tcIiwgXCJjbGlja0Z1bmNcIjogKCkgPT4geyBjb25maXJtRGlhbG9nRGl2LmNsb3NlKCkgfSB9XVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQXZhcnRhRGF0YVVybChkYXRhVXJsLG1vZGVsSUQpXHJcbiAgICAgICAgYWN0dWFsSW1wb3J0UGljQnRuLnZhbChcIlwiKVxyXG4gICAgfSlcclxuXHJcbiAgICBjaG9vc2VBdmFydGFCdG4ub24oXCJjbGlja1wiLCgpPT57dGhpcy5jaG9vc2VBdmFydGEobW9kZWxJRCl9KVxyXG5cclxuICAgIGNsZWFyQXZhcnRhQnRuLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXZhcnRhRGF0YVVybChudWxsLG1vZGVsSUQpXHJcbiAgICB9KTtcclxuXHJcbiAgICBcclxuICAgIGRlbEJ0bi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICB2YXIgcmVsYXRlZE1vZGVsSURzID1tb2RlbEFuYWx5emVyLmxpc3RNb2RlbHNGb3JEZWxldGVNb2RlbChtb2RlbElEKVxyXG4gICAgICAgIHZhciBkaWFsb2dTdHI9KHJlbGF0ZWRNb2RlbElEcy5sZW5ndGg9PTApPyAoXCJUaGlzIHdpbGwgREVMRVRFIG1vZGVsIFxcXCJcIiArIG1vZGVsSUQgKyBcIlxcXCIuXCIpOiBcclxuICAgICAgICAgICAgKG1vZGVsSUQgKyBcIiBpcyBiYXNlIG1vZGVsIG9mIFwiK3JlbGF0ZWRNb2RlbElEcy5qb2luKFwiLCBcIikrXCIuXCIpXHJcbiAgICAgICAgdmFyIGNvbmZpcm1EaWFsb2dEaXYgPSBuZXcgc2ltcGxlQ29uZmlybURpYWxvZygpXHJcblxyXG4gICAgICAgIC8vY2hlY2sgaG93IG1hbnkgdHdpbnMgYXJlIHVuZGVyIHRoaXMgbW9kZWwgSURcclxuICAgICAgICB2YXIgbnVtYmVyT2ZUd2lucz0wXHJcbiAgICAgICAgdmFyIGNoZWNrVHdpbnNNb2RlbEFycj1bbW9kZWxJRF0uY29uY2F0KHJlbGF0ZWRNb2RlbElEcylcclxuICAgICAgICBmb3IodmFyIG9uZVR3aW5JRCBpbiBnbG9iYWxDYWNoZS5EQlR3aW5zKXtcclxuICAgICAgICAgICAgdmFyIG9uZURCVHdpbiA9IGdsb2JhbENhY2hlLkRCVHdpbnNbb25lVHdpbklEXVxyXG4gICAgICAgICAgICB2YXIgdGhlSW5kZXg9Y2hlY2tUd2luc01vZGVsQXJyLmluZGV4T2Yob25lREJUd2luW1wibW9kZWxJRFwiXSlcclxuICAgICAgICAgICAgaWYodGhlSW5kZXghPS0xKSBudW1iZXJPZlR3aW5zKytcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpYWxvZ1N0cis9XCIgKFRoZXJlIHdpbGwgYmUgXCIrKChudW1iZXJPZlR3aW5zPjEpPyhudW1iZXJPZlR3aW5zK1wiIHR3aW5zXCIpOihudW1iZXJPZlR3aW5zK1wiIHR3aW5cIikgKSArIFwiIGJlaW5nIGltcGFjdGVkKVwiXHJcbiAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5zaG93KFxyXG4gICAgICAgICAgICB7IHdpZHRoOiBcIjM1MHB4XCIgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiV2FybmluZ1wiXHJcbiAgICAgICAgICAgICAgICAsIGNvbnRlbnQ6IGRpYWxvZ1N0clxyXG4gICAgICAgICAgICAgICAgLCBidXR0b25zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLXJlZCB3My1ob3Zlci1waW5rXCIsIHRleHQ6IFwiQ29uZmlybVwiLCBcImNsaWNrRnVuY1wiOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1EZWxldGVNb2RlbChtb2RlbElEKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNsYXNzOiBcInczLWdyYXlcIiwgdGV4dDogXCJDYW5jZWxcIiwgXCJjbGlja0Z1bmNcIjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybURpYWxvZ0Rpdi5jbG9zZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICB2YXIgVmlzdWFsaXphdGlvbkRPTT10aGlzLmFkZEFQYXJ0SW5SaWdodFNwYW4oXCJWaXN1YWxpemF0aW9uXCIse1wibWFyZ2luVG9wXCI6MH0pIFxyXG4gICAgdmFyIGVkaXRhYmxlUHJvcGVydGllc0RPTT10aGlzLmFkZEFQYXJ0SW5SaWdodFNwYW4oXCJFZGl0YWJsZSBQcm9wZXJ0aWVzIEFuZCBSZWxhdGlvbnNoaXBzXCIpXHJcbiAgICB2YXIgYmFzZUNsYXNzZXNET009dGhpcy5hZGRBUGFydEluUmlnaHRTcGFuKFwiQmFzZSBDbGFzc2VzXCIpXHJcbiAgICB2YXIgb3JpZ2luYWxEZWZpbml0aW9uRE9NPXRoaXMuYWRkQVBhcnRJblJpZ2h0U3BhbihcIk9yaWdpbmFsIERlZmluaXRpb25cIilcclxuXHJcbiAgICB2YXIgc3RyPUpTT04uc3RyaW5naWZ5KEpTT04ucGFyc2UobW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdW1wib3JpZ2luYWxcIl0pLG51bGwsMilcclxuICAgIG9yaWdpbmFsRGVmaW5pdGlvbkRPTS5hcHBlbmQoJCgnPHByZSBpZD1cImpzb25cIj4nK3N0cisnPC9wcmU+JykpXHJcblxyXG4gICAgdmFyIGVkaXR0YWJsZVByb3BlcnRpZXM9bW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdLmVkaXRhYmxlUHJvcGVydGllc1xyXG4gICAgdGhpcy5maWxsRWRpdGFibGVQcm9wZXJ0aWVzKGVkaXR0YWJsZVByb3BlcnRpZXMsZWRpdGFibGVQcm9wZXJ0aWVzRE9NKVxyXG4gICAgdmFyIHZhbGlkUmVsYXRpb25zaGlwcz1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF0udmFsaWRSZWxhdGlvbnNoaXBzXHJcbiAgICB0aGlzLmZpbGxSZWxhdGlvbnNoaXBJbmZvKHZhbGlkUmVsYXRpb25zaGlwcyxlZGl0YWJsZVByb3BlcnRpZXNET00pXHJcblxyXG4gICAgdGhpcy5maWxsVmlzdWFsaXphdGlvbihtb2RlbElELFZpc3VhbGl6YXRpb25ET00pXHJcblxyXG4gICAgdGhpcy5maWxsQmFzZUNsYXNzZXMobW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdLmFsbEJhc2VDbGFzc2VzLGJhc2VDbGFzc2VzRE9NKSBcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS51cGRhdGVBdmFydGFEYXRhVXJsID0gZnVuY3Rpb24gKGRhdGFVcmwsbW9kZWxJRCkge1xyXG4gICAgaWYgKCFkYXRhVXJsKXtcclxuICAgICAgICB2YXIgdmlzdWFsSnNvbiA9IGdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFxyXG4gICAgICAgIGlmICh2aXN1YWxKc29uW21vZGVsSURdKXtcclxuICAgICAgICAgICAgZGVsZXRlIHZpc3VhbEpzb25bbW9kZWxJRF0uYXZhcnRhXHJcbiAgICAgICAgICAgIGRlbGV0ZSB2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YVdpZHRoXHJcbiAgICAgICAgICAgIGRlbGV0ZSB2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YUhlaWdodFxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgaWYgKHRoaXMuYXZhcnRhSW1nKSB0aGlzLmF2YXJ0YUltZy5yZW1vdmVBdHRyKCdzcmMnKTtcclxuICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwibW9kZWxJRFwiOiBtb2RlbElELCBcIm5vQXZhcnRhXCI6IHRydWUgfSlcclxuICAgICAgICB0aGlzLnJlZnJlc2hNb2RlbFRyZWVMYWJlbCgpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSBcclxuICAgIFxyXG4gICAgLy9pZiBpdCBpcyBzdmcsIGNoZWNrIGlmIHRoZSBzdmcgc2V0IGl0cyB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZSwgYXMgY3l0b3NjYXBlIGpzIGNhbiBub3QgaGFuZGxlIHN2ZyBzY2FsaW5nIHdpdGhvdXRoIHdpZHRoIGFuZCBoZWlnaCBhdHRyaWJ1dGVcclxuICAgIHZhciBkZWM9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhVXJsKVxyXG4gICAgaWYoZGVjLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL3N2Zyt4bWxcIikpe1xyXG4gICAgICAgIHZhciBwb3M9ZGVjLmluZGV4T2YoXCI8c3ZnIFwiKVxyXG4gICAgICAgIHZhciBzdmdQYXJ0PWRlYy5zdWJzdHIocG9zKVxyXG4gICAgICAgIHZhciB0bXBPYmo9JChzdmdQYXJ0KVxyXG4gICAgICAgIGlmKHRtcE9iai5hdHRyKCd3aWR0aCcpPT1udWxsKXtcclxuICAgICAgICAgICAgdmFyIHNzPXRtcE9iai5hdHRyKCd2aWV3Qm94JylcclxuICAgICAgICAgICAgaWYoc3Mpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGFycj1zcy5zcGxpdChcIiBcIilcclxuICAgICAgICAgICAgICAgIHRtcE9iai5hdHRyKFwid2lkdGhcIixhcnJbMl0tYXJyWzBdKVxyXG4gICAgICAgICAgICAgICAgdG1wT2JqLmF0dHIoXCJoZWlnaHRcIixhcnJbM10tYXJyWzFdKVxyXG4gICAgICAgICAgICAgICAgZGF0YVVybD1gZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQodG1wT2JqWzBdLm91dGVySFRNTCl9YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmF2YXJ0YUltZykgdGhpcy5hdmFydGFJbWcuYXR0cihcInNyY1wiLCBkYXRhVXJsKVxyXG5cclxuICAgIHZhciB2aXN1YWxKc29uID0gZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsIC8vY3VycmVudGx5IHRoZXJlIGlzIG9ubHkgb25lIHZpc3VhbCBkZWZpbml0aW9uOiBcImRlZmF1bHRcIlxyXG4gICAgaWYgKCF2aXN1YWxKc29uW21vZGVsSURdKSB2aXN1YWxKc29uW21vZGVsSURdID0ge31cclxuICAgIHZpc3VhbEpzb25bbW9kZWxJRF0uYXZhcnRhID0gZGF0YVVybFxyXG4gICAgXHJcbiAgICB2YXIgdGVzdEltZyA9ICQoYDxpbWcgc3JjPVwiJHtkYXRhVXJsfVwiLz5gKVxyXG4gICAgdGVzdEltZy5vbignbG9hZCcsICgpPT57XHJcbiAgICAgICAgdGVzdEltZy5jc3Moe1wiZGlzcGxheVwiOlwibm9uZVwifSkgLy90byBnZXQgdGhlIGltYWdlIHNpemUsIGFwcGVuZCBpdCB0byBib2R5IHRlbXBvcmFyaWx5XHJcbiAgICAgICAgJCgnYm9keScpLmFwcGVuZCh0ZXN0SW1nKVxyXG4gICAgICAgIHZpc3VhbEpzb25bbW9kZWxJRF0uYXZhcnRhV2lkdGg9dGVzdEltZy53aWR0aCgpXHJcbiAgICAgICAgdmlzdWFsSnNvblttb2RlbElEXS5hdmFydGFIZWlnaHQ9dGVzdEltZy5oZWlnaHQoKVxyXG4gICAgICAgIHRlc3RJbWcucmVtb3ZlKClcclxuICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwibW9kZWxJRFwiOiBtb2RlbElELCBcImF2YXJ0YVwiOiBkYXRhVXJsIH0pXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoTW9kZWxUcmVlTGFiZWwoKVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuY2hvb3NlQXZhcnRhPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgdmFyIHBvcFdpbmRvdz1uZXcgc2ltcGxlQ29uZmlybURpYWxvZygpXHJcbiAgICBwb3BXaW5kb3cuc2hvdyh7XCJtYXgtd2lkdGhcIjpcIjQ1MHB4XCIsXCJtaW4td2lkdGhcIjpcIjMwMHB4XCJ9LHtcclxuICAgICAgICBcInRpdGxlXCI6IFwiQ2hvb3NlIFN5bWJvbCBhcyBBdmFydGEgKGJlc3Qgd2l0aCByZWN0YW5nbGUgc2hhcGUgKVwiLFxyXG4gICAgICAgIFwiY3VzdG9tRHJhd2luZ1wiOiAocGFyZW50RE9NKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciByb3cxPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cInBhZGRpbmc6MnB4XCI+PC9kaXY+JylcclxuICAgICAgICAgICAgcGFyZW50RE9NLmFwcGVuZChyb3cxKVxyXG4gICAgICAgICAgICB2YXIgbGFibGUgPSAkKCc8ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtb3BhY2l0eVwiIHN0eWxlPVwicGFkZGluZy1yaWdodDo1cHg7XCI+SWNvbiBTZXQgPC9kaXY+JylcclxuICAgICAgICAgICAgcm93MS5hcHBlbmQobGFibGUpXHJcbiAgICAgICAgICAgIHZhciBpY29uU2V0U2VsZWN0b3IgPSBuZXcgc2ltcGxlU2VsZWN0TWVudShcIiBcIiwgeyB3aXRoQm9yZGVyOiAxLCBjb2xvckNsYXNzOiBcInczLWxpZ2h0LWdyYXlcIiwgYnV0dG9uQ1NTOiB7IFwicGFkZGluZ1wiOiBcIjVweCAxMHB4XCIgfSB9KVxyXG4gICAgICAgICAgICByb3cxLmFwcGVuZChpY29uU2V0U2VsZWN0b3IuRE9NKVxyXG4gICAgICAgICAgICB0aGlzLmljb25zSG9sZGVyRGl2PSQoXCI8ZGl2Lz5cIilcclxuICAgICAgICAgICAgcGFyZW50RE9NLmFwcGVuZCh0aGlzLmljb25zSG9sZGVyRGl2KVxyXG4gICAgICAgICAgICBpY29uU2V0U2VsZWN0b3IuY2FsbEJhY2tfY2xpY2tPcHRpb24gPSAob3B0aW9uVGV4dCwgb3B0aW9uVmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGljb25TZXRTZWxlY3Rvci5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25zSG9sZGVyRGl2LmVtcHR5KClcclxuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xMaXN0PWdsb2JhbENhY2hlLnN5bWJvbExpYnNbb3B0aW9uVGV4dF1cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgc3ltYm9sTmFtZSBpbiBzeW1ib2xMaXN0KXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN5bWJvbERPTShvcHRpb25UZXh0LHN5bWJvbE5hbWUsbW9kZWxJRCx0aGlzLmljb25zSG9sZGVyRGl2LHBvcFdpbmRvdylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmQgaW4gZ2xvYmFsQ2FjaGUuc3ltYm9sTGlicykgaWNvblNldFNlbGVjdG9yLmFkZE9wdGlvbihpbmQpXHJcbiAgICAgICAgICAgIGljb25TZXRTZWxlY3Rvci50cmlnZ2VyT3B0aW9uSW5kZXgoMClcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmNyZWF0ZVN5bWJvbERPTT1mdW5jdGlvbihsaWJOYW1lLHN5bWJvbE5hbWUsbW9kZWxJRCxwYXJlbnRET00scG9wV2luZG93KXtcclxuICAgIHZhciBzeW1ib2xTaXplPTgwXHJcbiAgICB2YXIgc3ltYm9sTGlzdD1nbG9iYWxDYWNoZS5zeW1ib2xMaWJzW2xpYk5hbWVdXHJcbiAgICB2YXIgYVN5bWJvbERPTT0kKFwiPGRpdiBjbGFzcz0ndzMtYnV0dG9uIHczLXdoaXRlJyBzdHlsZT0ncGFkZGluZzowcHg7d2lkdGg6XCIrc3ltYm9sU2l6ZStcInB4O2hlaWdodDpcIitzeW1ib2xTaXplK1wicHg7ZmxvYXQ6bGVmdCc+PC9kaXY+XCIpXHJcbiAgICB2YXIgc3ZnU3RyPXN5bWJvbExpc3Rbc3ltYm9sTmFtZV0ucmVwbGFjZUFsbChcIidcIiwnXCInKVxyXG4gICAgdmFyIGRhdGFVcmw9YGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCR7ZW5jb2RlVVJJQ29tcG9uZW50KHN2Z1N0cil9YFxyXG4gICAgdmFyIHN2Z0ltZz0kKGA8aW1nIHN0eWxlPSdtYXgtd2lkdGg6JHtzeW1ib2xTaXplfXB4O21heC1oZWlnaHQ6JHtzeW1ib2xTaXplfXB4JyBzcmM9JyR7ZGF0YVVybH0nPjwvaW1nPmApXHJcbiAgICBhU3ltYm9sRE9NLmFwcGVuZChzdmdJbWcpXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKGFTeW1ib2xET00pXHJcbiAgICBhU3ltYm9sRE9NLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHBvcFdpbmRvdy5jbG9zZSgpXHJcbiAgICAgICAgdGhpcy51cGRhdGVBdmFydGFEYXRhVXJsKGRhdGFVcmwsbW9kZWxJRClcclxuICAgIH0pXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuY29uZmlybURlbGV0ZU1vZGVsPWZ1bmN0aW9uKG1vZGVsSUQpe1xyXG4gICAgdmFyIGZ1bmNBZnRlckVhY2hTdWNjZXNzRGVsZXRlID0gKGVhY2hEZWxldGVkTW9kZWxJRCkgPT4ge1xyXG4gICAgICAgIHRoaXMudHJlZS5kZWxldGVMZWFmTm9kZShnbG9iYWxDYWNoZS5tb2RlbElETWFwVG9OYW1lW2VhY2hEZWxldGVkTW9kZWxJRF0pXHJcbiAgICAgICAgLy9UT0RPOiBjbGVhciB0aGUgdmlzdWFsaXphdGlvbiBzZXR0aW5nIG9mIHRoaXMgZGVsZXRlZCBtb2RlbCwgYnV0IGlmIGl0IGlzIHJlcGxhY2UsIHNob3VsZCBub3QsIHNvIEkgY29tbWVudCBvdXQgZmlyc3RcclxuICAgICAgICAvKlxyXG4gICAgICAgIGlmIChnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxbbW9kZWxJRF0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIGdsb2JhbENhY2hlLnZpc3VhbERlZmluaXRpb25bXCJkZWZhdWx0XCJdLmRldGFpbFttb2RlbElEXVxyXG4gICAgICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxuICAgIHZhciBjb21wbGV0ZUZ1bmM9KCk9PnsgXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiQURUTW9kZWxzQ2hhbmdlXCJ9KVxyXG4gICAgICAgIHRoaXMucGFuZWxDYXJkLmVtcHR5KClcclxuICAgIH1cclxuXHJcbiAgICAvL2V2ZW4gbm90IGNvbXBsZXRlbHkgc3VjY2Vzc2Z1bCBkZWxldGluZywgaXQgd2lsbCBzdGlsbCBpbnZva2UgY29tcGxldGVGdW5jXHJcbiAgICBtb2RlbEFuYWx5emVyLmRlbGV0ZU1vZGVsKG1vZGVsSUQsZnVuY0FmdGVyRWFjaFN1Y2Nlc3NEZWxldGUsY29tcGxldGVGdW5jLGNvbXBsZXRlRnVuYylcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5yZWZyZXNoTW9kZWxUcmVlTGFiZWw9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMudHJlZS5zZWxlY3RlZE5vZGVzLmxlbmd0aD4wKSB0aGlzLnRyZWUuc2VsZWN0ZWROb2Rlc1swXS5yZWRyYXdMYWJlbCgpXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuZmlsbEJhc2VDbGFzc2VzPWZ1bmN0aW9uKGJhc2VDbGFzc2VzLHBhcmVudERvbSl7XHJcbiAgICBmb3IodmFyIGluZCBpbiBiYXNlQ2xhc3Nlcyl7XHJcbiAgICAgICAgdmFyIGtleURpdj0gJChcIjxsYWJlbCBzdHlsZT0nZGlzcGxheTpibG9jaztwYWRkaW5nOi4xZW0nPlwiK2luZCtcIjwvbGFiZWw+XCIpXHJcbiAgICAgICAgcGFyZW50RG9tLmFwcGVuZChrZXlEaXYpXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuZmlsbFZpc3VhbGl6YXRpb249ZnVuY3Rpb24obW9kZWxJRCxwYXJlbnREb20pe1xyXG4gICAgdmFyIG1vZGVsSnNvbj1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF07XHJcbiAgICB2YXIgYVRhYmxlPSQoXCI8dGFibGUgc3R5bGU9J3dpZHRoOjEwMCUnPjwvdGFibGU+XCIpXHJcbiAgICBhVGFibGUuaHRtbCgnPHRyPjx0ZD48L3RkPjx0ZCBhbGlnbj1cImNlbnRlclwiPjwvdGQ+PC90cj4nKVxyXG4gICAgcGFyZW50RG9tLmFwcGVuZChhVGFibGUpIFxyXG5cclxuICAgIHZhciBsZWZ0UGFydD1hVGFibGUuZmluZChcInRkOmZpcnN0XCIpXHJcbiAgICB2YXIgcmlnaHRQYXJ0PWFUYWJsZS5maW5kKFwidGQ6bnRoLWNoaWxkKDIpXCIpXHJcbiAgICB2YXIgb3V0ZXJESVY9JChcIjxkaXYgY2xhc3M9J3czLWJvcmRlcicgc3R5bGU9J3dpZHRoOjU1cHg7aGVpZ2h0OjU1cHg7cGFkZGluZzo1cHgnPjwvZGl2PlwiKVxyXG4gICAgdmFyIGF2YXJ0YUltZz0kKFwiPGltZyBzdHlsZT0naGVpZ2h0OjQ1cHgnPjwvaW1nPlwiKVxyXG4gICAgcmlnaHRQYXJ0LmFwcGVuZChvdXRlckRJVilcclxuICAgIG91dGVyRElWLmFwcGVuZChhdmFydGFJbWcpXHJcbiAgICB2YXIgdmlzdWFsSnNvbj1nbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxcclxuICAgIGlmKHZpc3VhbEpzb24gJiYgdmlzdWFsSnNvblttb2RlbElEXSAmJiB2aXN1YWxKc29uW21vZGVsSURdLmF2YXJ0YSkgYXZhcnRhSW1nLmF0dHIoJ3NyYycsdmlzdWFsSnNvblttb2RlbElEXS5hdmFydGEpXHJcbiAgICB0aGlzLmF2YXJ0YUltZz1hdmFydGFJbWc7XHJcbiAgICB0aGlzLmFkZE9uZVZpc3VhbGl6YXRpb25Sb3cobW9kZWxJRCxsZWZ0UGFydClcclxuXHJcbiAgICBpZih0aGlzLnNob3dSZWxhdGlvblZpc3VhbGl6YXRpb25TZXR0aW5ncyl7XHJcbiAgICAgICAgZm9yKHZhciBpbmQgaW4gbW9kZWxKc29uLnZhbGlkUmVsYXRpb25zaGlwcyl7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT25lVmlzdWFsaXphdGlvblJvdyhtb2RlbElELGxlZnRQYXJ0LGluZClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZExhYmVsVmlzdWFsaXphdGlvblJvdyhtb2RlbElELGxlZnRQYXJ0KVxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmFkZExhYmVsVmlzdWFsaXphdGlvblJvdz1mdW5jdGlvbihtb2RlbElELHBhcmVudERvbSl7XHJcbiAgICB2YXIgY29udGFpbmVyRGl2PSQoXCI8ZGl2IHN0eWxlPSdwYWRkaW5nLWJvdHRvbTo4cHgnPjwvZGl2PlwiKVxyXG4gICAgcGFyZW50RG9tLmFwcGVuZChjb250YWluZXJEaXYpXHJcbiAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsIGNsYXNzPSd3My10ZXh0LWdyYXknIHN0eWxlPSdtYXJnaW4tcmlnaHQ6MTBweDtmb250LXN0eWxlOml0YWxpYzsgZm9udC13ZWlnaHQ6Ym9sZDtmb250LXNpemU6MC45ZW0nPlBvc2l0aW9uIExhYmVsPC9sYWJlbD5cIilcclxuICAgIGNvbnRhaW5lckRpdi5hcHBlbmQoY29udGVudERPTSlcclxuICAgIHZhciBkZWZpbmVkTGJsWD0wXHJcbiAgICB2YXIgZGVmaW5lZExibFk9MFxyXG4gICAgdmFyIHZpc3VhbEpzb249Z2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsXHJcbiAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0ubGFiZWxYKSBkZWZpbmVkTGJsWD12aXN1YWxKc29uW21vZGVsSURdLmxhYmVsWFxyXG4gICAgaWYodmlzdWFsSnNvblttb2RlbElEXSAmJiB2aXN1YWxKc29uW21vZGVsSURdLmxhYmVsWSkgZGVmaW5lZExibFk9dmlzdWFsSnNvblttb2RlbElEXS5sYWJlbFlcclxuICAgIHZhciBsYmxYQWRqdXN0U2VsZWN0b3IgPSAkKCc8c2VsZWN0IGNsYXNzPVwidzMtYm9yZGVyXCIgc3R5bGU9XCJvdXRsaW5lOm5vbmU7d2lkdGg6MTEwcHhcIj48L3NlbGVjdD4nKVxyXG4gICAgZm9yKHZhciBmPS0yNTtmPD0zMDtmKz01KXtcclxuICAgICAgICB2YXIgdmFsPWYudG9GaXhlZCgwKStcIlwiXHJcbiAgICAgICAgbGJsWEFkanVzdFNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT1cIit2YWwrXCI+eG9mZjpcIit2YWwrXCI8L29wdGlvbj5cIikpXHJcbiAgICB9XHJcbiAgICBpZihkZWZpbmVkTGJsWCE9bnVsbCkgbGJsWEFkanVzdFNlbGVjdG9yLnZhbChkZWZpbmVkTGJsWClcclxuICAgIGVsc2UgbGJsWEFkanVzdFNlbGVjdG9yLnZhbChcIjBcIilcclxuICAgIGNvbnRhaW5lckRpdi5hcHBlbmQobGJsWEFkanVzdFNlbGVjdG9yKVxyXG4gICAgdmFyIGxibFlBZGp1c3RTZWxlY3RvciA9ICQoJzxzZWxlY3QgY2xhc3M9XCJ3My1ib3JkZXJcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTt3aWR0aDoxMTBweFwiPjwvc2VsZWN0PicpXHJcbiAgICBmb3IodmFyIGY9MDtmPDMwO2YrPTUpe1xyXG4gICAgICAgIHZhciB2YWw9Zi50b0ZpeGVkKDApK1wiXCJcclxuICAgICAgICBsYmxZQWRqdXN0U2VsZWN0b3IuYXBwZW5kKCQoXCI8b3B0aW9uIHZhbHVlPVwiK3ZhbCtcIj55b2ZmOlwiK3ZhbCtcIjwvb3B0aW9uPlwiKSlcclxuICAgIH1cclxuICAgIGZvcih2YXIgZj0zMDtmPD05MDtmKz0xMCl7XHJcbiAgICAgICAgdmFyIHZhbD1mLnRvRml4ZWQoMCkrXCJcIlxyXG4gICAgICAgIGxibFlBZGp1c3RTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9XCIrdmFsK1wiPnlvZmY6XCIrdmFsK1wiPC9vcHRpb24+XCIpKVxyXG4gICAgfVxyXG4gICAgaWYoZGVmaW5lZExibFkhPW51bGwpIGxibFlBZGp1c3RTZWxlY3Rvci52YWwoZGVmaW5lZExibFkpXHJcbiAgICBlbHNlIGxibFlBZGp1c3RTZWxlY3Rvci52YWwoXCIwXCIpXHJcbiAgICBjb250YWluZXJEaXYuYXBwZW5kKGxibFlBZGp1c3RTZWxlY3RvcilcclxuXHJcbiAgICBsYmxYQWRqdXN0U2VsZWN0b3IuY2hhbmdlKChldmUpPT57XHJcbiAgICAgICAgdmFyIGNob29zZVZhbD1ldmUudGFyZ2V0LnZhbHVlXHJcbiAgICAgICAgdGhpcy5tb2RpZnlMYmxPZmZzZXQoXCJsYWJlbFhcIixjaG9vc2VWYWwsbW9kZWxJRClcclxuICAgIH0pXHJcbiAgICBsYmxZQWRqdXN0U2VsZWN0b3IuY2hhbmdlKChldmUpPT57XHJcbiAgICAgICAgdmFyIGNob29zZVZhbD1ldmUudGFyZ2V0LnZhbHVlXHJcbiAgICAgICAgdGhpcy5tb2RpZnlMYmxPZmZzZXQoXCJsYWJlbFlcIixjaG9vc2VWYWwsbW9kZWxJRClcclxuICAgIH0pXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUubW9kaWZ5TGJsT2Zmc2V0ID0gZnVuY3Rpb24gKFhZLCB2YWwsbW9kZWxJRCkge1xyXG4gICAgdmFyIHZpc3VhbEpzb24gPSBnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxcclxuICAgIGlmICghdmlzdWFsSnNvblttb2RlbElEXSkgdmlzdWFsSnNvblttb2RlbElEXSA9IHt9XHJcbiAgICB2aXN1YWxKc29uW21vZGVsSURdW1hZXSA9IHZhbFxyXG4gICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwidmlzdWFsRGVmaW5pdGlvbkNoYW5nZVwiLCBcIm1vZGVsSURcIjogbW9kZWxJRCwgXCJsYWJlbFBvc2l0aW9uXCI6dHJ1ZSB9KVxyXG4gICAgdGhpcy5zYXZlVmlzdWFsRGVmaW5pdGlvbigpXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuYWRkT25lVmlzdWFsaXphdGlvblJvdz1mdW5jdGlvbihtb2RlbElELHBhcmVudERvbSxyZWxhdGluc2hpcE5hbWUpe1xyXG4gICAgaWYocmVsYXRpbnNoaXBOYW1lPT1udWxsKSB2YXIgbmFtZVN0cj1cIuKXr1wiIC8vdmlzdWFsIGZvciBub2RlXHJcbiAgICBlbHNlIG5hbWVTdHI9XCLin5wgXCIrcmVsYXRpbnNoaXBOYW1lXHJcbiAgICB2YXIgY29udGFpbmVyRGl2PSQoXCI8ZGl2IHN0eWxlPSdwYWRkaW5nLWJvdHRvbTo4cHgnPjwvZGl2PlwiKVxyXG4gICAgcGFyZW50RG9tLmFwcGVuZChjb250YWluZXJEaXYpXHJcbiAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsIGNsYXNzPSd3My10ZXh0LWdyYXknIHN0eWxlPSdtYXJnaW4tcmlnaHQ6MTBweDtmb250LXdlaWdodDpib2xkO2ZvbnQtc2l6ZTowLjllbSc+XCIrbmFtZVN0citcIjwvbGFiZWw+XCIpXHJcbiAgICBjb250YWluZXJEaXYuYXBwZW5kKGNvbnRlbnRET00pXHJcblxyXG4gICAgdmFyIGRlZmluZWRDb2xvcj1udWxsXHJcbiAgICB2YXIgZGVmaW5lZENvbG9yMj1udWxsXHJcbiAgICB2YXIgZGVmaW5lZFNoYXBlPW51bGxcclxuICAgIHZhciBkZWZpbmVkRGltZW5zaW9uUmF0aW89bnVsbFxyXG4gICAgdmFyIGRlZmluZWRFZGdlV2lkdGg9bnVsbFxyXG4gICAgdmFyIHZpc3VhbEpzb249Z2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsXHJcbiAgICBpZihyZWxhdGluc2hpcE5hbWU9PW51bGwpe1xyXG4gICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0gJiYgdmlzdWFsSnNvblttb2RlbElEXS5jb2xvcikgZGVmaW5lZENvbG9yPXZpc3VhbEpzb25bbW9kZWxJRF0uY29sb3JcclxuICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0uc2Vjb25kQ29sb3IpIGRlZmluZWRDb2xvcjI9dmlzdWFsSnNvblttb2RlbElEXS5zZWNvbmRDb2xvclxyXG4gICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF0gJiYgdmlzdWFsSnNvblttb2RlbElEXS5zaGFwZSkgZGVmaW5lZFNoYXBlPXZpc3VhbEpzb25bbW9kZWxJRF0uc2hhcGVcclxuICAgICAgICBpZih2aXN1YWxKc29uW21vZGVsSURdICYmIHZpc3VhbEpzb25bbW9kZWxJRF0uZGltZW5zaW9uUmF0aW8pIGRlZmluZWREaW1lbnNpb25SYXRpbz12aXN1YWxKc29uW21vZGVsSURdLmRpbWVuc2lvblJhdGlvXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBpZiAodmlzdWFsSnNvblttb2RlbElEXSAmJiB2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXSAmJiB2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdKSB7XHJcbiAgICAgICAgICAgIGlmICh2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdLmNvbG9yKSBkZWZpbmVkQ29sb3IgPSB2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdLmNvbG9yXHJcbiAgICAgICAgICAgIGlmICh2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdLnNoYXBlKSBkZWZpbmVkU2hhcGUgPSB2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXVtyZWxhdGluc2hpcE5hbWVdLnNoYXBlXHJcbiAgICAgICAgICAgIGlmKHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0uZWRnZVdpZHRoKSBkZWZpbmVkRWRnZVdpZHRoPXZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0uZWRnZVdpZHRoXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjcmVhdGVBQ29sb3JTZWxlY3Rvcj0ocHJlZGVmaW5lZENvbG9yLG5hbWVPZkNvbG9yRmllbGQpPT57XHJcbiAgICAgICAgdmFyIGNvbG9yU2VsZWN0b3I9JCgnPHNlbGVjdCBjbGFzcz1cInczLWJvcmRlclwiIHN0eWxlPVwib3V0bGluZTpub25lO3dpZHRoOjc1cHhcIj48L3NlbGVjdD4nKVxyXG4gICAgICAgIGNvbnRhaW5lckRpdi5hcHBlbmQoY29sb3JTZWxlY3RvcilcclxuXHJcbiAgICAgICAgdmFyIGNvbG9yQXJyPVtcImRhcmtHcmF5XCIsXCJCbGFja1wiLFwiTGlnaHRHcmF5XCIsXCJSZWRcIixcIkdyZWVuXCIsXCJCbHVlXCIsXCJCaXNxdWVcIixcIkJyb3duXCIsXCJDb3JhbFwiLFwiQ3JpbXNvblwiLFwiRG9kZ2VyQmx1ZVwiLFwiR29sZFwiXVxyXG4gICAgICAgIGNvbG9yQXJyLmZvckVhY2goKG9uZUNvbG9yQ29kZSk9PntcclxuICAgICAgICAgICAgdmFyIGFuT3B0aW9uPSQoXCI8b3B0aW9uIHZhbHVlPSdcIitvbmVDb2xvckNvZGUrXCInPlwiK29uZUNvbG9yQ29kZStcIuKWpzwvb3B0aW9uPlwiKVxyXG4gICAgICAgICAgICBjb2xvclNlbGVjdG9yLmFwcGVuZChhbk9wdGlvbilcclxuICAgICAgICAgICAgYW5PcHRpb24uY3NzKFwiY29sb3JcIixvbmVDb2xvckNvZGUpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgaWYocmVsYXRpbnNoaXBOYW1lPT1udWxsKXtcclxuICAgICAgICAgICAgdmFyIGFuT3B0aW9uPSQoXCI8b3B0aW9uIHZhbHVlPSdub25lJz5ub25lPC9vcHRpb24+XCIpXHJcbiAgICAgICAgICAgIGFuT3B0aW9uLmNzcyhcImNvbG9yXCIsXCJkYXJrR3JheVwiKVxyXG4gICAgICAgICAgICBjb2xvclNlbGVjdG9yLmFwcGVuZChhbk9wdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG5hbWVPZkNvbG9yRmllbGQ9PVwic2Vjb25kQ29sb3JcIil7XHJcbiAgICAgICAgICAgIGlmKHByZWRlZmluZWRDb2xvcj09bnVsbCkgcHJlZGVmaW5lZENvbG9yPVwibm9uZVwiXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGlmKHByZWRlZmluZWRDb2xvcj09bnVsbCkgcHJlZGVmaW5lZENvbG9yPVwiZGFya0dyYXlcIlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29sb3JTZWxlY3Rvci52YWwocHJlZGVmaW5lZENvbG9yKVxyXG4gICAgICAgIGlmKHByZWRlZmluZWRDb2xvciE9XCJub25lXCIpIHtcclxuICAgICAgICAgICAgY29sb3JTZWxlY3Rvci5jc3MoXCJjb2xvclwiLHByZWRlZmluZWRDb2xvcilcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgY29sb3JTZWxlY3Rvci5jc3MoXCJjb2xvclwiLFwiZGFya0dyYXlcIilcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29sb3JTZWxlY3Rvci5jaGFuZ2UoKGV2ZSk9PntcclxuICAgICAgICAgICAgdmFyIHNlbGVjdENvbG9yQ29kZT1ldmUudGFyZ2V0LnZhbHVlXHJcbiAgICAgICAgICAgIGlmKHNlbGVjdENvbG9yQ29kZT09XCJub25lXCIpIGNvbG9yU2VsZWN0b3IuY3NzKFwiY29sb3JcIixcImRhcmtHcmF5XCIpXHJcbiAgICAgICAgICAgIGVsc2UgY29sb3JTZWxlY3Rvci5jc3MoXCJjb2xvclwiLHNlbGVjdENvbG9yQ29kZSlcclxuICAgICAgICAgICAgdmFyIHZpc3VhbEpzb249Z2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsXHJcbiAgICBcclxuICAgICAgICAgICAgaWYoIXZpc3VhbEpzb25bbW9kZWxJRF0pIHZpc3VhbEpzb25bbW9kZWxJRF09e31cclxuICAgICAgICAgICAgaWYoIXJlbGF0aW5zaGlwTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZWN0Q29sb3JDb2RlPT1cIm5vbmVcIiAmJiBuYW1lT2ZDb2xvckZpZWxkPT1cInNlY29uZENvbG9yXCIpIGRlbGV0ZSB2aXN1YWxKc29uW21vZGVsSURdW1wic2Vjb25kQ29sb3JcIl1cclxuICAgICAgICAgICAgICAgIGVsc2UgdmlzdWFsSnNvblttb2RlbElEXVtuYW1lT2ZDb2xvckZpZWxkXT1zZWxlY3RDb2xvckNvZGVcclxuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInZpc3VhbERlZmluaXRpb25DaGFuZ2VcIiwgXCJtb2RlbElEXCI6bW9kZWxJRFxyXG4gICAgICAgICAgICAgICAgICAgICxcImNvbG9yXCI6dmlzdWFsSnNvblttb2RlbElEXVtcImNvbG9yXCJdLFwic2Vjb25kQ29sb3JcIjp2aXN1YWxKc29uW21vZGVsSURdW1wic2Vjb25kQ29sb3JcIl0gfSlcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaE1vZGVsVHJlZUxhYmVsKClcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZighdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl0pIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdPXt9XHJcbiAgICAgICAgICAgICAgICBpZighdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXSkgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXT17fVxyXG4gICAgICAgICAgICAgICAgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXS5jb2xvcj1zZWxlY3RDb2xvckNvZGVcclxuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInZpc3VhbERlZmluaXRpb25DaGFuZ2VcIiwgXCJzcmNNb2RlbElEXCI6bW9kZWxJRCxcInJlbGF0aW9uc2hpcE5hbWVcIjpyZWxhdGluc2hpcE5hbWUsXCJjb2xvclwiOnNlbGVjdENvbG9yQ29kZSB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZVZpc3VhbERlZmluaXRpb24oKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQUNvbG9yU2VsZWN0b3IoZGVmaW5lZENvbG9yLFwiY29sb3JcIilcclxuICAgIGlmKHJlbGF0aW5zaGlwTmFtZT09bnVsbCkgY3JlYXRlQUNvbG9yU2VsZWN0b3IoZGVmaW5lZENvbG9yMixcInNlY29uZENvbG9yXCIpXHJcblxyXG5cclxuICAgIHZhciBzaGFwZVNlbGVjdG9yID0gJCgnPHNlbGVjdCBjbGFzcz1cInczLWJvcmRlclwiIHN0eWxlPVwib3V0bGluZTpub25lXCI+PC9zZWxlY3Q+JylcclxuICAgIGNvbnRhaW5lckRpdi5hcHBlbmQoc2hhcGVTZWxlY3RvcilcclxuICAgIGlmKHJlbGF0aW5zaGlwTmFtZT09bnVsbCl7XHJcbiAgICAgICAgc2hhcGVTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9J2VsbGlwc2UnPuKXrzwvb3B0aW9uPlwiKSlcclxuICAgICAgICBzaGFwZVNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT0ncmVjdGFuZ2xlJyBzdHlsZT0nZm9udC1zaXplOjEyMCUnPuKWojwvb3B0aW9uPlwiKSlcclxuICAgICAgICBzaGFwZVNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT0naGV4YWdvbicgc3R5bGU9J2ZvbnQtc2l6ZToxMzAlJz7irKE8L29wdGlvbj5cIikpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBzaGFwZVNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT0nc29saWQnPuKGkjwvb3B0aW9uPlwiKSlcclxuICAgICAgICBzaGFwZVNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT0nZG90dGVkJz7ih6I8L29wdGlvbj5cIikpXHJcbiAgICB9XHJcbiAgICBpZihkZWZpbmVkU2hhcGUhPW51bGwpIHtcclxuICAgICAgICBzaGFwZVNlbGVjdG9yLnZhbChkZWZpbmVkU2hhcGUpXHJcbiAgICB9XHJcbiAgICBzaGFwZVNlbGVjdG9yLmNoYW5nZSgoZXZlKT0+e1xyXG4gICAgICAgIHZhciBzZWxlY3RTaGFwZT1ldmUudGFyZ2V0LnZhbHVlXHJcbiAgICAgICAgdmFyIHZpc3VhbEpzb24gPSBnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxcclxuXHJcbiAgICAgICAgaWYoIXZpc3VhbEpzb25bbW9kZWxJRF0pIHZpc3VhbEpzb25bbW9kZWxJRF09e31cclxuICAgICAgICBpZighcmVsYXRpbnNoaXBOYW1lKSB7XHJcbiAgICAgICAgICAgIHZpc3VhbEpzb25bbW9kZWxJRF0uc2hhcGU9c2VsZWN0U2hhcGVcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwidmlzdWFsRGVmaW5pdGlvbkNoYW5nZVwiLCBcIm1vZGVsSURcIjptb2RlbElELFwic2hhcGVcIjpzZWxlY3RTaGFwZSB9KVxyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hNb2RlbFRyZWVMYWJlbCgpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGlmKCF2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXSkgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl09e31cclxuICAgICAgICAgICAgaWYoIXZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0pIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV09e31cclxuICAgICAgICAgICAgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXS5zaGFwZT1zZWxlY3RTaGFwZVxyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwic3JjTW9kZWxJRFwiOm1vZGVsSUQsXCJyZWxhdGlvbnNoaXBOYW1lXCI6cmVsYXRpbnNoaXBOYW1lLFwic2hhcGVcIjpzZWxlY3RTaGFwZSB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNhdmVWaXN1YWxEZWZpbml0aW9uKClcclxuICAgIH0pXHJcblxyXG4gICAgdmFyIHNpemVBZGp1c3RTZWxlY3RvciA9ICQoJzxzZWxlY3QgY2xhc3M9XCJ3My1ib3JkZXJcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTt3aWR0aDoxMTBweFwiPjwvc2VsZWN0PicpXHJcbiAgICBpZihyZWxhdGluc2hpcE5hbWU9PW51bGwpe1xyXG4gICAgICAgIGZvcih2YXIgZj0wLjI7Zjw9MjtmKz0wLjQpe1xyXG4gICAgICAgICAgICB2YXIgdmFsPWYudG9GaXhlZCgxKStcIlwiXHJcbiAgICAgICAgICAgIHNpemVBZGp1c3RTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9XCIrdmFsK1wiPmRpbWVuc2lvbipcIit2YWwrXCI8L29wdGlvbj5cIikpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgZj0yO2Y8PTEwO2YrPTEpe1xyXG4gICAgICAgICAgICB2YXIgdmFsPWYudG9GaXhlZCgxKStcIlwiXHJcbiAgICAgICAgICAgIHNpemVBZGp1c3RTZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24gdmFsdWU9XCIrdmFsK1wiPmRpbWVuc2lvbipcIit2YWwrXCI8L29wdGlvbj5cIikpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGRlZmluZWREaW1lbnNpb25SYXRpbyE9bnVsbCkgc2l6ZUFkanVzdFNlbGVjdG9yLnZhbChkZWZpbmVkRGltZW5zaW9uUmF0aW8pXHJcbiAgICAgICAgZWxzZSBzaXplQWRqdXN0U2VsZWN0b3IudmFsKFwiMS4wXCIpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBzaXplQWRqdXN0U2VsZWN0b3IuY3NzKFwid2lkdGhcIixcIjgwcHhcIilcclxuICAgICAgICBmb3IodmFyIGY9MC41O2Y8PTQ7Zis9MC41KXtcclxuICAgICAgICAgICAgdmFyIHZhbD1mLnRvRml4ZWQoMSkrXCJcIlxyXG4gICAgICAgICAgICBzaXplQWRqdXN0U2VsZWN0b3IuYXBwZW5kKCQoXCI8b3B0aW9uIHZhbHVlPVwiK3ZhbCtcIj53aWR0aCAqXCIrdmFsK1wiPC9vcHRpb24+XCIpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGY9NTtmPD0xMDtmKz0xKXsgXHJcbiAgICAgICAgICAgIHZhciB2YWw9Zi50b0ZpeGVkKDEpK1wiXCJcclxuICAgICAgICAgICAgc2l6ZUFkanVzdFNlbGVjdG9yLmFwcGVuZCgkKFwiPG9wdGlvbiB2YWx1ZT1cIit2YWwrXCI+d2lkdGggKlwiK3ZhbCtcIjwvb3B0aW9uPlwiKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZGVmaW5lZEVkZ2VXaWR0aCE9bnVsbCkgc2l6ZUFkanVzdFNlbGVjdG9yLnZhbChkZWZpbmVkRWRnZVdpZHRoKVxyXG4gICAgICAgIGVsc2Ugc2l6ZUFkanVzdFNlbGVjdG9yLnZhbChcIjIuMFwiKVxyXG4gICAgfVxyXG4gICAgY29udGFpbmVyRGl2LmFwcGVuZChzaXplQWRqdXN0U2VsZWN0b3IpXHJcblxyXG4gICAgXHJcbiAgICBzaXplQWRqdXN0U2VsZWN0b3IuY2hhbmdlKChldmUpPT57XHJcbiAgICAgICAgdmFyIGNob29zZVZhbD1ldmUudGFyZ2V0LnZhbHVlXHJcbiAgICAgICAgdmFyIHZpc3VhbEpzb24gPSBnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWxcclxuXHJcbiAgICAgICAgaWYoIXJlbGF0aW5zaGlwTmFtZSkge1xyXG4gICAgICAgICAgICBpZighdmlzdWFsSnNvblttb2RlbElEXSkgdmlzdWFsSnNvblttb2RlbElEXT17fVxyXG4gICAgICAgICAgICB2aXN1YWxKc29uW21vZGVsSURdLmRpbWVuc2lvblJhdGlvPWNob29zZVZhbFxyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJ2aXN1YWxEZWZpbml0aW9uQ2hhbmdlXCIsIFwibW9kZWxJRFwiOm1vZGVsSUQsXCJkaW1lbnNpb25SYXRpb1wiOmNob29zZVZhbCB9KVxyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hNb2RlbFRyZWVMYWJlbCgpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGlmKCF2aXN1YWxKc29uW21vZGVsSURdW1wicmVsc1wiXSkgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl09e31cclxuICAgICAgICAgICAgaWYoIXZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV0pIHZpc3VhbEpzb25bbW9kZWxJRF1bXCJyZWxzXCJdW3JlbGF0aW5zaGlwTmFtZV09e31cclxuICAgICAgICAgICAgdmlzdWFsSnNvblttb2RlbElEXVtcInJlbHNcIl1bcmVsYXRpbnNoaXBOYW1lXS5lZGdlV2lkdGg9Y2hvb3NlVmFsXHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInZpc3VhbERlZmluaXRpb25DaGFuZ2VcIiwgXCJzcmNNb2RlbElEXCI6bW9kZWxJRCxcInJlbGF0aW9uc2hpcE5hbWVcIjpyZWxhdGluc2hpcE5hbWUsXCJlZGdlV2lkdGhcIjpjaG9vc2VWYWwgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zYXZlVmlzdWFsRGVmaW5pdGlvbigpXHJcbiAgICB9KVxyXG4gICAgXHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuc2F2ZVZpc3VhbERlZmluaXRpb249YXN5bmMgZnVuY3Rpb24oKXtcclxuICAgIHRyeXtcclxuICAgICAgICBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9zYXZlVmlzdWFsRGVmaW5pdGlvblwiLCBcIlBPU1RcIiwge1widmlzdWFsRGVmaW5pdGlvbkpzb25cIjpKU09OLnN0cmluZ2lmeShnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5kZXRhaWwpfSxcIndpdGhQcm9qZWN0SURcIilcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgIH1cclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5maWxsUmVsYXRpb25zaGlwSW5mbz1mdW5jdGlvbih2YWxpZFJlbGF0aW9uc2hpcHMscGFyZW50RG9tKXtcclxuICAgIGZvcih2YXIgaW5kIGluIHZhbGlkUmVsYXRpb25zaGlwcyl7XHJcbiAgICAgICAgdmFyIGtleURpdj0gJChcIjxsYWJlbCBzdHlsZT0nZGlzcGxheTppbmxpbmU7cGFkZGluZzouMWVtIC4zZW0gLjFlbSAuM2VtO21hcmdpbi1yaWdodDouM2VtJz5cIitpbmQrXCI8L2xhYmVsPlwiKVxyXG4gICAgICAgIHBhcmVudERvbS5hcHBlbmQoa2V5RGl2KVxyXG4gICAgICAgIGtleURpdi5jc3MoXCJwYWRkaW5nLXRvcFwiLFwiLjFlbVwiKVxyXG4gICAgICAgIHZhciBsYWJlbD0kKFwiPGxhYmVsIGNsYXNzPSd3My1saW1lJyBzdHlsZT0nZGlzcGxheTppbmxpbmU7Zm9udC1zaXplOjlweDtwYWRkaW5nOjJweCc+PC9sYWJlbD5cIilcclxuICAgICAgICBsYWJlbC50ZXh0KFwiUmVsYXRpb25zaGlwXCIpXHJcbiAgICAgICAgcGFyZW50RG9tLmFwcGVuZChsYWJlbClcclxuICAgICAgICBpZih2YWxpZFJlbGF0aW9uc2hpcHNbaW5kXS50YXJnZXQpe1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwxPSQoXCI8bGFiZWwgY2xhc3M9J3czLWxpbWUnIHN0eWxlPSdkaXNwbGF5OmlubGluZTtmb250LXNpemU6OXB4O3BhZGRpbmc6MnB4O21hcmdpbi1sZWZ0OjJweCc+PC9sYWJlbD5cIilcclxuICAgICAgICAgICAgbGFiZWwxLnRleHQodmFsaWRSZWxhdGlvbnNoaXBzW2luZF0udGFyZ2V0KVxyXG4gICAgICAgICAgICBwYXJlbnREb20uYXBwZW5kKGxhYmVsMSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRlbnRET009JChcIjxsYWJlbD48L2xhYmVsPlwiKVxyXG4gICAgICAgIGNvbnRlbnRET00uY3NzKFwiZGlzcGxheVwiLFwiYmxvY2tcIilcclxuICAgICAgICBjb250ZW50RE9NLmNzcyhcInBhZGRpbmctbGVmdFwiLFwiMWVtXCIpXHJcbiAgICAgICAgcGFyZW50RG9tLmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgICAgIHRoaXMuZmlsbEVkaXRhYmxlUHJvcGVydGllcyh2YWxpZFJlbGF0aW9uc2hpcHNbaW5kXS5lZGl0YWJsZVJlbGF0aW9uc2hpcFByb3BlcnRpZXMsIGNvbnRlbnRET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZGVsTWFuYWdlckRpYWxvZy5wcm90b3R5cGUuZmlsbEVkaXRhYmxlUHJvcGVydGllcz1mdW5jdGlvbihqc29uSW5mbyxwYXJlbnREb20pe1xyXG4gICAgZm9yKHZhciBpbmQgaW4ganNvbkluZm8pe1xyXG4gICAgICAgIHZhciBrZXlEaXY9ICQoXCI8bGFiZWwgc3R5bGU9J2Rpc3BsYXk6YmxvY2snPjxsYWJlbCBzdHlsZT0nZGlzcGxheTppbmxpbmU7cGFkZGluZzouMWVtIC4zZW0gLjFlbSAuM2VtO21hcmdpbi1yaWdodDouM2VtJz5cIitpbmQrXCI8L2xhYmVsPjwvbGFiZWw+XCIpXHJcbiAgICAgICAgcGFyZW50RG9tLmFwcGVuZChrZXlEaXYpXHJcbiAgICAgICAga2V5RGl2LmNzcyhcInBhZGRpbmctdG9wXCIsXCIuMWVtXCIpXHJcblxyXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoanNvbkluZm9baW5kXSkpe1xyXG4gICAgICAgICAgICB2YXIgY29udGVudERPTT0kKFwiPGxhYmVsIGNsYXNzPSd3My1kYXJrLWdyYXknID48L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICBjb250ZW50RE9NLnRleHQoXCJlbnVtXCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHtcImZvbnRTaXplXCI6XCI5cHhcIixcInBhZGRpbmdcIjonMnB4J30pXHJcbiAgICAgICAgICAgIGtleURpdi5hcHBlbmQoY29udGVudERPTSlcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZUFycj1bXVxyXG4gICAgICAgICAgICBqc29uSW5mb1tpbmRdLmZvckVhY2goZWxlPT57dmFsdWVBcnIucHVzaChlbGUuZW51bVZhbHVlKX0pXHJcbiAgICAgICAgICAgIHZhciBsYWJlbDE9JChcIjxsYWJlbCBjbGFzcz0ndzMtZGFyay1ncmF5JyA+PC9sYWJlbD5cIilcclxuICAgICAgICAgICAgbGFiZWwxLmNzcyh7XCJmb250U2l6ZVwiOlwiOXB4XCIsXCJwYWRkaW5nXCI6JzJweCcsXCJtYXJnaW4tbGVmdFwiOlwiMnB4XCJ9KVxyXG4gICAgICAgICAgICBsYWJlbDEudGV4dCh2YWx1ZUFyci5qb2luKCkpXHJcbiAgICAgICAgICAgIGtleURpdi5hcHBlbmQobGFiZWwxKVxyXG4gICAgICAgIH1lbHNlIGlmKHR5cGVvZihqc29uSW5mb1tpbmRdKT09PVwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRET009JChcIjxsYWJlbD48L2xhYmVsPlwiKVxyXG4gICAgICAgICAgICBjb250ZW50RE9NLmNzcyhcImRpc3BsYXlcIixcImJsb2NrXCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKFwicGFkZGluZy1sZWZ0XCIsXCIxZW1cIilcclxuICAgICAgICAgICAgdGhpcy5maWxsRWRpdGFibGVQcm9wZXJ0aWVzKGpzb25JbmZvW2luZF0sY29udGVudERPTSlcclxuICAgICAgICAgICAga2V5RGl2LmFwcGVuZChjb250ZW50RE9NKVxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRET009JChcIjxsYWJlbCBjbGFzcz0ndzMtZGFyay1ncmF5JyA+PC9sYWJlbD5cIilcclxuICAgICAgICAgICAgY29udGVudERPTS50ZXh0KGpzb25JbmZvW2luZF0pXHJcbiAgICAgICAgICAgIGNvbnRlbnRET00uY3NzKHtcImZvbnRTaXplXCI6XCI5cHhcIixcInBhZGRpbmdcIjonMnB4J30pXHJcbiAgICAgICAgICAgIGtleURpdi5hcHBlbmQoY29udGVudERPTSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmFkZEFQYXJ0SW5SaWdodFNwYW49ZnVuY3Rpb24ocGFydE5hbWUsb3B0aW9ucyl7XHJcbiAgICBvcHRpb25zPW9wdGlvbnN8fHt9XHJcbiAgICB2YXIgc2VjdGlvbj0gbmV3IHNpbXBsZUV4cGFuZGFibGVTZWN0aW9uKHBhcnROYW1lLHRoaXMucGFuZWxDYXJkLG9wdGlvbnMpXHJcbiAgICBzZWN0aW9uLmV4cGFuZCgpXHJcbiAgICByZXR1cm4gc2VjdGlvbi5saXN0RE9NO1xyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLnJlYWRNb2RlbEZpbGVzQ29udGVudEFuZEltcG9ydD1hc3luYyBmdW5jdGlvbihmaWxlcyl7XHJcbiAgICAvLyBmaWxlcyBpcyBhIEZpbGVMaXN0IG9mIEZpbGUgb2JqZWN0cy4gTGlzdCBzb21lIHByb3BlcnRpZXMuXHJcbiAgICB2YXIgZmlsZUNvbnRlbnRBcnI9W11cclxuICAgIGZvciAodmFyIGkgPSAwO2k8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGY9ZmlsZXNbaV1cclxuICAgICAgICAvLyBPbmx5IHByb2Nlc3MganNvbiBmaWxlcy5cclxuICAgICAgICBpZiAoZi50eXBlIT1cImFwcGxpY2F0aW9uL2pzb25cIikgY29udGludWU7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICB2YXIgc3RyPSBhd2FpdCB0aGlzLnJlYWRPbmVGaWxlKGYpXHJcbiAgICAgICAgICAgIHZhciBvYmo9SlNPTi5wYXJzZShzdHIpXHJcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkob2JqKSkgZmlsZUNvbnRlbnRBcnI9ZmlsZUNvbnRlbnRBcnIuY29uY2F0KG9iailcclxuICAgICAgICAgICAgZWxzZSBmaWxlQ29udGVudEFyci5wdXNoKG9iailcclxuICAgICAgICB9Y2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgYWxlcnQoZXJyKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKGZpbGVDb250ZW50QXJyLmxlbmd0aD09MCkgcmV0dXJuO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9pbXBvcnRNb2RlbHNcIiwgXCJQT1NUXCIsIHtcIm1vZGVsc1wiOkpTT04uc3RyaW5naWZ5KGZpbGVDb250ZW50QXJyKX0sXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgdGhpcy5saXN0TW9kZWxzKFwic2hvdWxkQnJvYWRDYXN0XCIpXHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICB9ICBcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5yZWFkT25lRmlsZT0gYXN5bmMgZnVuY3Rpb24oYUZpbGUpe1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCk9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGFGaWxlKTtcclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgIHJlamVjdChlKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLmxpc3RNb2RlbHM9YXN5bmMgZnVuY3Rpb24oc2hvdWxkQnJvYWRjYXN0KXtcclxuICAgIHRoaXMubW9kZWxMaXN0LmVtcHR5KClcclxuICAgIHRoaXMucGFuZWxDYXJkLmVtcHR5KClcclxuICAgIHRyeXtcclxuICAgICAgICB2YXIgcmVzPWF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2ZldGNoUHJvamVjdE1vZGVsc0RhdGFcIixcIlBPU1RcIixudWxsLFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLnN0b3JlUHJvamVjdE1vZGVsc0RhdGEocmVzLkRCTW9kZWxzLHJlcy5hZHRNb2RlbHMpXHJcbiAgICAgICAgbW9kZWxBbmFseXplci5jbGVhckFsbE1vZGVscygpO1xyXG4gICAgICAgIG1vZGVsQW5hbHl6ZXIuYWRkTW9kZWxzKHJlcy5hZHRNb2RlbHMpXHJcbiAgICAgICAgbW9kZWxBbmFseXplci5hbmFseXplKCk7XHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgaWYoJC5pc0VtcHR5T2JqZWN0KG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVscykpe1xyXG4gICAgICAgIHZhciB6ZXJvTW9kZWxJdGVtPSQoJzxsaSBzdHlsZT1cImZvbnQtc2l6ZTowLjllbVwiPnplcm8gbW9kZWwgcmVjb3JkLiBQbGVhc2UgaW1wb3J0Li4uPC9saT4nKVxyXG4gICAgICAgIHRoaXMubW9kZWxMaXN0LmFwcGVuZCh6ZXJvTW9kZWxJdGVtKVxyXG4gICAgICAgIHplcm9Nb2RlbEl0ZW0uY3NzKFwiY3Vyc29yXCIsXCJkZWZhdWx0XCIpXHJcblxyXG4gICAgICAgIHZhciBjcmVhdGVTYW1wbGVNb2RlbHNCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYnV0dG9uIHczLWFtYmVyIHczLWhvdmVyLXBpbmsgdzMtYm9yZGVyXCIgc3R5bGU9XCJtYXJnaW46MTAlO2ZvbnQtc2l6ZToxZW1cIj5DcmVhdGUgU2FtcGxlIE1vZGVsczwvYnV0dG9uPicpXHJcbiAgICAgICAgdGhpcy5tb2RlbExpc3QuYXBwZW5kKGNyZWF0ZVNhbXBsZU1vZGVsc0J1dHRvbikgXHJcbiAgICAgICAgY3JlYXRlU2FtcGxlTW9kZWxzQnV0dG9uLm9uKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjcmVhdGVTYW1wbGVNb2RlbHNCdXR0b24uaGlkZSgpXHJcbiAgICAgICAgICAgIHZhciBuYW1lU3BhY2VTdHIgPSBtc2FsSGVscGVyLnVzZXJOYW1lLnJlcGxhY2VBbGwoXCIgXCIsIFwiX1wiKVxyXG4gICAgICAgICAgICBpZiAobmFtZVNwYWNlU3RyID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzTGVuZ3RoID0gY2hhcmFjdGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVTcGFjZVN0ciArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2ltcG9ydE1vZGVsc1wiLCBcIlBPU1RcIiwge1wibW9kZWxzXCI6dGhpcy5zYW1wbGVNb2RlbHNTdHIobmFtZVNwYWNlU3RyKX0sXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RNb2RlbHMoXCJzaG91bGRCcm9hZENhc3RcIilcclxuICAgICAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9KSBcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBzaW1wbGVUcmVlKHRoaXMubW9kZWxMaXN0LCB7XHJcbiAgICAgICAgICAgIFwibGVhZk5hbWVQcm9wZXJ0eVwiOiBcImRpc3BsYXlOYW1lXCJcclxuICAgICAgICAgICAgLCBcIm5vTXVsdGlwbGVTZWxlY3RBbGxvd2VkXCI6IHRydWUsIFwiaGlkZUVtcHR5R3JvdXBcIjogdHJ1ZVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMudHJlZS5vcHRpb25zLmxlYWZOb2RlSWNvbkZ1bmMgPSAobG4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbENhY2hlLmdlbmVyYXRlTW9kZWxJY29uKGxuLmxlYWZJbmZvW1wiQGlkXCJdKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50cmVlLmNhbGxiYWNrX2FmdGVyU2VsZWN0Tm9kZXMgPSAobm9kZXNBcnIsIG1vdXNlQ2xpY2tEZXRhaWwpID0+IHtcclxuICAgICAgICAgICAgdmFyIHRoZU5vZGUgPSBub2Rlc0FyclswXVxyXG4gICAgICAgICAgICB0aGlzLmZpbGxSaWdodFNwYW4odGhlTm9kZS5sZWFmSW5mb1tcIkBpZFwiXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBncm91cE5hbWVMaXN0ID0ge31cclxuICAgICAgICBmb3IgKHZhciBtb2RlbElEIGluIG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVscykgZ3JvdXBOYW1lTGlzdFt0aGlzLm1vZGVsTmFtZVRvR3JvdXBOYW1lKG1vZGVsSUQpXSA9IDFcclxuICAgICAgICB2YXIgbW9kZWxncm91cFNvcnRBcnIgPSBPYmplY3Qua2V5cyhncm91cE5hbWVMaXN0KVxyXG4gICAgICAgIG1vZGVsZ3JvdXBTb3J0QXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKGIudG9Mb3dlckNhc2UoKSkgfSk7XHJcbiAgICAgICAgbW9kZWxncm91cFNvcnRBcnIuZm9yRWFjaChvbmVHcm91cE5hbWUgPT4ge1xyXG4gICAgICAgICAgICB2YXIgZ249dGhpcy50cmVlLmFkZEdyb3VwTm9kZSh7IGRpc3BsYXlOYW1lOiBvbmVHcm91cE5hbWUgfSlcclxuICAgICAgICAgICAgZ24uZXhwYW5kKClcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBmb3IgKHZhciBtb2RlbElEIGluIG1vZGVsQW5hbHl6ZXIuRFRETE1vZGVscykge1xyXG4gICAgICAgICAgICB2YXIgZ24gPSB0aGlzLm1vZGVsTmFtZVRvR3JvdXBOYW1lKG1vZGVsSUQpXHJcbiAgICAgICAgICAgIHRoaXMudHJlZS5hZGRMZWFmbm9kZVRvR3JvdXAoZ24sIEpTT04ucGFyc2UobW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdW1wib3JpZ2luYWxcIl0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50cmVlLnNvcnRBbGxMZWF2ZXMoKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZihzaG91bGRCcm9hZGNhc3QpIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcIkFEVE1vZGVsc0NoYW5nZVwifSlcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5tb2RlbE5hbWVUb0dyb3VwTmFtZT1mdW5jdGlvbihtb2RlbE5hbWUpe1xyXG4gICAgdmFyIG5hbWVQYXJ0cz1tb2RlbE5hbWUuc3BsaXQoXCI6XCIpXHJcbiAgICBpZihuYW1lUGFydHMubGVuZ3RoPj0yKSAgcmV0dXJuIG5hbWVQYXJ0c1sxXVxyXG4gICAgZWxzZSByZXR1cm4gXCJPdGhlcnNcIlxyXG59XHJcblxyXG5tb2RlbE1hbmFnZXJEaWFsb2cucHJvdG90eXBlLnJ4TWVzc2FnZT1mdW5jdGlvbihtc2dQYXlsb2FkKXtcclxuICAgIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJBRFRNb2RlbEVkaXRlZFwiKSB0aGlzLmxpc3RNb2RlbHMoXCJzaG91bGRCcm9hZGNhc3RcIilcclxufVxyXG5cclxubW9kZWxNYW5hZ2VyRGlhbG9nLnByb3RvdHlwZS5zYW1wbGVNb2RlbHNTdHI9ZnVuY3Rpb24ocmFuZG9tZU5hbWVTcGFjZSl7XHJcbiAgICB2YXIgc2FtcGxlU3RyPSdbe1wiQGlkXCI6XCJkdG1pOlBJRDE6cmVkdWNlcjsxXCIsXCJAY29udGV4dFwiOltcImR0bWk6ZHRkbDpjb250ZXh0OzJcIl0sXCJAdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJkaXNwbGF5TmFtZVwiOlwiUmVkdWNlclwiLFwiY29udGVudHNcIjpbe1wiQHR5cGVcIjpcIlByb3BlcnR5XCIsXCJuYW1lXCI6XCJ1cHN0cmVhbVNpemVcIixcInNjaGVtYVwiOlwiZmxvYXRcIn0se1wiQHR5cGVcIjpcIlJlbGF0aW9uc2hpcFwiLFwibmFtZVwiOlwicGlwZUNvbm5lY3RcIn0se1wiQHR5cGVcIjpcIlByb3BlcnR5XCIsXCJuYW1lXCI6XCJkb3duc3RyZWFtU2l6ZVwiLFwic2NoZW1hXCI6XCJmbG9hdFwifSx7XCJAdHlwZVwiOlwiUHJvcGVydHlcIixcIm5hbWVcIjpcInR5cGVcIixcInNjaGVtYVwiOntcIkB0eXBlXCI6XCJFbnVtXCIsXCJ2YWx1ZVNjaGVtYVwiOlwic3RyaW5nXCIsXCJlbnVtVmFsdWVzXCI6W3tcIm5hbWVcIjpcImNvbmNlbnRyaWNcIixcImVudW1WYWx1ZVwiOlwiY29uY2VudHJpY1wifSx7XCJuYW1lXCI6XCJlY2NlbnRyaWNcIixcImVudW1WYWx1ZVwiOlwiZWNjZW50cmljXCJ9XX19LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwiaGVpZ2h0XCIsXCJzY2hlbWFcIjpcImZsb2F0XCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwidGhpY2tuZXNzXCIsXCJzY2hlbWFcIjpcImZsb2F0XCJ9XSxcImV4dGVuZHNcIjpbXX0se1wiQGlkXCI6XCJkdG1pOlBJRDE6cHJlc3N1cmVUcmFuc21pdHRlcjsxXCIsXCJAY29udGV4dFwiOltcImR0bWk6ZHRkbDpjb250ZXh0OzJcIl0sXCJAdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJkaXNwbGF5TmFtZVwiOlwiUHJlc3N1cmUgVHJhbnNtaXR0ZXJcIixcImNvbnRlbnRzXCI6W3tcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwicHJlc3N1cmVcIixcInNjaGVtYVwiOlwiZmxvYXRcIn0se1wiQHR5cGVcIjpcIlJlbGF0aW9uc2hpcFwiLFwibmFtZVwiOlwic2Vuc2luZ1wifSx7XCJAdHlwZVwiOlwiUHJvcGVydHlcIixcIm5hbWVcIjpcInVuaXRcIixcInNjaGVtYVwiOlwic3RyaW5nXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwidHlwZVwiLFwic2NoZW1hXCI6e1wiQHR5cGVcIjpcIkVudW1cIixcInZhbHVlU2NoZW1hXCI6XCJzdHJpbmdcIixcImVudW1WYWx1ZXNcIjpbe1wibmFtZVwiOlwiYW5hbG9nXCIsXCJlbnVtVmFsdWVcIjpcImFuYWxvZ1wifSx7XCJuYW1lXCI6XCJkaWdpdGFsXCIsXCJlbnVtVmFsdWVcIjpcImRpZ2l0YWxcIn1dfX0se1wiQHR5cGVcIjpcIlByb3BlcnR5XCIsXCJuYW1lXCI6XCJtb2RlbFwiLFwic2NoZW1hXCI6XCJzdHJpbmdcIn1dLFwiZXh0ZW5kc1wiOltdfSx7XCJAaWRcIjpcImR0bWk6UElEMTptaXhpbmdSZWFjdG9yOzFcIixcIkBjb250ZXh0XCI6W1wiZHRtaTpkdGRsOmNvbnRleHQ7MlwiXSxcIkB0eXBlXCI6XCJJbnRlcmZhY2VcIixcImRpc3BsYXlOYW1lXCI6XCJNaXhpbmcgUmVhY3RvclwiLFwiY29udGVudHNcIjpbe1wiQHR5cGVcIjpcIlJlbGF0aW9uc2hpcFwiLFwibmFtZVwiOlwicGlwZUNvbm5lY3RcIn0se1wiQHR5cGVcIjpcIlByb3BlcnR5XCIsXCJuYW1lXCI6XCJ2b2x1bWVcIixcInNjaGVtYVwiOlwiZG91YmxlXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwidGVtcGVyYXR1cmVcIixcInNjaGVtYVwiOlwiZG91YmxlXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwicHJlc3N1cmVcIixcInNjaGVtYVwiOlwiZG91YmxlXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwibW9kZWxcIixcInNjaGVtYVwiOlwic3RyaW5nXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwidHlwZVwiLFwic2NoZW1hXCI6e1wiQHR5cGVcIjpcIkVudW1cIixcInZhbHVlU2NoZW1hXCI6XCJzdHJpbmdcIixcImVudW1WYWx1ZXNcIjpbe1wibmFtZVwiOlwiQ1NUUlwiLFwiZW51bVZhbHVlXCI6XCJDU1RSXCJ9LHtcIm5hbWVcIjpcIlBGUlwiLFwiZW51bVZhbHVlXCI6XCJQRlJcIn0se1wibmFtZVwiOlwiQ2F0YWx5dGljXCIsXCJlbnVtVmFsdWVcIjpcIkNhdGFseXRpY1wifV19fV0sXCJleHRlbmRzXCI6W119LHtcIkBpZFwiOlwiZHRtaTpQSUQxOnBhY2tlZENvbHVtbjsxXCIsXCJAY29udGV4dFwiOltcImR0bWk6ZHRkbDpjb250ZXh0OzJcIl0sXCJAdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJkaXNwbGF5TmFtZVwiOlwiUGFja2VkIENvbHVtblwiLFwiY29udGVudHNcIjpbe1wiQHR5cGVcIjpcIlJlbGF0aW9uc2hpcFwiLFwibmFtZVwiOlwicGlwZUNvbm5lY3RcIn0se1wiQHR5cGVcIjpcIlByb3BlcnR5XCIsXCJuYW1lXCI6XCJ2b2x1bWVcIixcInNjaGVtYVwiOlwiZG91YmxlXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwidGVtcGVyYXR1cmVcIixcInNjaGVtYVwiOlwiZG91YmxlXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwicHJlc3N1cmVcIixcInNjaGVtYVwiOlwiZG91YmxlXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwibW9kZWxcIixcInNjaGVtYVwiOlwic3RyaW5nXCJ9XSxcImV4dGVuZHNcIjpbXX0se1wiQGlkXCI6XCJkdG1pOlBJRDE6dmVzc2VsOzFcIixcIkBjb250ZXh0XCI6W1wiZHRtaTpkdGRsOmNvbnRleHQ7MlwiXSxcIkB0eXBlXCI6XCJJbnRlcmZhY2VcIixcImRpc3BsYXlOYW1lXCI6XCJWZXNzZWxcIixcImNvbnRlbnRzXCI6W3tcIkB0eXBlXCI6XCJSZWxhdGlvbnNoaXBcIixcIm5hbWVcIjpcInBpcGVDb25uZWN0XCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwidm9sdW1lXCIsXCJzY2hlbWFcIjpcImRvdWJsZVwifSx7XCJAdHlwZVwiOlwiUHJvcGVydHlcIixcIm5hbWVcIjpcInRlbXBlcmF0dXJlXCIsXCJzY2hlbWFcIjpcImRvdWJsZVwifSx7XCJAdHlwZVwiOlwiUHJvcGVydHlcIixcIm5hbWVcIjpcInByZXNzdXJlXCIsXCJzY2hlbWFcIjpcImRvdWJsZVwifSx7XCJAdHlwZVwiOlwiUHJvcGVydHlcIixcIm5hbWVcIjpcIm1vZGVsXCIsXCJzY2hlbWFcIjpcInN0cmluZ1wifV0sXCJleHRlbmRzXCI6W119LHtcIkBpZFwiOlwiZHRtaTpQSUQxOm1vdG9yVmFsdmU7MVwiLFwiQGNvbnRleHRcIjpbXCJkdG1pOmR0ZGw6Y29udGV4dDsyXCJdLFwiQHR5cGVcIjpcIkludGVyZmFjZVwiLFwiZGlzcGxheU5hbWVcIjpcIk1vdG9yIFZhbHZlXCIsXCJjb250ZW50c1wiOlt7XCJAdHlwZVwiOlwiUmVsYXRpb25zaGlwXCIsXCJuYW1lXCI6XCJwaXBlQ29ubmVjdFwifSx7XCJAdHlwZVwiOlwiUHJvcGVydHlcIixcIm5hbWVcIjpcInNpemVcIixcInNjaGVtYVwiOlwiZG91YmxlXCJ9LHtcIkB0eXBlXCI6XCJQcm9wZXJ0eVwiLFwibmFtZVwiOlwicG9ydHNcIixcInNjaGVtYVwiOlwiaW50ZWdlclwifV0sXCJleHRlbmRzXCI6W119LHtcIkBpZFwiOlwiZHRtaTpQSUQxOm9uZVRvT25lOzFcIixcIkBjb250ZXh0XCI6W1wiZHRtaTpkdGRsOmNvbnRleHQ7MlwiXSxcIkB0eXBlXCI6XCJJbnRlcmZhY2VcIixcImRpc3BsYXlOYW1lXCI6XCJvbmVUb09uZVwiLFwiY29udGVudHNcIjpbe1wiQHR5cGVcIjpcIlJlbGF0aW9uc2hpcFwiLFwibmFtZVwiOlwicGlwZUNvbm5lY3RcIn0se1wiQHR5cGVcIjpcIlByb3BlcnR5XCIsXCJuYW1lXCI6XCJtb2RlbFwiLFwic2NoZW1hXCI6XCJzdHJpbmdcIn1dLFwiZXh0ZW5kc1wiOltdfSx7XCJAaWRcIjpcImR0bWk6UElEMTpvbmVUb09wdGlvbmFsTXVsdGk7MVwiLFwiQGNvbnRleHRcIjpbXCJkdG1pOmR0ZGw6Y29udGV4dDsyXCJdLFwiQHR5cGVcIjpcIkludGVyZmFjZVwiLFwiZGlzcGxheU5hbWVcIjpcIm9uZVRvT3B0aW9uYWxNdWx0aVwiLFwiY29udGVudHNcIjpbe1wiQHR5cGVcIjpcIlJlbGF0aW9uc2hpcFwiLFwibmFtZVwiOlwicGlwZUNvbm5lY3RcIn0se1wiQHR5cGVcIjpcIlByb3BlcnR5XCIsXCJuYW1lXCI6XCJtb2RlbFwiLFwic2NoZW1hXCI6XCJzdHJpbmdcIn1dLFwiZXh0ZW5kc1wiOltdfV0nXHJcbiAgICByZXR1cm4gc2FtcGxlU3RyLnJlcGxhY2VBbGwoXCI6UElEMTpcIixcIjpcIityYW5kb21lTmFtZVNwYWNlK1wiOlwiKVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBtb2RlbE1hbmFnZXJEaWFsb2coKTsiLCJjb25zdCBnbG9iYWxBcHBTZXR0aW5ncz1yZXF1aXJlKFwiLi4vZ2xvYmFsQXBwU2V0dGluZ3NcIilcclxuXHJcbmZ1bmN0aW9uIG1vZHVsZVN3aXRjaERpYWxvZygpe1xyXG4gICAgdGhpcy5tb2R1bGVzU2lkZWJhcj0kKCc8ZGl2IGNsYXNzPVwidzMtc2lkZWJhciB3My1iYXItYmxvY2sgdzMtd2hpdGUgdzMtYW5pbWF0ZS1sZWZ0IHczLWNhcmQtNFwiIHN0eWxlPVwiZGlzcGxheTpub25lO2hlaWdodDoxOTVweDt3aWR0aDoyNDBweDtvdmVyZmxvdzpoaWRkZW5cIj48ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLWxlZnQgdzMtaG92ZXItYW1iZXJcIiBzdHlsZT1cImZvbnQtc2l6ZToyZW07cGFkZGluZy10b3A6NHB4O3dpZHRoOjU1cHhcIj7imLA8L2J1dHRvbj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjVlbTt3aWR0aDo3MHB4O2Zsb2F0OmxlZnQ7Y3Vyc29yOmRlZmF1bHRcIj5PcGVuPC9kaXY+PC9kaXY+PGEgaHJlZj1cIiNcIiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1tZWRpdW1cIj48aW1nIHNyYz1cImZhdmljb25pb3RodWIuaWNvXCIgc3R5bGU9XCJ3aWR0aDoyNXB4O21hcmdpbi1yaWdodDoxMHB4XCI+PC9pbWc+RGV2aWNlIE1hbmFnZW1lbnQ8L2E+PGEgaHJlZj1cIiNcIiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1tZWRpdW1cIj48aW1nIHNyYz1cImZhdmljb25kaWdpdGFsdHdpbi5pY29cIiBzdHlsZT1cIndpZHRoOjI1cHg7bWFyZ2luLXJpZ2h0OjEwcHhcIj48L2ltZz5EaWdpdGFsIFR3aW48L2E+PGEgaHJlZj1cIiNcIiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1tZWRpdW1cIj48aW1nIHNyYz1cImZhdmljb25ldmVudGxvZy5pY29cIiBzdHlsZT1cIndpZHRoOjI1cHg7bWFyZ2luLXJpZ2h0OjEwcHhcIj48L2ltZz5FdmVudCBMb2c8L2E+PGEgaHJlZj1cIiNcIiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1tZWRpdW1cIj5Mb2cgb3V0PC9hPjwvZGl2PicpXHJcbiAgICBcclxuICAgIHRoaXMubW9kdWxlc1N3aXRjaEJ1dHRvbj0kKCc8YSBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvblwiIGhyZWY9XCIjXCI+4piwPC9hPicpXHJcbiAgICBcclxuICAgIHRoaXMubW9kdWxlc1N3aXRjaEJ1dHRvbi5vbihcImNsaWNrXCIsKCk9PnsgdGhpcy5tb2R1bGVzU2lkZWJhci5jc3MoXCJkaXNwbGF5XCIsXCJibG9ja1wiKSB9KVxyXG4gICAgdGhpcy5tb2R1bGVzU2lkZWJhci5jaGlsZHJlbignOmZpcnN0Jykub24oXCJjbGlja1wiLCgpPT57dGhpcy5tb2R1bGVzU2lkZWJhci5jc3MoXCJkaXNwbGF5XCIsXCJub25lXCIpfSlcclxuICAgIFxyXG4gICAgdmFyIGFsbE1vZGV1bHM9dGhpcy5tb2R1bGVzU2lkZWJhci5jaGlsZHJlbihcImFcIilcclxuICAgICQoYWxsTW9kZXVsc1swXSkub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgd2luZG93Lm9wZW4oXCJkZXZpY2VtYW5hZ2VtZW50Lmh0bWxcIiwgXCJfYmxhbmtcIilcclxuICAgICAgICB0aGlzLm1vZHVsZXNTaWRlYmFyLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIilcclxuICAgIH0pXHJcbiAgICAkKGFsbE1vZGV1bHNbMV0pLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKFwiZGlnaXRhbHR3aW5tb2R1bGUuaHRtbFwiLCBcIl9ibGFua1wiKVxyXG4gICAgICAgIHRoaXMubW9kdWxlc1NpZGViYXIuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKVxyXG4gICAgfSlcclxuICAgICQoYWxsTW9kZXVsc1syXSkub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgd2luZG93Lm9wZW4oXCJldmVudGxvZ21vZHVsZS5odG1sXCIsIFwiX2JsYW5rXCIpXHJcbiAgICAgICAgdGhpcy5tb2R1bGVzU2lkZWJhci5jc3MoXCJkaXNwbGF5XCIsXCJub25lXCIpXHJcbiAgICB9KVxyXG4gICAgJChhbGxNb2RldWxzWzNdKS5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICBjb25zdCBsb2dvdXRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBwb3N0TG9nb3V0UmVkaXJlY3RVcmk6IGdsb2JhbEFwcFNldHRpbmdzLmxvZ291dFJlZGlyZWN0VXJpLFxyXG4gICAgICAgICAgICBtYWluV2luZG93UmVkaXJlY3RVcmk6IGdsb2JhbEFwcFNldHRpbmdzLmxvZ291dFJlZGlyZWN0VXJpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbXlNU0FMT2JqID0gbmV3IG1zYWwuUHVibGljQ2xpZW50QXBwbGljYXRpb24oZ2xvYmFsQXBwU2V0dGluZ3MubXNhbENvbmZpZyk7XHJcbiAgICAgICAgbXlNU0FMT2JqLmxvZ291dFBvcHVwKGxvZ291dFJlcXVlc3QpO1xyXG4gICAgfSlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgbW9kdWxlU3dpdGNoRGlhbG9nKCk7IiwiY29uc3QgbW9kZWxBbmFseXplcj1yZXF1aXJlKFwiLi9tb2RlbEFuYWx5emVyXCIpXHJcbmNvbnN0IHNpbXBsZVNlbGVjdE1lbnU9IHJlcXVpcmUoXCIuL3NpbXBsZVNlbGVjdE1lbnVcIilcclxuY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBnbG9iYWxDYWNoZT1yZXF1aXJlKFwiLi9nbG9iYWxDYWNoZVwiKVxyXG5cclxuZnVuY3Rpb24gbmV3VHdpbkRpYWxvZygpIHtcclxuICAgIGlmKCF0aGlzLkRPTSl7XHJcbiAgICAgICAgdGhpcy5ET00gPSAkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO2xlZnQ6NTAlO3RyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6OTlcIiBjbGFzcz1cInczLWNhcmQtMlwiPjwvZGl2PicpXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLm1ha2VET01EcmFnZ2FibGUodGhpcy5ET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbm5ld1R3aW5EaWFsb2cucHJvdG90eXBlLnBvcHVwID0gYXN5bmMgZnVuY3Rpb24odHdpbkluZm8sYWZ0ZXJUd2luQ3JlYXRlZENhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmFmdGVyVHdpbkNyZWF0ZWRDYWxsYmFjaz1hZnRlclR3aW5DcmVhdGVkQ2FsbGJhY2tcclxuICAgIHRoaXMub3JpZ2luYWxUd2luSW5mbz1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHR3aW5JbmZvKSlcclxuICAgIHRoaXMudHdpbkluZm89dHdpbkluZm9cclxuICAgIHRoaXMuRE9NLnNob3coKVxyXG4gICAgdGhpcy5ET00uZW1wdHkoKVxyXG4gICAgdGhpcy5jb250ZW50RE9NID0gJCgnPGRpdiBzdHlsZT1cIndpZHRoOjUyMHB4XCI+PC9kaXY+JylcclxuICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmNvbnRlbnRET00pXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuNWVtXCI+RGlnaXRhbCBUd2luIEVkaXRvcjwvZGl2PjwvZGl2PicpKVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbTtwYWRkaW5nLXRvcDo0cHhcIj7DlzwvYnV0dG9uPicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLkRPTS5oaWRlKCkgfSlcclxuXHJcbiAgICBpZighdGhpcy5hZnRlclR3aW5DcmVhdGVkQ2FsbGJhY2spe1xyXG4gICAgICAgIHZhciBhZGRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJ1dHRvbiB3My1jYXJkIHczLWdyZWVuIHczLWhvdmVyLWxpZ2h0LWdyZWVuXCIgc3R5bGU9XCJoZWlnaHQ6MTAwJVwiPkFkZDwvYnV0dG9uPicpXHJcbiAgICAgICAgdGhpcy5jb250ZW50RE9NLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQoYWRkQnV0dG9uKVxyXG4gICAgICAgIGFkZEJ1dHRvbi5vbihcImNsaWNrXCIsIGFzeW5jICgpID0+IHsgdGhpcy5hZGROZXdUd2luKCkgfSkgICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgYWRkQW5kQ2xvc2VCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYnV0dG9uIHczLWNhcmQgdzMtZ3JlZW4gdzMtaG92ZXItbGlnaHQtZ3JlZW5cIiBzdHlsZT1cImhlaWdodDoxMDAlO21hcmdpbi1sZWZ0OjVweFwiPkFkZCAmIENsb3NlPC9idXR0b24+JykgICAgXHJcbiAgICB0aGlzLmNvbnRlbnRET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChhZGRBbmRDbG9zZUJ1dHRvbilcclxuICAgIGFkZEFuZENsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge3RoaXMuYWRkTmV3VHdpbihcIkNsb3NlRGlhbG9nXCIpfSlcclxuICAgICAgICBcclxuICAgIHZhciBJRExhYmxlRGl2PSAkKFwiPGRpdiBjbGFzcz0ndzMtcGFkZGluZycgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtd2VpZ2h0OmJvbGQ7Y29sb3I6YmxhY2snPlR3aW4gSUQ8L2Rpdj5cIilcclxuICAgIHZhciBJRElucHV0PSQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPVwibWFyZ2luOjhweCAwO3BhZGRpbmc6MnB4O3dpZHRoOjE1MHB4O291dGxpbmU6bm9uZTtkaXNwbGF5OmlubGluZVwiIHBsYWNlaG9sZGVyPVwiSURcIi8+JykuYWRkQ2xhc3MoXCJ3My1pbnB1dCB3My1ib3JkZXJcIik7XHJcbiAgICB0aGlzLklESW5wdXQ9SURJbnB1dCBcclxuICAgIHZhciBtb2RlbElEPXR3aW5JbmZvW1wiJG1ldGFkYXRhXCJdW1wiJG1vZGVsXCJdXHJcbiAgICB2YXIgbW9kZWxMYWJsZURpdj0gJChcIjxkaXYgY2xhc3M9J3czLXBhZGRpbmcnIHN0eWxlPSdkaXNwbGF5OmlubGluZTtmb250LXdlaWdodDpib2xkO2NvbG9yOmJsYWNrJz5Nb2RlbDwvZGl2PlwiKVxyXG4gICAgdmFyIG1vZGVsSW5wdXQ9JCgnPGxhYmVsIHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJtYXJnaW46OHB4IDA7cGFkZGluZzoycHg7ZGlzcGxheTppbmxpbmVcIi8+JykudGV4dChtb2RlbElEKTsgIFxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZCgkKFwiPGRpdi8+XCIpLmFwcGVuZChJRExhYmxlRGl2LElESW5wdXQpKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZCgkKFwiPGRpdiBzdHlsZT0ncGFkZGluZzo4cHggMHB4Jy8+XCIpLmFwcGVuZChtb2RlbExhYmxlRGl2LG1vZGVsSW5wdXQpKVxyXG4gICAgSURJbnB1dC5jaGFuZ2UoKGUpPT57XHJcbiAgICAgICAgdGhpcy50d2luSW5mb1tcIiRkdElkXCJdPSQoZS50YXJnZXQpLnZhbCgpXHJcbiAgICB9KVxyXG5cclxuICAgIHZhciBkaWFsb2dET009JCgnPGRpdiAvPicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKGRpYWxvZ0RPTSkgICAgXHJcbiAgICB2YXIgdGl0bGVUYWJsZT0kKCc8dGFibGUgc3R5bGU9XCJ3aWR0aDoxMDAlXCIgY2VsbHNwYWNpbmc9XCIwcHhcIiBjZWxscGFkZGluZz1cIjBweFwiPjwvdGFibGU+JylcclxuICAgIHRpdGxlVGFibGUuYXBwZW5kKCQoJzx0cj48dGQgc3R5bGU9XCJmb250LXdlaWdodDpib2xkXCI+UHJvcGVydGllcyBUcmVlPC90ZD48L3RyPicpKVxyXG4gICAgZGlhbG9nRE9NLmFwcGVuZCgkKFwiPGRpdiBjbGFzcz0ndzMtY29udGFpbmVyJy8+XCIpLmFwcGVuZCh0aXRsZVRhYmxlKSlcclxuXHJcbiAgICB2YXIgc2V0dGluZ3NEaXY9JChcIjxkaXYgY2xhc3M9J3czLWNvbnRhaW5lciB3My1ib3JkZXInIHN0eWxlPSd3aWR0aDoxMDAlO21heC1oZWlnaHQ6MzEwcHg7b3ZlcmZsb3c6YXV0byc+PC9kaXY+XCIpXHJcbiAgICB0aGlzLnNldHRpbmdzRGl2PXNldHRpbmdzRGl2XHJcbiAgICBkaWFsb2dET00uYXBwZW5kKHNldHRpbmdzRGl2KVxyXG4gICAgdGhpcy5kcmF3TW9kZWxTZXR0aW5ncygpXHJcbn1cclxuXHJcbm5ld1R3aW5EaWFsb2cucHJvdG90eXBlLmFkZE5ld1R3aW4gPSBhc3luYyBmdW5jdGlvbihjbG9zZURpYWxvZykge1xyXG4gICAgdmFyIG1vZGVsSUQ9dGhpcy50d2luSW5mb1tcIiRtZXRhZGF0YVwiXVtcIiRtb2RlbFwiXVxyXG4gICAgdmFyIERCTW9kZWxJbmZvPWdsb2JhbENhY2hlLmdldFNpbmdsZURCTW9kZWxCeUlEKG1vZGVsSUQpXHJcblxyXG4gICAgaWYoIXRoaXMudHdpbkluZm9bXCIkZHRJZFwiXXx8dGhpcy50d2luSW5mb1tcIiRkdElkXCJdPT1cIlwiKXtcclxuICAgICAgICBhbGVydChcIlBsZWFzZSBmaWxsIGluIG5hbWUgZm9yIHRoZSBuZXcgZGlnaXRhbCB0d2luXCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvbmVudHNOYW1lQXJyPW1vZGVsQW5hbHl6ZXIuRFRETE1vZGVsc1ttb2RlbElEXS5pbmNsdWRlZENvbXBvbmVudHNcclxuICAgIGNvbXBvbmVudHNOYW1lQXJyLmZvckVhY2gob25lQ29tcG9uZW50TmFtZT0+eyAvL2FkdCBzZXJ2aWNlIHJlcXVlc3RpbmcgYWxsIGNvbXBvbmVudCBhcHBlYXIgYnkgbWFuZGF0b3J5XHJcbiAgICAgICAgaWYodGhpcy50d2luSW5mb1tvbmVDb21wb25lbnROYW1lXT09bnVsbCl0aGlzLnR3aW5JbmZvW29uZUNvbXBvbmVudE5hbWVdPXt9XHJcbiAgICAgICAgdGhpcy50d2luSW5mb1tvbmVDb21wb25lbnROYW1lXVtcIiRtZXRhZGF0YVwiXT0ge31cclxuICAgIH0pXHJcblxyXG4gICAgLy9hc2sgdGFza21hc3RlciB0byBhZGQgdGhlIHR3aW5cclxuICAgIHRyeXtcclxuICAgICAgICB2YXIgcG9zdEJvZHk9IHtcIm5ld1R3aW5Kc29uXCI6SlNPTi5zdHJpbmdpZnkodGhpcy50d2luSW5mbyl9XHJcbiAgICAgICAgdmFyIGRhdGEgPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi91cHNlcnREaWdpdGFsVHdpblwiLCBcIlBPU1RcIiwgcG9zdEJvZHksXCJ3aXRoUHJvamVjdElEXCIgKVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgaWYoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbENhY2hlLnN0b3JlU2luZ2xlREJUd2luKGRhdGEuREJUd2luKSAgICBcclxuICAgIGdsb2JhbENhY2hlLnN0b3JlU2luZ2xlQURUVHdpbihkYXRhLkFEVFR3aW4pXHJcblxyXG5cclxuICAgIC8vYXNrIHRhc2ttYXN0ZXIgdG8gcHJvdmlzaW9uIHRoZSB0d2luIHRvIGlvdCBodWIgaWYgdGhlIG1vZGVsIGlzIGEgaW90IGRldmljZSBtb2RlbFxyXG4gICAgaWYoREJNb2RlbEluZm8uaXNJb1REZXZpY2VNb2RlbCl7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICB2YXIgcG9zdEJvZHk9IHtcIkRCVHdpblwiOmRhdGEuREJUd2luLFwiZGVzaXJlZEluRGV2aWNlVHdpblwiOnt9fVxyXG4gICAgICAgICAgICBEQk1vZGVsSW5mby5kZXNpcmVkUHJvcGVydGllcy5mb3JFYWNoKGVsZT0+e1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZT1lbGUucGF0aFtlbGUucGF0aC5sZW5ndGgtMV1cclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVNhbXBsZVY9IFwiXCJcclxuICAgICAgICAgICAgICAgIHBvc3RCb2R5LmRlc2lyZWRJbkRldmljZVR3aW5bcHJvcGVydHlOYW1lXT1wcm9wZXJ0eVNhbXBsZVZcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdmFyIHByb3Zpc2lvbmVkRG9jdW1lbnQgPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkZXZpY2VtYW5hZ2VtZW50L3Byb3Zpc2lvbklvVERldmljZVR3aW5cIiwgXCJQT1NUXCIsIHBvc3RCb2R5LFwid2l0aFByb2plY3RJRFwiIClcclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS5EQlR3aW49cHJvdmlzaW9uZWREb2N1bWVudFxyXG4gICAgICAgIGdsb2JhbENhY2hlLnN0b3JlU2luZ2xlREJUd2luKHByb3Zpc2lvbmVkRG9jdW1lbnQpICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy9pdCBzaG91bGQgc2VsZWN0IHRoZSBuZXcgbm9kZSBpbiB0aGUgdHJlZSwgYW5kIG1vdmUgdG9wb2xvZ3kgdmlldyB0byBzaG93IHRoZSBuZXcgbm9kZSAobm90ZSBwYW4gdG8gYSBwbGFjZSB0aGF0IGlzIG5vdCBibG9ja2VkIGJ5IHRoZSBkaWFsb2cgaXRzZWxmKVxyXG4gICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwiYWRkTmV3VHdpblwiLCBcInR3aW5JbmZvXCI6IGRhdGEuQURUVHdpbiwgXCJEQlR3aW5JbmZvXCI6ZGF0YS5EQlR3aW59KVxyXG5cclxuICAgIGlmKHRoaXMuYWZ0ZXJUd2luQ3JlYXRlZENhbGxiYWNrKXtcclxuICAgICAgICB0aGlzLmFmdGVyVHdpbkNyZWF0ZWRDYWxsYmFjayhkYXRhLkFEVFR3aW4pXHJcbiAgICAgICAgdGhpcy5ET00uaGlkZSgpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBpZihjbG9zZURpYWxvZyl0aGlzLkRPTS5oaWRlKClcclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAvL2NsZWFyIHRoZSBpbnB1dCBlZGl0Ym94XHJcbiAgICAgICAgICAgIHRoaXMucG9wdXAodGhpcy5vcmlnaW5hbFR3aW5JbmZvKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubmV3VHdpbkRpYWxvZy5wcm90b3R5cGUuZHJhd01vZGVsU2V0dGluZ3MgPSBhc3luYyBmdW5jdGlvbigpIHtcclxuICAgIHZhciBtb2RlbElEPXRoaXMudHdpbkluZm9bXCIkbWV0YWRhdGFcIl1bXCIkbW9kZWxcIl1cclxuICAgIHZhciBtb2RlbERldGFpbD0gbW9kZWxBbmFseXplci5EVERMTW9kZWxzW21vZGVsSURdXHJcbiAgICB2YXIgY29weU1vZGVsRWRpdGFibGVQcm9wZXJ0eT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1vZGVsRGV0YWlsLmVkaXRhYmxlUHJvcGVydGllcykpXHJcbiAgICBcclxuICAgIGlmKCQuaXNFbXB0eU9iamVjdChjb3B5TW9kZWxFZGl0YWJsZVByb3BlcnR5KSl7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5nc0Rpdi50ZXh0KFwiVGhlcmUgaXMgbm8gZWRpdGFibGUgcHJvcGVydHlcIilcclxuICAgICAgICB0aGlzLnNldHRpbmdzRGl2LmFkZENsYXNzKFwidzMtdGV4dC1ncmF5XCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSAgIFxyXG5cclxuICAgIHZhciBzZXR0aW5nc1RhYmxlPSQoJzx0YWJsZSBzdHlsZT1cIndpZHRoOjEwMCVcIiBjZWxsc3BhY2luZz1cIjBweFwiIGNlbGxwYWRkaW5nPVwiMHB4XCI+PC90YWJsZT4nKVxyXG4gICAgdGhpcy5zZXR0aW5nc0Rpdi5hcHBlbmQoc2V0dGluZ3NUYWJsZSlcclxuXHJcbiAgICB2YXIgaW5pdGlhbFBhdGhBcnI9W11cclxuICAgIHZhciBsYXN0Um9vdE5vZGVSZWNvcmQ9W11cclxuICAgIHRoaXMuZHJhd0VkaXRhYmxlKHNldHRpbmdzVGFibGUsY29weU1vZGVsRWRpdGFibGVQcm9wZXJ0eSx0aGlzLnR3aW5JbmZvLGluaXRpYWxQYXRoQXJyLGxhc3RSb290Tm9kZVJlY29yZClcclxufVxyXG5cclxuXHJcbm5ld1R3aW5EaWFsb2cucHJvdG90eXBlLmRyYXdFZGl0YWJsZSA9IGFzeW5jIGZ1bmN0aW9uKHBhcmVudFRhYmxlLGpzb25JbmZvLG9yaWdpbkVsZW1lbnRJbmZvLHBhdGhBcnIsbGFzdFJvb3ROb2RlUmVjb3JkKSB7XHJcbiAgICBpZihqc29uSW5mbz09bnVsbCkgcmV0dXJuO1xyXG4gICAgdmFyIGFycj1bXVxyXG4gICAgZm9yKHZhciBpbmQgaW4ganNvbkluZm8pIGFyci5wdXNoKGluZClcclxuXHJcbiAgICBmb3IodmFyIHRoZUluZGV4PTA7dGhlSW5kZXg8YXJyLmxlbmd0aDt0aGVJbmRleCsrKXtcclxuICAgICAgICBpZih0aGVJbmRleD09YXJyLmxlbmd0aC0xKSBsYXN0Um9vdE5vZGVSZWNvcmRbcGF0aEFyci5sZW5ndGhdID10cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpbmQgPSBhcnJbdGhlSW5kZXhdXHJcbiAgICAgICAgdmFyIHRyPSQoXCI8dHIvPlwiKVxyXG4gICAgICAgIHZhciByaWdodFREPSQoXCI8dGQgc3R5bGU9J2hlaWdodDozMHB4Jy8+XCIpXHJcbiAgICAgICAgdHIuYXBwZW5kKHJpZ2h0VEQpXHJcbiAgICAgICAgcGFyZW50VGFibGUuYXBwZW5kKHRyKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaT0wO2k8cGF0aEFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgaWYoIWxhc3RSb290Tm9kZVJlY29yZFtpXSkgcmlnaHRURC5hcHBlbmQodGhpcy50cmVlTGluZURpdigyKSlcclxuICAgICAgICAgICAgZWxzZSByaWdodFRELmFwcGVuZCh0aGlzLnRyZWVMaW5lRGl2KDQpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhlSW5kZXg9PWFyci5sZW5ndGgtMSkgcmlnaHRURC5hcHBlbmQodGhpcy50cmVlTGluZURpdigzKSlcclxuICAgICAgICBlbHNlIHJpZ2h0VEQuYXBwZW5kKHRoaXMudHJlZUxpbmVEaXYoMSkpXHJcblxyXG4gICAgICAgIHZhciBwTmFtZURpdj0kKFwiPGRpdiBzdHlsZT0nZmxvYXQ6bGVmdDtsaW5lLWhlaWdodDoyOHB4O21hcmdpbi1sZWZ0OjNweCc+XCIraW5kK1wiPC9kaXY+XCIpXHJcbiAgICAgICAgcmlnaHRURC5hcHBlbmQocE5hbWVEaXYpXHJcbiAgICAgICAgdmFyIG5ld1BhdGg9cGF0aEFyci5jb25jYXQoW2luZF0pXHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb25JbmZvW2luZF0pKSB7IC8vaXQgaXMgYSBlbnVtZXJhdG9yXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0Ryb3BEb3duQm94KHJpZ2h0VEQsbmV3UGF0aCxqc29uSW5mb1tpbmRdLG9yaWdpbkVsZW1lbnRJbmZvKVxyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChqc29uSW5mb1tpbmRdKT09PVwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3RWRpdGFibGUocGFyZW50VGFibGUsanNvbkluZm9baW5kXSxvcmlnaW5FbGVtZW50SW5mbyxuZXdQYXRoLGxhc3RSb290Tm9kZVJlY29yZClcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBnbG9iYWxDYWNoZS5zZWFyY2hWYWx1ZShvcmlnaW5FbGVtZW50SW5mbywgbmV3UGF0aClcclxuICAgICAgICAgICAgdmFyIGFJbnB1dD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm1hcmdpbi1sZWZ0OjVweDtwYWRkaW5nOjJweDt3aWR0aDoyMDBweDtvdXRsaW5lOm5vbmU7ZGlzcGxheTppbmxpbmVcIiBwbGFjZWhvbGRlcj1cInR5cGU6ICcranNvbkluZm9baW5kXSsnXCIvPicpLmFkZENsYXNzKFwidzMtaW5wdXQgdzMtYm9yZGVyXCIpOyAgXHJcbiAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkgYUlucHV0LnZhbCh2YWwpXHJcbiAgICAgICAgICAgIHJpZ2h0VEQuYXBwZW5kKGFJbnB1dClcclxuICAgICAgICAgICAgYUlucHV0LmRhdGEoXCJwYXRoXCIsIG5ld1BhdGgpXHJcbiAgICAgICAgICAgIGFJbnB1dC5kYXRhKFwiZGF0YVR5cGVcIiwganNvbkluZm9baW5kXSlcclxuICAgICAgICAgICAgYUlucHV0LmNoYW5nZSgoZSk9PntcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT3JpZ2luT2JqZWN0VmFsdWUoJChlLnRhcmdldCkuZGF0YShcInBhdGhcIiksJChlLnRhcmdldCkudmFsKCksJChlLnRhcmdldCkuZGF0YShcImRhdGFUeXBlXCIpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcbn1cclxuXHJcbm5ld1R3aW5EaWFsb2cucHJvdG90eXBlLmRyYXdEcm9wRG93bkJveD1mdW5jdGlvbihyaWdodFRELG5ld1BhdGgsdmFsdWVBcnIsb3JpZ2luRWxlbWVudEluZm8pe1xyXG4gICAgdmFyIGFTZWxlY3RNZW51ID0gbmV3IHNpbXBsZVNlbGVjdE1lbnUoXCJcIlxyXG4gICAgICAgICwgeyB3aWR0aDogXCIyMDBcIiBcclxuICAgICAgICAgICAgLGJ1dHRvbkNTUzogeyBcInBhZGRpbmdcIjogXCI0cHggMTZweFwifVxyXG4gICAgICAgICAgICAsIFwib3B0aW9uTGlzdE1hcmdpblRvcFwiOiAyNS8vLFwib3B0aW9uTGlzdE1hcmdpbkxlZnRcIjoyMTBcclxuICAgICAgICAgICAgLCBcImFkanVzdFBvc2l0aW9uQW5jaG9yXCI6IHRoaXMuRE9NLm9mZnNldCgpXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgcmlnaHRURC5hcHBlbmQoYVNlbGVjdE1lbnUucm93RE9NKSAgLy91c2Ugcm93RE9NIGluc3RlYWQgb2YgRE9NIHRvIGFsbG93IHNlbGVjdCBvcHRpb24gd2luZG93IGZsb2F0IGFib3ZlIGRpYWxvZ1xyXG4gICAgYVNlbGVjdE1lbnUuRE9NLmRhdGEoXCJwYXRoXCIsIG5ld1BhdGgpXHJcbiAgICB2YWx1ZUFyci5mb3JFYWNoKChvbmVPcHRpb24pID0+IHtcclxuICAgICAgICB2YXIgc3RyID0gb25lT3B0aW9uW1wiZGlzcGxheU5hbWVcIl0gfHwgb25lT3B0aW9uW1wiZW51bVZhbHVlXCJdXHJcbiAgICAgICAgYVNlbGVjdE1lbnUuYWRkT3B0aW9uKHN0cilcclxuICAgIH0pXHJcbiAgICBhU2VsZWN0TWVudS5jYWxsQmFja19jbGlja09wdGlvbiA9IChvcHRpb25UZXh0LCBvcHRpb25WYWx1ZSwgcmVhbE1vdXNlQ2xpY2spID0+IHtcclxuICAgICAgICBhU2VsZWN0TWVudS5jaGFuZ2VOYW1lKG9wdGlvblRleHQpXHJcbiAgICAgICAgaWYgKHJlYWxNb3VzZUNsaWNrKSB0aGlzLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlKGFTZWxlY3RNZW51LkRPTS5kYXRhKFwicGF0aFwiKSwgb3B0aW9uVmFsdWUsIFwic3RyaW5nXCIpXHJcbiAgICB9XHJcbiAgICB2YXIgdmFsID0gZ2xvYmFsQ2FjaGUuc2VhcmNoVmFsdWUob3JpZ2luRWxlbWVudEluZm8sIG5ld1BhdGgpXHJcbiAgICBpZiAodmFsICE9IG51bGwpIHtcclxuICAgICAgICBhU2VsZWN0TWVudS50cmlnZ2VyT3B0aW9uVmFsdWUodmFsKVxyXG4gICAgfVxyXG59XHJcblxyXG5uZXdUd2luRGlhbG9nLnByb3RvdHlwZS51cGRhdGVPcmlnaW5PYmplY3RWYWx1ZT1mdW5jdGlvbihwYXRoQXJyLG5ld1ZhbCxkYXRhVHlwZSl7XHJcbiAgICBpZihbXCJkb3VibGVcIixcImJvb2xlYW5cIixcImZsb2F0XCIsXCJpbnRlZ2VyXCIsXCJsb25nXCJdLmluY2x1ZGVzKGRhdGFUeXBlKSkgbmV3VmFsPU51bWJlcihuZXdWYWwpXHJcbiAgICBpZihwYXRoQXJyLmxlbmd0aD09MCkgcmV0dXJuO1xyXG4gICAgdmFyIHRoZUpzb249dGhpcy50d2luSW5mb1xyXG4gICAgZm9yKHZhciBpPTA7aTxwYXRoQXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBrZXk9cGF0aEFycltpXVxyXG5cclxuICAgICAgICBpZihpPT1wYXRoQXJyLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgdGhlSnNvbltrZXldPW5ld1ZhbFxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGVKc29uW2tleV09PW51bGwpIHRoZUpzb25ba2V5XT17fVxyXG4gICAgICAgIHRoZUpzb249dGhlSnNvbltrZXldXHJcbiAgICB9XHJcbn1cclxuXHJcbm5ld1R3aW5EaWFsb2cucHJvdG90eXBlLnRyZWVMaW5lRGl2ID0gZnVuY3Rpb24odHlwZU51bWJlcikge1xyXG4gICAgdmFyIHJlRGl2PSQoJzxkaXYgc3R5bGU9XCJtYXJnaW4tbGVmdDoxMHB4O3dpZHRoOjE1cHg7aGVpZ2h0OiAxMDAlO2Zsb2F0OiBsZWZ0XCI+PC9kaXY+JylcclxuICAgIGlmKHR5cGVOdW1iZXI9PTEpe1xyXG4gICAgICAgIHJlRGl2LmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwidzMtYm9yZGVyLWJvdHRvbSB3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PicpKVxyXG4gICAgfWVsc2UgaWYodHlwZU51bWJlcj09Mil7XHJcbiAgICAgICAgcmVEaXYuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJ3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ3My1ib3JkZXItbGVmdFwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAlO1wiPjwvZGl2PicpKVxyXG4gICAgfWVsc2UgaWYodHlwZU51bWJlcj09Myl7XHJcbiAgICAgICAgcmVEaXYuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJ3My1ib3JkZXItYm90dG9tIHczLWJvcmRlci1sZWZ0XCIgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDo1MCU7XCI+JykpXHJcbiAgICB9ZWxzZSBpZih0eXBlTnVtYmVyPT00KXtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIHJldHVybiByZURpdlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBuZXdUd2luRGlhbG9nKCk7IiwiY29uc3QgZ2xvYmFsQ2FjaGU9cmVxdWlyZShcIi4vZ2xvYmFsQ2FjaGVcIilcclxuY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBzaW1wbGVDb25maXJtRGlhbG9nID0gcmVxdWlyZShcIi4vc2ltcGxlQ29uZmlybURpYWxvZ1wiKVxyXG5cclxuZnVuY3Rpb24gcHJvamVjdFNldHRpbmdEaWFsb2coKSB7XHJcbiAgICBpZighdGhpcy5ET00pe1xyXG4gICAgICAgIHRoaXMuRE9NID0gJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtsZWZ0OjUwJTt0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTt6LWluZGV4OjEwMVwiIGNsYXNzPVwidzMtY2FyZC0yXCI+PC9kaXY+JylcclxuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICAgICAgdGhpcy5ET00uaGlkZSgpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUubWFrZURPTURyYWdnYWJsZSh0aGlzLkRPTSlcclxuICAgIH1cclxufVxyXG5cclxucHJvamVjdFNldHRpbmdEaWFsb2cucHJvdG90eXBlLnJ4TWVzc2FnZT1mdW5jdGlvbihtc2dQYXlsb2FkKXtcclxuICAgIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJwcm9qZWN0SXNDaGFuZ2VkXCIpe1xyXG4gICAgICAgIHRoaXMuY29udGVudEluaXRpYWxpemVkPWZhbHNlXHJcbiAgICAgICAgdGhpcy5ET00uZW1wdHkoKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgfVxyXG59XHJcblxyXG5wcm9qZWN0U2V0dGluZ0RpYWxvZy5wcm90b3R5cGUucG9wdXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLkRPTS5zaG93KClcclxuICAgIGlmKHRoaXMuY29udGVudEluaXRpYWxpemVkKXJldHVybjtcclxuICAgIHRoaXMuY29udGVudEluaXRpYWxpemVkPXRydWU7IFxyXG4gICAgdGhpcy5ET00uY3NzKHtcIndpZHRoXCI6XCI0MjBweFwiLFwicGFkZGluZy1ib3R0b21cIjpcIjNweFwifSlcclxuICAgIHRoaXMuRE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHg7bWFyZ2luLWJvdHRvbToycHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjJlbVwiPlNldHRpbmc8L2Rpdj48L2Rpdj4nKSlcclxuICAgIHZhciBjbG9zZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmlnaHRcIiBzdHlsZT1cImZvbnQtc2l6ZToyZW07cGFkZGluZy10b3A6NHB4XCI+w5c8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5ET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLkRPTS5oaWRlKCkgfSlcclxuXHJcbiAgICB2YXIgdGFiQ29udHJvbD0kKCc8ZGl2IGNsYXNzPVwidzMtYmFyIHczLWxpZ2h0LWdyYXlcIj48L2Rpdj4nKVxyXG4gICAgdmFyIGxheW91dEJ0bj0kKCc8YnV0dG9uIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uIFwiPkxheW91dDwvYnV0dG9uPicpXHJcbiAgICB2YXIgdmlzdWFsU2NoZW1hQnRuPSQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b25cIj5WaXN1YWwgU2NoZW1hPC9idXR0b24+JylcclxuICAgIHRhYkNvbnRyb2wuYXBwZW5kKGxheW91dEJ0bix2aXN1YWxTY2hlbWFCdG4pXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQodGFiQ29udHJvbClcclxuXHJcbiAgICB0aGlzLmxheW91dENvbnRlbnREaXY9JCgnPGRpdiBjbGFzcz1cInczLWFuaW1hdGUtb3BhY2l0eVwiIHN0eWxlPVwicGFkZGluZzoxMHB4O2Rpc3BsYXk6bm9uZVwiPjwvZGl2PicpXHJcbiAgICB0aGlzLnZpc3VhbFNjaGVtYUNvbnRlbnREaXY9JCgnPGRpdiBjbGFzcz1cInczLWFuaW1hdGUtb3BhY2l0eVwiIHN0eWxlPVwicGFkZGluZzoxMHB4O2Rpc3BsYXk6bm9uZVwiPjwvZGl2PicpXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQodGhpcy5sYXlvdXRDb250ZW50RGl2LHRoaXMudmlzdWFsU2NoZW1hQ29udGVudERpdilcclxuICAgIHRoaXMuZmlsbExheW91dERpdkNvbnRlbnQoKVxyXG4gICAgdGhpcy5maWxsVmlzdWFsU2NoZW1hQ29udGVudCgpXHJcblxyXG4gICAgbGF5b3V0QnRuLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIGxheW91dEJ0bi5hZGRDbGFzcyhcInczLXdoaXRlXCIpXHJcbiAgICAgICAgdmlzdWFsU2NoZW1hQnRuLnJlbW92ZUNsYXNzKFwidzMtd2hpdGVcIilcclxuICAgICAgICB0aGlzLnZpc3VhbFNjaGVtYUNvbnRlbnREaXYuaGlkZSgpXHJcbiAgICAgICAgdGhpcy5sYXlvdXRDb250ZW50RGl2LnNob3coKVxyXG4gICAgfSlcclxuXHJcbiAgICB2aXN1YWxTY2hlbWFCdG4ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgbGF5b3V0QnRuLnJlbW92ZUNsYXNzKFwidzMtd2hpdGVcIilcclxuICAgICAgICB2aXN1YWxTY2hlbWFCdG4uYWRkQ2xhc3MoXCJ3My13aGl0ZVwiKVxyXG4gICAgICAgIHRoaXMudmlzdWFsU2NoZW1hQ29udGVudERpdi5zaG93KClcclxuICAgICAgICB0aGlzLmxheW91dENvbnRlbnREaXYuaGlkZSgpXHJcbiAgICB9KVxyXG5cclxuICAgIGxheW91dEJ0bi50cmlnZ2VyKFwiY2xpY2tcIilcclxufVxyXG5cclxucHJvamVjdFNldHRpbmdEaWFsb2cucHJvdG90eXBlLmZpbGxMYXlvdXREaXZDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNob3dPdGhlclVzZXJMYXlvdXRDaGVjayA9ICQoJzxpbnB1dCBjbGFzcz1cInczLWNoZWNrXCIgc3R5bGU9XCJ3aWR0aDoyMHB4O21hcmdpbi1sZWZ0OjEwcHg7bWFyZ2luLXJpZ2h0OjEwcHhcIiB0eXBlPVwiY2hlY2tib3hcIj4nKVxyXG4gICAgdmFyIHNob3dPdGhlclVzZXJMYXlvdXRUZXh0ID0gJCgnPGxhYmVsIHN0eWxlPVwicGFkZGluZzoycHggOHB4O1wiPlNob3cgc2hhcmVkIGxheW91dHMgZnJvbSBvdGhlciB1c2VyczwvbGFiZWw+JylcclxuICAgIHRoaXMubGF5b3V0Q29udGVudERpdi5hcHBlbmQoc2hvd090aGVyVXNlckxheW91dENoZWNrLCBzaG93T3RoZXJVc2VyTGF5b3V0VGV4dClcclxuICAgIGlmKHRoaXMuc2hvd1NoYXJlZExheW91dHMpIHNob3dPdGhlclVzZXJMYXlvdXRDaGVjay5wcm9wKCBcImNoZWNrZWRcIiwgdHJ1ZSApO1xyXG4gICAgc2hvd090aGVyVXNlckxheW91dENoZWNrLm9uKFwiY2hhbmdlXCIsKCk9PntcclxuICAgICAgICB0aGlzLnNob3dTaGFyZWRMYXlvdXRzPXNob3dPdGhlclVzZXJMYXlvdXRDaGVjay5wcm9wKCdjaGVja2VkJylcclxuICAgICAgICB0aGlzLnJlZmlsbExheW91dHMoKVxyXG4gICAgfSlcclxuXHJcblxyXG4gICAgdmFyIGxheW91dHNEaXY9JCgnPGRpdiBjbGFzcz1cInczLWJvcmRlclwiIHN0eWxlPVwibWFyZ2luLXRvcDoxMHB4O21heC1oZWlnaHQ6MjAwcHg7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvXCI+PC9kaXY+JylcclxuICAgIHRoaXMubGF5b3V0Q29udGVudERpdi5hcHBlbmQobGF5b3V0c0RpdilcclxuICAgIHRoaXMubGF5b3V0c0Rpdj1sYXlvdXRzRGl2XHJcblxyXG4gICAgdGhpcy5yZWZpbGxMYXlvdXRzKClcclxufVxyXG5cclxuXHJcbnByb2plY3RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5maWxsVmlzdWFsU2NoZW1hQ29udGVudD0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNoYXJlU2VsZlZpc3VhbFNjaGVtYUNoZWNrID0gJCgnPGlucHV0IGNsYXNzPVwidzMtY2hlY2tcIiBzdHlsZT1cIndpZHRoOjIwcHg7bWFyZ2luLWxlZnQ6MTBweDttYXJnaW4tcmlnaHQ6MTBweFwiIHR5cGU9XCJjaGVja2JveFwiPicpXHJcbiAgICB2YXIgc2hhcmVTZWxmVmlzdWFsU2NoZW1hVGV4dCA9ICQoJzxsYWJlbCBzdHlsZT1cInBhZGRpbmc6MnB4IDhweDtcIj5TaGFyZSBteSBvd24gdmlzdWFsIGxlZ2VuZDwvbGFiZWw+JylcclxuICAgIHRoaXMudmlzdWFsU2NoZW1hQ29udGVudERpdi5hcHBlbmQoc2hhcmVTZWxmVmlzdWFsU2NoZW1hQ2hlY2ssIHNoYXJlU2VsZlZpc3VhbFNjaGVtYVRleHQpXHJcblxyXG4gICAgaWYoZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uaXNTaGFyZWQpIHNoYXJlU2VsZlZpc3VhbFNjaGVtYUNoZWNrLnByb3AoIFwiY2hlY2tlZFwiLCB0cnVlICk7XHJcbiAgICBcclxuICAgIHNoYXJlU2VsZlZpc3VhbFNjaGVtYUNoZWNrLm9uKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW1wiZGVmYXVsdFwiXS5pc1NoYXJlZD1zaGFyZVNlbGZWaXN1YWxTY2hlbWFDaGVjay5wcm9wKCdjaGVja2VkJylcclxuXHJcbiAgICAgICAgdmFyIHZpc3VhbFNjaGVtYU5hbWUgPSBcImRlZmF1bHRcIiAvL2ZpeGVkIGluIGN1cnJlbnQgdmVyc2lvbiwgdGhlcmUgaXMgb25seSBcImRlZmF1bHRcIiBzY2hlbWEgZm9yIGVhY2ggdXNlclxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NldFZpc3VhbFNjaGVtYVNoYXJlZEZsYWdcIiwgXCJQT1NUXCIsIHsgXCJ2aXN1YWxTY2hlbWFcIjogdmlzdWFsU2NoZW1hTmFtZSwgXCJpc1NoYXJlZFwiOiBzaGFyZVNlbGZWaXN1YWxTY2hlbWFDaGVjay5wcm9wKCdjaGVja2VkJykgfSwgXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZVRleHQpIGFsZXJ0KGUucmVzcG9uc2VUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgdmFyIHZpc3VhbFNjaGVtYURpdj0kKCc8ZGl2IGNsYXNzPVwidzMtYm9yZGVyXCIgc3R5bGU9XCJtYXJnaW4tdG9wOjEwcHg7bWF4LWhlaWdodDoyMDBweDtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG9cIj48L2Rpdj4nKVxyXG4gICAgdGhpcy52aXN1YWxTY2hlbWFDb250ZW50RGl2LmFwcGVuZCh2aXN1YWxTY2hlbWFEaXYpXHJcbiAgICB0aGlzLnZpc3VhbFNjaGVtYURpdj12aXN1YWxTY2hlbWFEaXZcclxuXHJcbiAgICB0aGlzLnJlZmlsbFZpc3VhbFNjaGVtYXMoKVxyXG59XHJcblxyXG5wcm9qZWN0U2V0dGluZ0RpYWxvZy5wcm90b3R5cGUucmVmaWxsVmlzdWFsU2NoZW1hcz1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy52aXN1YWxTY2hlbWFEaXYuZW1wdHkoKVxyXG4gICAgdmFyIHNlbGZTY2hlbWFcclxuICAgIGZvciAodmFyIGluZCBpbiBnbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIG9uZVNjaGVtYT1nbG9iYWxDYWNoZS52aXN1YWxEZWZpbml0aW9uW2luZF1cclxuICAgICAgICBpZihvbmVTY2hlbWEub3duZXIhPW51bGwgJiYgb25lU2NoZW1hLm93bmVyIT1nbG9iYWxDYWNoZS5hY2NvdW50SW5mby5pZCkgdGhpcy5hZGRPbmVWaXN1YWxTY2hlbWEob25lU2NoZW1hLHRoaXMudmlzdWFsU2NoZW1hRGl2KVxyXG4gICAgICAgIGVsc2Ugc2VsZlNjaGVtYT1vbmVTY2hlbWFcclxuICAgIH1cclxuICAgIHRoaXMuYWRkT25lVmlzdWFsU2NoZW1hKHNlbGZTY2hlbWEsdGhpcy52aXN1YWxTY2hlbWFEaXYpXHJcbn1cclxuXHJcbnByb2plY3RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5hZGRPbmVWaXN1YWxTY2hlbWE9ZnVuY3Rpb24ob25lU2NoZW1hT2JqLHBhcmVudERpdil7XHJcbiAgICB2YXIgb3duZXI9IG9uZVNjaGVtYU9iai5vd25lciB8fCBnbG9iYWxDYWNoZS5hY2NvdW50SW5mby5pZFxyXG4gICAgXHJcbiAgICB2YXIgb25lU2NoZW1hUm93PSQoJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXIgdzMtYnV0dG9uIHczLWJvcmRlci1ib3R0b21cIj48L2E+JylcclxuICAgIHBhcmVudERpdi5hcHBlbmQob25lU2NoZW1hUm93KVxyXG4gICAgdmFyIGxibFN0cj0ob3duZXI9PWdsb2JhbENhY2hlLmFjY291bnRJbmZvLmlkKT9cIlNlbGZcIjpcIlNoYXJlZCBieSBcIitvd25lclxyXG4gICAgLy92YXIgbmFtZUxibD0kKCc8YSBzdHlsZT1cInRleHQtYWxpZ246bGVmdDtjb2xvcjpncmV5O21hcmdpbjo1cHggMHB4O2Rpc3BsYXk6YmxvY2tcIj4nK2xibFN0cisnPC9hPicpXHJcbiAgICB2YXIgdGl0bGVSb3c9JCgnPGEgaHJlZj1cIiNcIiBjbGFzcz1cInczLWJhciB3My10ZXh0LWdyZXlcIiAgPjwvYT4nKVxyXG4gICAgb25lU2NoZW1hUm93LmFwcGVuZCh0aXRsZVJvdylcclxuICAgIHZhciBuYW1lTGJsPSQoJzxhIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uXCIgPicrbGJsU3RyKyc8L2E+JylcclxuICAgIHZhciBjb3B5QnRuPSQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJpZ2h0IHczLWxpbWUgdzMtaG92ZXItYW1iZXJcIj5Db3B5PC9idXR0b24+JylcclxuICAgIHRpdGxlUm93LmFwcGVuZChuYW1lTGJsKVxyXG4gICAgaWYob3duZXIhPWdsb2JhbENhY2hlLmFjY291bnRJbmZvLmlkKSB0aXRsZVJvdy5hcHBlbmQoY29weUJ0bilcclxuXHJcbiAgICB2YXIgZGV0YWlsPW9uZVNjaGVtYU9iai5kZXRhaWxcclxuXHJcbiAgICBjb3B5QnRuLm9uKFwiY2xpY2tcIiwgYXN5bmMgKCk9PntcclxuICAgICAgICAvL3JlcGxhY2Ugc2VsZiB2aXN1YWwgc2NoZW1hXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUudmlzdWFsRGVmaW5pdGlvbltcImRlZmF1bHRcIl0uZGV0YWlsPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGV0YWlsKSlcclxuICAgICAgICB0aGlzLnJlZmlsbFZpc3VhbFNjaGVtYXMoKVxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vc2F2ZVZpc3VhbERlZmluaXRpb25cIiwgXCJQT1NUXCIsIHtcInZpc3VhbERlZmluaXRpb25Kc29uXCI6SlNPTi5zdHJpbmdpZnkoZGV0YWlsKX0sXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBmb3IodmFyIG1vZGVsSUQgaW4gZGV0YWlsKXtcclxuICAgICAgICB2YXIgaWNvbkRPTT1nbG9iYWxDYWNoZS5nZW5lcmF0ZU1vZGVsSWNvbihtb2RlbElEKVxyXG4gICAgICAgIG9uZVNjaGVtYVJvdy5hcHBlbmQoaWNvbkRPTSlcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbnByb2plY3RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5yZWZpbGxMYXlvdXRzPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmxheW91dHNEaXYuZW1wdHkoKVxyXG4gICAgdmFyIHByb2plY3RJbmZvPWdsb2JhbENhY2hlLmZpbmRQcm9qZWN0SW5mbyhnbG9iYWxDYWNoZS5jdXJyZW50UHJvamVjdElEKVxyXG4gICAgdmFyIGRlZmF1bHRMYXlvdXROYW1lPXByb2plY3RJbmZvLmRlZmF1bHRMYXlvdXRcclxuXHJcbiAgICBpZih0aGlzLnNob3dTaGFyZWRMYXlvdXRzKXtcclxuICAgICAgICBmb3IgKHZhciBpbmQgaW4gZ2xvYmFsQ2FjaGUubGF5b3V0SlNPTikge1xyXG4gICAgICAgICAgICB2YXIgb25lTGF5b3V0T2JqPWdsb2JhbENhY2hlLmxheW91dEpTT05baW5kXVxyXG4gICAgICAgICAgICBpZihvbmVMYXlvdXRPYmoub3duZXIhPWdsb2JhbENhY2hlLmFjY291bnRJbmZvLmlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9uZUxheW91dEJhcihvbmVMYXlvdXRPYmosdGhpcy5sYXlvdXRzRGl2LGRlZmF1bHRMYXlvdXROYW1lKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaW5kIGluIGdsb2JhbENhY2hlLmxheW91dEpTT04pIHtcclxuICAgICAgICB2YXIgb25lTGF5b3V0T2JqPWdsb2JhbENhY2hlLmxheW91dEpTT05baW5kXVxyXG4gICAgICAgIGlmKG9uZUxheW91dE9iai5vd25lciE9Z2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uaWQpIGNvbnRpbnVlXHJcbiAgICAgICAgdGhpcy5hZGRPbmVMYXlvdXRCYXIob25lTGF5b3V0T2JqLHRoaXMubGF5b3V0c0RpdixkZWZhdWx0TGF5b3V0TmFtZSlcclxuICAgIH1cclxuICAgIFxyXG59XHJcblxyXG5wcm9qZWN0U2V0dGluZ0RpYWxvZy5wcm90b3R5cGUuYWRkT25lTGF5b3V0QmFyPWZ1bmN0aW9uKG9uZUxheW91dE9iaixwYXJlbnREaXYsZGVmYXVsdExheW91dE5hbWUpe1xyXG4gICAgdmFyIGxheW91dE5hbWUgPSBvbmVMYXlvdXRPYmoubmFtZVxyXG4gICAgdmFyIHNoYXJlZEZsYWcgPSBvbmVMYXlvdXRPYmouaXNTaGFyZWRcclxuXHJcbiAgICB2YXIgc2VsZkxheW91dD0ob25lTGF5b3V0T2JqLm93bmVyPT1nbG9iYWxDYWNoZS5hY2NvdW50SW5mby5pZClcclxuXHJcbiAgICB2YXIgb25lTGF5b3V0PSQoJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXIgdzMtYnV0dG9uIHczLWJvcmRlci1ib3R0b21cIj48L2E+JylcclxuICAgIHBhcmVudERpdi5hcHBlbmQob25lTGF5b3V0KVxyXG5cclxuICAgIHZhciBuYW1lTGJsPSQoJzxhIGNsYXNzPVwidzMtYmFyLWl0ZW0gdzMtYnV0dG9uXCIgaHJlZj1cIiNcIj4nK2xheW91dE5hbWUrJzwvYT4nKVxyXG4gICAgdmFyIGRlZmF1bHRMYmw9JChcIjxhIGNsYXNzPSd3My1iYXItaXRlbScgc3R5bGU9J2ZvbnQtc2l6ZTo5cHg7cGFkZGluZzoxcHggMnB4O21hcmdpbi10b3A6OXB4O2JvcmRlci1yYWRpdXM6IDJweDsnPjwvYT5cIilcclxuICAgIFxyXG4gICAgb25lTGF5b3V0LmRhdGEoXCJsYXlvdXRPYmpcIixvbmVMYXlvdXRPYmopXHJcblxyXG4gICAgb25lTGF5b3V0LmRhdGEoXCJkZWZhdWx0TGJsXCIsZGVmYXVsdExibClcclxuICAgIG9uZUxheW91dC5hcHBlbmQobmFtZUxibCxkZWZhdWx0TGJsKVxyXG5cclxuICAgIGlmKGxheW91dE5hbWUhPWRlZmF1bHRMYXlvdXROYW1lKSB0aGlzLnNob3dBc05vdERlZmF1bHRMYXlvdXRMYmwob25lTGF5b3V0KVxyXG4gICAgZWxzZSB0aGlzLnNob3dBc0RlZmF1bHRMYXlvdXRMYmwob25lTGF5b3V0KVxyXG5cclxuICAgIGlmKHNlbGZMYXlvdXQpe1xyXG4gICAgICAgIHZhciBzdHI9KHNoYXJlZEZsYWcpP1wiU2hhcmVkXCI6XCJTaGFyZVwiXHJcbiAgICAgICAgdmFyIHNoYXJlQnRuPSQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtYmFyLWl0ZW0gdzMtYnV0dG9uIHczLXJpZ2h0IHczLWhvdmVyLWFtYmVyXCI+JytzdHIrJzwvYnV0dG9uPicpXHJcbiAgICAgICAgb25lTGF5b3V0LmRhdGEoXCJzaGFyZUJ0blwiLHNoYXJlQnRuKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkZWxldGVCdG49JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodCB3My1ob3Zlci1hbWJlclwiPjxpIGNsYXNzPVwiZmEgZmEtdHJhc2ggZmEtbGdcIj48L2k+PC9idXR0b24+JylcclxuICAgICAgICBvbmVMYXlvdXQuYXBwZW5kKHNoYXJlQnRuLGRlbGV0ZUJ0bilcclxuICAgICAgICBpZighc2hhcmVkRmxhZykgc2hhcmVCdG4uaGlkZSgpXHJcbiAgICAgICAgZGVsZXRlQnRuLmhpZGUoKVxyXG4gICAgXHJcbiAgICAgICAgb25lTGF5b3V0LmhvdmVyKCgpPT57XHJcbiAgICAgICAgICAgIG9uZUxheW91dC5kYXRhKFwiZGVmYXVsdExibFwiKS5zaG93KClcclxuICAgICAgICAgICAgdmFyIGlzU2hhcmVkPW9uZUxheW91dC5kYXRhKFwibGF5b3V0T2JqXCIpLmlzU2hhcmVkXHJcbiAgICAgICAgICAgIGlmKCFpc1NoYXJlZCkgc2hhcmVCdG4uc2hvdygpXHJcbiAgICAgICAgICAgIGRlbGV0ZUJ0bi5zaG93KClcclxuICAgICAgICB9LCgpPT57XHJcbiAgICAgICAgICAgIGlmKCFvbmVMYXlvdXQuZGF0YShcImRlZmF1bHRMYmxcIikuaGFzQ2xhc3MoXCJ3My1saW1lXCIpKSBvbmVMYXlvdXQuZGF0YShcImRlZmF1bHRMYmxcIikuaGlkZSgpXHJcbiAgICAgICAgICAgIHZhciBpc1NoYXJlZD1vbmVMYXlvdXQuZGF0YShcImxheW91dE9ialwiKS5pc1NoYXJlZFxyXG4gICAgICAgICAgICBpZighaXNTaGFyZWQpIHNoYXJlQnRuLmhpZGUoKVxyXG4gICAgICAgICAgICBkZWxldGVCdG4uaGlkZSgpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBvbmVMYXlvdXQub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgICAgIHZhciBwcm9qZWN0SW5mbz1nbG9iYWxDYWNoZS5maW5kUHJvamVjdEluZm8oZ2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRClcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocHJvamVjdEluZm8uZGVmYXVsdExheW91dClcclxuICAgICAgICAgICAgaWYobGF5b3V0TmFtZSE9cHJvamVjdEluZm8uZGVmYXVsdExheW91dCkgdGhpcy5zZXRBc0RlZmF1bHRMYXlvdXQob25lTGF5b3V0KVxyXG4gICAgICAgICAgICBlbHNlIHRoaXMuc2V0QXNEZWZhdWx0TGF5b3V0KClcclxuICAgICAgICB9KVxyXG4gICAgICAgIGRlbGV0ZUJ0bi5vbihcImNsaWNrXCIsKCk9PntcclxuICAgICAgICAgICAgdGhpcy5kZWxldGVMYXlvdXQob25lTGF5b3V0KVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICB9KVxyXG4gICAgICAgIHNoYXJlQnRuLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLmNsaWNrU2hhcmVMYXlvdXRCdG4ob25lTGF5b3V0KVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICB9KSAgICBcclxuICAgIH1lbHNle1xyXG4gICAgICAgIG9uZUxheW91dC5hZGRDbGFzcyhcInczLWdyYXlcIixcInczLWhvdmVyLWdyYXlcIilcclxuICAgICAgICB2YXIgY29weUJ0bj0kKCc8YnV0dG9uIGNsYXNzPVwidzMtcmlwcGxlIHczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodCB3My1saW1lIHczLWhvdmVyLWFtYmVyXCI+Q29weTwvYnV0dG9uPicpXHJcbiAgICAgICAgb25lTGF5b3V0LmFwcGVuZChjb3B5QnRuKVxyXG4gICAgICAgIGNvcHlCdG4ub24oXCJjbGlja1wiLCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuY29weUxheW91dChvbmVMYXlvdXQuZGF0YShcImxheW91dE9ialwiKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSkgXHJcbiAgICB9ICAgIFxyXG59XHJcblxyXG5wcm9qZWN0U2V0dGluZ0RpYWxvZy5wcm90b3R5cGUuY29weUxheW91dD1hc3luYyBmdW5jdGlvbihkaWN0KXtcclxuICAgIHZhciBsYXlvdXREaWN0PWRpY3QuZGV0YWlsXHJcbiAgICBpZihsYXlvdXREaWN0W1wiZWRnZXNcIl09PW51bGwpIGxheW91dERpY3RbXCJlZGdlc1wiXT17fSAgICBcclxuICAgIHZhciBzYXZlTGF5b3V0T2JqPXtcImxheW91dHNcIjp7fX1cclxuICAgIHNhdmVMYXlvdXRPYmpbXCJsYXlvdXRzXCJdW2RpY3Qub25hbWVdPUpTT04uc3RyaW5naWZ5KGxheW91dERpY3QpICBcclxuXHJcbiAgICBnbG9iYWxDYWNoZS5yZWNvcmRTaW5nbGVMYXlvdXQobGF5b3V0RGljdCxnbG9iYWxDYWNoZS5hY2NvdW50SW5mby5pZCxkaWN0Lm9uYW1lLGZhbHNlKVxyXG4gICAgdHJ5e1xyXG4gICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NhdmVMYXlvdXRcIiwgXCJQT1NUXCIsIHNhdmVMYXlvdXRPYmosXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwibGF5b3V0c1VwZGF0ZWRcIn0pXHJcbiAgICAgICAgdGhpcy5yZWZpbGxMYXlvdXRzKClcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgIH1cclxufVxyXG5cclxucHJvamVjdFNldHRpbmdEaWFsb2cucHJvdG90eXBlLmNsaWNrU2hhcmVMYXlvdXRCdG49YXN5bmMgZnVuY3Rpb24ob25lTGF5b3V0RE9NKXtcclxuICAgIHZhciBpc1NoYXJlZD1vbmVMYXlvdXRET00uZGF0YShcImxheW91dE9ialwiKS5pc1NoYXJlZFxyXG4gICAgdmFyIHRoZUJ0bj1vbmVMYXlvdXRET00uZGF0YShcInNoYXJlQnRuXCIpXHJcbiAgICBpc1NoYXJlZD0haXNTaGFyZWRcclxuICAgIG9uZUxheW91dERPTS5kYXRhKFwibGF5b3V0T2JqXCIpLmlzU2hhcmVkPWlzU2hhcmVkXHJcbiAgICBpZighaXNTaGFyZWQpIHRoZUJ0bi50ZXh0KFwiU2hhcmVcIilcclxuICAgIGVsc2UgdGhlQnRuLnRleHQoXCJTaGFyZWRcIilcclxuICAgIFxyXG4gICAgdmFyIGxheW91dE5hbWU9b25lTGF5b3V0RE9NLmRhdGEoXCJsYXlvdXRPYmpcIikubmFtZSBcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vc2V0TGF5b3V0U2hhcmVkRmxhZ1wiLCBcIlBPU1RcIiwge1wibGF5b3V0XCI6bGF5b3V0TmFtZSxcImlzU2hhcmVkXCI6aXNTaGFyZWQgfSxcIndpdGhQcm9qZWN0SURcIilcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgIH0gXHJcbn1cclxuXHJcblxyXG5wcm9qZWN0U2V0dGluZ0RpYWxvZy5wcm90b3R5cGUuZGVsZXRlTGF5b3V0PWFzeW5jIGZ1bmN0aW9uKG9uZUxheW91dERPTSl7XHJcbiAgICB2YXIgbGF5b3V0TmFtZT1vbmVMYXlvdXRET00uZGF0YShcImxheW91dE9ialwiKS5uYW1lIFxyXG4gICAgdmFyIGNvbmZpcm1EaWFsb2dEaXY9bmV3IHNpbXBsZUNvbmZpcm1EaWFsb2coKVxyXG5cclxuICAgIGNvbmZpcm1EaWFsb2dEaXYuc2hvdyhcclxuICAgICAgICB7IHdpZHRoOiBcIjI1MHB4XCIgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRpdGxlOiBcIkNvbmZpcm1cIlxyXG4gICAgICAgICAgICAsIGNvbnRlbnQ6IFwiQ29uZmlybSBkZWxldGluZyBsYXlvdXQgXFxcIlwiICsgbGF5b3V0TmFtZSArIFwiXFxcIj9cIlxyXG4gICAgICAgICAgICAsIGJ1dHRvbnM6W1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQ2xhc3M6IFwidzMtcmVkIHczLWhvdmVyLXBpbmtcIiwgdGV4dDogXCJDb25maXJtXCIsIFwiY2xpY2tGdW5jXCI6IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbENhY2hlLmxheW91dEpTT05bbGF5b3V0TmFtZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dE5hbWUgPT0gZ2xvYmFsQ2FjaGUuY3VycmVudExheW91dE5hbWUpIGdsb2JhbENhY2hlLmN1cnJlbnRMYXlvdXROYW1lID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwibGF5b3V0c1VwZGF0ZWRcIn0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZUxheW91dERPTS5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9kZWxldGVMYXlvdXRcIiwgXCJQT1NUXCIsIHsgXCJsYXlvdXROYW1lXCI6IGxheW91dE5hbWUgfSxcIndpdGhQcm9qZWN0SURcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JDbGFzczogXCJ3My1ncmF5XCIsdGV4dDogXCJDYW5jZWxcIiwgXCJjbGlja0Z1bmNcIjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRGlhbG9nRGl2LmNsb3NlKClcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcbiAgICApXHJcbn1cclxuXHJcbnByb2plY3RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5zaG93QXNEZWZhdWx0TGF5b3V0TGJsPWFzeW5jIGZ1bmN0aW9uKG9uZUxheW91dERPTSl7XHJcbiAgICB2YXIgZGVmYXVsdExibD1vbmVMYXlvdXRET00uZGF0YShcImRlZmF1bHRMYmxcIilcclxuICAgIGRlZmF1bHRMYmwuc2hvdygpXHJcbiAgICBkZWZhdWx0TGJsLnRleHQoXCJEZWZhdWx0XCIpXHJcbiAgICBkZWZhdWx0TGJsLmFkZENsYXNzKFwidzMtbGltZVwiKVxyXG59XHJcblxyXG5wcm9qZWN0U2V0dGluZ0RpYWxvZy5wcm90b3R5cGUuc2hvd0FzTm90RGVmYXVsdExheW91dExibD1hc3luYyBmdW5jdGlvbihvbmVMYXlvdXRET00pe1xyXG4gICAgdmFyIGRlZmF1bHRMYmw9b25lTGF5b3V0RE9NLmRhdGEoXCJkZWZhdWx0TGJsXCIpXHJcbiAgICBkZWZhdWx0TGJsLmhpZGUoKVxyXG4gICAgZGVmYXVsdExibC50ZXh0KFwiU2V0IEFzIERlZmF1bHRcIilcclxuICAgIGRlZmF1bHRMYmwucmVtb3ZlQ2xhc3MoXCJ3My1saW1lXCIpXHJcbn1cclxuXHJcbnByb2plY3RTZXR0aW5nRGlhbG9nLnByb3RvdHlwZS5zZXRBc0RlZmF1bHRMYXlvdXQ9YXN5bmMgZnVuY3Rpb24ob25lTGF5b3V0RE9NKXtcclxuICAgIHRoaXMubGF5b3V0c0Rpdi5jaGlsZHJlbignYScpLmVhY2goKGluZGV4LGFMYXlvdXQpPT57XHJcbiAgICAgICAgdGhpcy5zaG93QXNOb3REZWZhdWx0TGF5b3V0TGJsKCQoYUxheW91dCkpXHJcbiAgICB9KVxyXG5cclxuICAgIGlmKG9uZUxheW91dERPTT09bnVsbCl7IC8vcmVtb3ZlIGRlZmF1bHQgbGF5b3V0XHJcbiAgICAgICAgdmFyIGxheW91dE5hbWU9XCJcIlxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5zaG93QXNEZWZhdWx0TGF5b3V0TGJsKCQob25lTGF5b3V0RE9NKSlcclxuICAgICAgICBsYXlvdXROYW1lPW9uZUxheW91dERPTS5kYXRhKFwibGF5b3V0T2JqXCIpLm5hbWUgXHJcbiAgICB9XHJcbiAgICAgICBcclxuICAgIHZhciBwcm9qZWN0SW5mbz1nbG9iYWxDYWNoZS5maW5kUHJvamVjdEluZm8oZ2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRClcclxuICAgIHByb2plY3RJbmZvLmRlZmF1bHRMYXlvdXQ9bGF5b3V0TmFtZVxyXG4gICAgLy91cGRhdGUgZGF0YWJhc2VcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiYWNjb3VudE1hbmFnZW1lbnQvc2V0UHJvamVjdERlZmF1bHRMYXlvdXRcIiwgXCJQT1NUXCIsIHtcImRlZmF1bHRMYXlvdXRcIjpsYXlvdXROYW1lIH0sXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICBpZihlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICB9IFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBwcm9qZWN0U2V0dGluZ0RpYWxvZygpOyIsImNvbnN0IGdsb2JhbENhY2hlID0gcmVxdWlyZShcIi4vZ2xvYmFsQ2FjaGVcIilcclxuY29uc3QgbW9kZWxBbmFseXplciA9IHJlcXVpcmUoXCIuL21vZGVsQW5hbHl6ZXJcIik7XHJcblxyXG5mdW5jdGlvbiBzY3JpcHRUZXN0RGlhbG9nKCkge1xyXG4gICAgaWYoIXRoaXMuRE9NKXtcclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2JhY2tncm91bmQtY29sb3I6d2hpdGU7bGVmdDo1MCU7dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDoxMDBcIiBjbGFzcz1cInczLWNhcmQtMlwiPjwvZGl2PicpXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmhpZGUoKVxyXG4gICAgICAgIGdsb2JhbENhY2hlLm1ha2VET01EcmFnZ2FibGUodGhpcy5ET00pXHJcbiAgICB9XHJcbn1cclxuXHJcbnNjcmlwdFRlc3REaWFsb2cucHJvdG90eXBlLnBvcHVwID0gYXN5bmMgZnVuY3Rpb24oaW5wdXRzQXJyLHR3aW5OYW1lLGZvcm11bGFUd2luTW9kZWwsdmFsdWVUZW1wbGF0ZSkge1xyXG4gICAgdGhpcy5zY3JpcHRDb250ZW50PVwiXCJcclxuICAgIHRoaXMuc2VsZlR3aW5OYW1lPXR3aW5OYW1lXHJcbiAgICB0aGlzLnZhbHVlVGVtcGxhdGU9dmFsdWVUZW1wbGF0ZVxyXG4gICAgdGhpcy5ET00uc2hvdygpXHJcbiAgICB0aGlzLkRPTS5lbXB0eSgpXHJcbiAgICBcclxuICAgIHRoaXMuRE9NLmFwcGVuZCgkKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjVlbVwiPlR3aW4gRGF0YSBQcm9jZXNzaW5nIFRlc3RmbGlnaHQ8L2Rpdj48L2Rpdj4nKSlcclxuICAgIHZhciBjbG9zZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmlnaHRcIiBzdHlsZT1cImZvbnQtc2l6ZToyZW07cGFkZGluZy10b3A6NHB4XCI+w5c8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5ET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLkRPTS5oaWRlKCkgfSlcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRET00gPSAkKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyXCIgc3R5bGU9XCJ3aWR0aDo0MjBweDtmb250LXNpemU6MS4yZW1cIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKHRoaXMuY29udGVudERPTSlcclxuXHJcbiAgICB2YXIgdHdpbk5hbWVMYmw9dGhpcy5nZW5lcmF0ZU5hbWVMYWJlbChcIlR3aW4gTmFtZVwiLFwiMTBweFwiKVxyXG4gICAgdHdpbk5hbWVMYmwuYXBwZW5kKCQoJzxsYWJlbCBjbGFzcz1cInczLXRleHQtZ3JheVwiPicrdHdpbk5hbWUrJzwvbGFiZWw+JykpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKHR3aW5OYW1lTGJsKVxyXG5cclxuICAgIHZhciB0d2luTmFtZUxibD10aGlzLmdlbmVyYXRlTmFtZUxhYmVsKFwiTW9kZWxcIixcIjEwcHhcIilcclxuICAgIHR3aW5OYW1lTGJsLmFwcGVuZCgkKCc8bGFiZWwgY2xhc3M9XCJ3My10ZXh0LWdyYXlcIj4nK2Zvcm11bGFUd2luTW9kZWwrJzwvbGFiZWw+JykpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKHR3aW5OYW1lTGJsKVxyXG5cclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQodGhpcy5nZW5lcmF0ZU5hbWVMYWJlbChcIklucHV0c1wiLFwiMTBweFwiKSlcclxuICAgIFxyXG4gICAgdmFyIGFUYWJsZT0kKCc8dGFibGUgY2xhc3M9XCJ3My10ZXh0LWdyYXlcIiBzdHlsZT1cImJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7Zm9udC1zaXplOi44ZW07d2lkdGg6MTAwJVwiPjwvdGFibGU+JylcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQoYVRhYmxlKVxyXG4gICAgYVRhYmxlLmFwcGVuZCgkKCc8dHI+PHRkIGNsYXNzPVwidzMtbGlnaHQtZ3JheSB3My1ib3JkZXJcIj48L3RkPjx0ZCBjbGFzcz1cInczLWxpZ2h0LWdyYXkgdzMtYm9yZGVyXCIgc3R5bGU9XCJmb250LXdlaWdodDpib2xkO3RleHQtYWxpZ246Y2VudGVyXCI+VHdpbjwvdGQ+PHRkIGNsYXNzPVwidzMtbGlnaHQtZ3JheSB3My1ib3JkZXJcIiBzdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGQ7dGV4dC1hbGlnbjpjZW50ZXJcIj5Qcm9wZXJ0eSBQYXRoPC90ZD48dGQgY2xhc3M9XCJ3My1saWdodC1ncmF5IHczLWJvcmRlclwiIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZDt0ZXh0LWFsaWduOmNlbnRlclwiPlZhbHVlPC90ZD48L3RyPicpKVxyXG5cclxuICAgIHZhciB2YWx1ZUVkaXRvckFycj1bXVxyXG4gICAgaW5wdXRzQXJyLmZvckVhY2gob25lUHJvcGVydHk9PntcclxuICAgICAgICB2YXIgdHI9JCgnPHRyPjwvdHI+JylcclxuICAgICAgICB2YXIgdGQwPSQoJzx0ZCBjbGFzcz1cInczLWJvcmRlclwiIHN0eWxlPVwicGFkZGluZzowcHggMTBweFwiPjxpIGNsYXNzPVwiZmFzIGZhLXVubG9ja1wiPjwvaT48L3RkPicpXHJcbiAgICAgICAgdmFyIHRkMT0kKCc8dGQgY2xhc3M9XCJ3My1saWdodC1ncmF5IHczLWJvcmRlclwiIHN0eWxlPVwicGFkZGluZzowcHggMTBweFwiPicrb25lUHJvcGVydHkudHdpbk5hbWUrJzwvdGQ+JylcclxuICAgICAgICB2YXIgdGQyPSQoJzx0ZCBjbGFzcz1cInczLWxpZ2h0LWdyYXkgdzMtYm9yZGVyXCIgc3R5bGU9XCJwYWRkaW5nOjBweCAxMHB4XCI+JytvbmVQcm9wZXJ0eS5wYXRoKyc8L3RkPicpXHJcbiAgICAgICAgdmFyIHRkMz0kKCc8dGQgY2xhc3M9XCJ3My1ib3JkZXJcIiBzdHlsZT1cInBhZGRpbmc6MHB4IDEwcHhcIj48L3RkPicpXHJcbiAgICAgICAgdmFyIHZhbHVlVHlwZT10aGlzLmZpbmRQcm9wZXJ0eVR5cGUob25lUHJvcGVydHkudHdpbk5hbWVfb3JpZ2luLG9uZVByb3BlcnR5LnBhdGgpXHJcbiAgICAgICAgdmFyIHZhbHVlRWRpdD0kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT1cIm91dGxpbmU6bm9uZTtib3JkZXI6bm9uZTtwYWRkaW5nOjVweCAwcHg7d2lkdGg6MTAwJVwiICBwbGFjZWhvbGRlcj1cInR5cGU6ICcgK3ZhbHVlVHlwZSArICdcIi8+Jyk7XHJcbiAgICAgICAgdGQwLmNoaWxkcmVuKCc6Zmlyc3QnKS5vbihcImNsaWNrXCIsKGUpPT57XHJcbiAgICAgICAgICAgIHZhciBsb2NrRG9tPSQoZS50YXJnZXQpXHJcbiAgICAgICAgICAgIGlmKGxvY2tEb20uaGFzQ2xhc3MoXCJmYS11bmxvY2tcIikpe2xvY2tEb20ucmVtb3ZlQ2xhc3MoXCJmYS11bmxvY2tcIik7bG9ja0RvbS5hZGRDbGFzcyhcImZhLWxvY2tcIik7bG9ja0RvbS5hZGRDbGFzcyhcInczLXRleHQtYW1iZXJcIil9XHJcbiAgICAgICAgICAgIGVsc2Uge2xvY2tEb20ucmVtb3ZlQ2xhc3MoXCJmYS1sb2NrXCIpO2xvY2tEb20uYWRkQ2xhc3MoXCJmYS11bmxvY2tcIik7bG9ja0RvbS5yZW1vdmVDbGFzcyhcInczLXRleHQtYW1iZXJcIil9XHJcbiAgICAgICAgfSlcclxuICAgICAgICB2YWx1ZUVkaXRvckFyci5wdXNoKHtcInR5cGVcIjp2YWx1ZVR5cGUsXCJlZGl0b3JcIjp2YWx1ZUVkaXQsXCJsb2NrSWNvblwiOnRkMC5jaGlsZHJlbignOmZpcnN0JylcclxuICAgICAgICAgICAgLFwidHdpbk5hbWVcIjpvbmVQcm9wZXJ0eS50d2luTmFtZV9vcmlnaW5cclxuICAgICAgICAgICAgLFwiaW5wdXRQYXRoXCI6b25lUHJvcGVydHkucGF0aFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgYVRhYmxlLmFwcGVuZCh0ci5hcHBlbmQodGQwLHRkMSx0ZDIsdGQzKSlcclxuICAgICAgICB0ZDMuYXBwZW5kKHZhbHVlRWRpdClcclxuICAgIH0pXHJcblxyXG4gICAgdmFyIHJhbmRvbUlucHV0QnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1jYXJkIHczLW1hcmdpbi1yaWdodCB3My1saWdodC1ncmF5IHczLWJ1dHRvbiB3My1ob3Zlci1waW5rIHczLW1hcmdpbi10b3AgdzMtbWFyZ2luLWJvdHRvbVwiPkdlbmVyYXRlIFJhbmRvbSBJbnB1dCAmIEV4ZWN1dGU8L2J1dHRvbj4nKVxyXG5cclxuICAgIHJhbmRvbUlucHV0QnRuLm9uKFwiY2xpY2tcIiwoKT0+e1xyXG4gICAgICAgIHZhbHVlRWRpdG9yQXJyLmZvckVhY2goZWxlPT57XHJcbiAgICAgICAgICAgIGlmKGVsZS5sb2NrSWNvbi5oYXNDbGFzcyhcImZhLWxvY2tcIikpIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIGRhdGFUeXBlPWVsZS50eXBlXHJcbiAgICAgICAgICAgIHZhciB0aGVFZGl0b3I9ZWxlLmVkaXRvclxyXG4gICAgICAgICAgICB0aGVFZGl0b3IudmFsKHRoaXMuZ2VuZXJhdGVSYW5kb21WYWx1ZShkYXRhVHlwZSkpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9kbyBleGVjdXRlIGF1dG9tYXRpY2FsbHlcclxuICAgICAgICB0aGlzLnRlc3RGbGlnaHQodmFsdWVFZGl0b3JBcnIpXHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICB2YXIgZXhlY3V0ZVNjcmlwdEJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1yaXBwbGUgdzMtY2FyZCB3My1idXR0b24gdzMtYW1iZXIgdzMtaG92ZXItcGluayB3My1tYXJnaW4tdG9wIHczLW1hcmdpbi1ib3R0b21cIj5FeGVjdXRlPC9idXR0b24+JylcclxuICAgIGV4ZWN1dGVTY3JpcHRCdG4ub24oXCJjbGlja1wiLCgpPT57dGhpcy50ZXN0RmxpZ2h0KHZhbHVlRWRpdG9yQXJyKX0pXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKHJhbmRvbUlucHV0QnRuLGV4ZWN1dGVTY3JpcHRCdG4pXHJcblxyXG4gICAgdmFyIGxibDE9JCgnPGxhYmVsIGNsYXNzPVwidzMtdGV4dC1hbWJlclwiIHN0eWxlPVwiZm9udC1zdHlsZTogaXRhbGljO2ZvbnQtc2l6ZToxMXB4O2Rpc3BsYXk6YmxvY2tcIj5Zb3UgY2FuIHN0aWxsIGNoYW5nZSB0aGUgY2FsY3VsYXRpb24gc2NyaXB0IGluIHRoZSBpbmZvbXJhdGlvbiBwYW5lbCBhbmQgdGVzdCB0aGUgbW9kaWZpZWQgc2NyaXB0IGltbWVkaWF0ZWx5PC9sYWJlbD4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZChsYmwxKVxyXG5cclxuICAgIHZhciByZXN1bHREaXY9JCgnPGRpdiBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjE0MHB4O3BhZGRpbmc6NXB4XCIvPicpLmFkZENsYXNzKFwidzMtbGlnaHQtZ3JheSB3My10ZXh0LWdyYXkgdzMtYm9yZGVyIHczLW1hcmdpbi1ib3R0b21cIik7XHJcbiAgICByZXN1bHREaXYudGV4dChcIkNhbGN1bGF0aW9uIHJlc3VsdC4uLlwiKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZChyZXN1bHREaXYpXHJcbiAgICB0aGlzLnJlc3VsdERpdj1yZXN1bHREaXZcclxufVxyXG5cclxuc2NyaXB0VGVzdERpYWxvZy5wcm90b3R5cGUudGVzdEZsaWdodD1mdW5jdGlvbih2YWx1ZUVkaXRvckFycil7XHJcbiAgICB2YXIgX3NlbGY9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlVGVtcGxhdGUpKVxyXG4gICAgdmFyIF90d2luVmFsPXt9XHJcbiAgICBcclxuICAgIHZhbHVlRWRpdG9yQXJyLmZvckVhY2goZWxlPT57XHJcbiAgICAgICAgdmFyIG9iaj1udWxsXHJcbiAgICAgICAgaWYoZWxlLnR3aW5OYW1lIT10aGlzLnNlbGZUd2luTmFtZSl7XHJcbiAgICAgICAgICAgIF90d2luVmFsW2VsZS50d2luTmFtZV09e31cclxuICAgICAgICAgICAgb2JqPV90d2luVmFsW2VsZS50d2luTmFtZV1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgb2JqPV9zZWxmXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb290T2JqPW9ialxyXG4gICAgICAgIGZvcih2YXIgaT0wO2k8ZWxlLmlucHV0UGF0aC5sZW5ndGgtMTtpKyspe1xyXG4gICAgICAgICAgICB2YXIgcG5hbWU9ZWxlLmlucHV0UGF0aFtpXVxyXG4gICAgICAgICAgICBpZihyb290T2JqW3BuYW1lXT09bnVsbCkgcm9vdE9ialtwbmFtZV09e31cclxuICAgICAgICAgICAgcm9vdE9iaj1yb290T2JqW3BuYW1lXVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luVmFsPWVsZS5lZGl0b3IudmFsKClcclxuICAgICAgICBpZihlbGUudHlwZT09XCJib29sZWFuXCIpIHZhciB0aGVWYWw9IChvcmlnaW5WYWwgPT09ICd0cnVlJylcclxuICAgICAgICBlbHNlIGlmKGVsZS50eXBlPT1cImRvdWJsZVwifHxlbGUudHlwZT09XCJmbG9hdFwifHxlbGUudHlwZT09XCJpbnRlZ2VyXCJ8fGVsZS50eXBlPT1cImxvbmdcIikgdGhlVmFsPXBhcnNlRmxvYXQob3JpZ2luVmFsKVxyXG4gICAgICAgIGVsc2UgdGhlVmFsPW9yaWdpblZhbFxyXG4gICAgICAgIHJvb3RPYmpbZWxlLmlucHV0UGF0aFtlbGUuaW5wdXRQYXRoLmxlbmd0aC0xXV09dGhlVmFsXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMucmVzdWx0RGl2LmVtcHR5KClcclxuICAgIHRyeXtcclxuICAgICAgICB2YXIgZXZhbFN0cj10aGlzLnNjcmlwdENvbnRlbnQrXCJcXG5fc2VsZlwiXHJcbiAgICAgICAgdmFyIHJlc3VsdD1ldmFsKGV2YWxTdHIpIC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgIHRoaXMucmVzdWx0RGl2LmFwcGVuZCgkKCc8cHJlIHN0eWxlPVwibWFyZ2luOjBweDtmb250LXNpemU6MTFweFwiIGlkPVwianNvblwiPicrSlNPTi5zdHJpbmdpZnkocmVzdWx0LG51bGwsMikrJzwvcHJlPicpKSBcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICB0aGlzLnJlc3VsdERpdi5hcHBlbmQoJCgnPHByZSBzdHlsZT1cIm1hcmdpbjowcHg7Zm9udC1zaXplOjExcHhcIiBpZD1cImpzb25cIj4nK2UrJzwvcHJlPicpKVxyXG4gICAgfVxyXG59XHJcblxyXG5zY3JpcHRUZXN0RGlhbG9nLnByb3RvdHlwZS5nZW5lcmF0ZVJhbmRvbVZhbHVlPWZ1bmN0aW9uKGRhdGFUeXBlKXtcclxuICAgIHZhciByYW5kRGF0YT1NYXRoLnJhbmRvbSgpXHJcbiAgICBpZihkYXRhVHlwZT09XCJib29sZWFuXCIpe1xyXG4gICAgICAgIHJldHVybiAocmFuZERhdGE+MC41KVxyXG4gICAgfWVsc2UgaWYoZGF0YVR5cGU9PVwiZGF0ZVRpbWVcIil7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfWVsc2UgaWYoZGF0YVR5cGU9PVwiZGF0ZVwiKXtcclxuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSkuc3BsaXQoXCJUXCIpWzBdXHJcbiAgICB9ZWxzZSBpZihkYXRhVHlwZT09XCJ0aW1lXCIpe1xyXG4gICAgICAgIHJldHVybiAoXCJUXCIrKChuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpLnNwbGl0KFwiVFwiKVsxXSkpXHJcbiAgICB9ZWxzZSBpZihkYXRhVHlwZT09XCJkb3VibGVcIiB8fCBkYXRhVHlwZT09XCJmbG9hdFwiKXtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgocmFuZERhdGEqMTAwKS50b0ZpeGVkKDEpKVxyXG4gICAgfWVsc2UgaWYoZGF0YVR5cGU9PVwiaW50ZWdlclwiIHx8IGRhdGFUeXBlPT1cImxvbmdcIil7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJhbmREYXRhKjEwMClcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbn1cclxuXHJcbnNjcmlwdFRlc3REaWFsb2cucHJvdG90eXBlLmZpbmRQcm9wZXJ0eVR5cGU9ZnVuY3Rpb24odHdpbk5hbWUscHJvcGVydHlQYXRoKXtcclxuICAgIHZhciBkYnR3aW49Z2xvYmFsQ2FjaGUuZ2V0U2luZ2xlREJUd2luQnlOYW1lKHR3aW5OYW1lKVxyXG4gICAgdmFyIG1vZGVsSUQ9ZGJ0d2luW1wibW9kZWxJRFwiXVxyXG4gICAgdmFyIGVkaXRhYmxlUHJvcGVydGllcz1tb2RlbEFuYWx5emVyLkRURExNb2RlbHNbbW9kZWxJRF0uZWRpdGFibGVQcm9wZXJ0aWVzXHJcbiAgICB2YXIgdGhlVHlwZT1lZGl0YWJsZVByb3BlcnRpZXNcclxuICAgIGZvcih2YXIgaT0wO2k8cHJvcGVydHlQYXRoLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBlbGU9cHJvcGVydHlQYXRoW2ldXHJcbiAgICAgICAgaWYodGhlVHlwZVtlbGVdKSB0aGVUeXBlPXRoZVR5cGVbZWxlXVxyXG4gICAgICAgIGVsc2UgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICAgIHJldHVybiB0aGVUeXBlXHJcbn1cclxuXHJcblxyXG5zY3JpcHRUZXN0RGlhbG9nLnByb3RvdHlwZS5nZW5lcmF0ZU5hbWVMYWJlbD1mdW5jdGlvbihzdHIscGFkZGluZ1RvcCl7XHJcbiAgICB2YXIga2V5RGl2ID0gJChcIjxkaXY+PGRpdiBjbGFzcz0ndzMtYm9yZGVyJyBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjojZjZmNmY2O2Rpc3BsYXk6aW5saW5lO3BhZGRpbmc6LjFlbSAuM2VtIC4xZW0gLjNlbTttYXJnaW4tcmlnaHQ6LjNlbSc+XCIrc3RyK1wiPC9kaXY+PC9kaXY+XCIpXHJcbiAgICBrZXlEaXYuY3NzKFwicGFkZGluZy10b3BcIixwYWRkaW5nVG9wKVxyXG4gICAgcmV0dXJuIGtleURpdlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBzY3JpcHRUZXN0RGlhbG9nKCk7IiwiY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBnbG9iYWxDYWNoZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWRTb3VyY2VGaWxlcy9nbG9iYWxDYWNoZVwiKTtcclxuXHJcbmZ1bmN0aW9uIHNlcnZpY2VXb3JrZXJIZWxwZXIoKXtcclxuICAgIHRoaXMucHJvamVjdElEPW51bGxcclxuICAgIHRoaXMuYWxsTGl2ZU1vbml0b3I9e31cclxuICAgIHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgaWYodGhpcy5wcm9qZWN0SUQ9PW51bGwpIHJldHVybjtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZUltcG9ydGFudEV2ZW50KHRoaXMucHJvamVjdElEKVxyXG5cclxuICAgICAgICBmb3IodmFyIGluZCBpbiB0aGlzLmFsbExpdmVNb25pdG9yKXtcclxuICAgICAgICAgICAgdmFyIGFMaXZlUHJvcGVydHk9dGhpcy5hbGxMaXZlTW9uaXRvcltpbmRdXHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlTGl2ZVByb3BlcnR5KGFMaXZlUHJvcGVydHkudHdpbklELGFMaXZlUHJvcGVydHkucHJvcGVydHlQYXRoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LDgqNjAqMTAwMCkgLy9ldmVyeSA4IG1pbnV0ZSByZW5ldyB0aGUgc2VydmljZSB3b3JrZXIgc3Vic2NyaXB0aW9uXHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnN1YnNjcmliZUltcG9ydGFudEV2ZW50ID0gYXN5bmMgZnVuY3Rpb24gKHByb2plY3RJRCkgeyAgICBcclxuICAgIHZhciBzdWJzY3JpcHRpb249YXdhaXQgdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oKVxyXG4gICAgaWYoc3Vic2NyaXB0aW9uPT1udWxsKSByZXR1cm47XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBwYXlsb2FkPXtcclxuICAgICAgICAgICAgdHlwZTonZXZlbnRzJyxcclxuICAgICAgICAgICAgc2VydmljZVdvcmtlclN1YnNjcmlwdGlvbjpKU09OLnN0cmluZ2lmeShzdWJzY3JpcHRpb24pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NlcnZpY2VXb3JrZXJTdWJzY3JpcHRpb25cIiwgXCJQT1NUXCIsIHBheWxvYWQsIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICB9XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnN1YnNjcmliZUxpdmVQcm9wZXJ0eSA9IGFzeW5jIGZ1bmN0aW9uICh0d2luSUQscHJvcGVydHlQYXRoKSB7ICAgIFxyXG4gICAgdmFyIHN1YnNjcmlwdGlvbj1hd2FpdCB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbigpXHJcbiAgICBpZihzdWJzY3JpcHRpb249PW51bGwpIHJldHVybjtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHBheWxvYWQ9e1xyXG4gICAgICAgICAgICB0eXBlOidwcm9wZXJ0eVZhbHVlJyxcclxuICAgICAgICAgICAgc2VydmljZVdvcmtlclN1YnNjcmlwdGlvbjpKU09OLnN0cmluZ2lmeShzdWJzY3JpcHRpb24pLFxyXG4gICAgICAgICAgICB0d2luSUQ6dHdpbklELFxyXG4gICAgICAgICAgICBwcm9wZXJ0eVBhdGg6cHJvcGVydHlQYXRoXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL3NlcnZpY2VXb3JrZXJTdWJzY3JpcHRpb25cIiwgXCJQT1NUXCIsIHBheWxvYWQsIFwid2l0aFByb2plY3RJRFwiKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpIFxyXG4gICAgfVxyXG59XHJcblxyXG5zZXJ2aWNlV29ya2VySGVscGVyLnByb3RvdHlwZS51bnN1YnNjcmliZUxpdmVQcm9wZXJ0eSA9IGFzeW5jIGZ1bmN0aW9uICh0d2luSUQscHJvcGVydHlQYXRoKSB7ICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBtc2FsSGVscGVyLmNhbGxBUEkoXCJkaWdpdGFsdHdpbi9zZXJ2aWNlV29ya2VyVW5zdWJzY3JpcHRpb25cIiwgXCJQT1NUXCIsIHt0d2luSUQ6dHdpbklELHByb3BlcnR5UGF0aDpwcm9wZXJ0eVBhdGh9LCBcIndpdGhQcm9qZWN0SURcIilcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgfVxyXG59XHJcblxyXG5zZXJ2aWNlV29ya2VySGVscGVyLnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoISgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSkgcmV0dXJuIG51bGw7XHJcbiAgICAvL3RoaXMgcHVibGljIGtleSBzaG91bGQgYmUgdGhlIG9uZSB1c2VkIGluIGJhY2tlbmQgc2VydmVyIHNpZGUgZm9yIHB1c2hpbmcgbWVzc2FnZSAoaW4gYXp1cmVpb3Ryb2Nrc2Z1bmN0aW9uKVxyXG4gICAgY29uc3QgcHVibGljVmFwaWRLZXkgPSAnQkN4dkZxazBjeklrQ1RibEFNeTgwZk1XVGoyV2FBa2VYQ3lwOTgtUzJNaVZyVEw1OXUwNDZlTFJyVEJJbW85WkNXQVEzWXFqXzdQd0VPdXloRG1DLVdZJztcclxuICAgIHZhciBzdWJzY3JpcHRpb24gPSBudWxsXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCcvd29ya2VyLmpzJywgeyBzY29wZTogJy8nIH0pO1xyXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IGF3YWl0IHJlZ2lzdHJhdGlvbi5wdXNoTWFuYWdlci5zdWJzY3JpYmUoe1xyXG4gICAgICAgICAgICB1c2VyVmlzaWJsZU9ubHk6IHRydWUsXHJcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uU2VydmVyS2V5OiBwdWJsaWNWYXBpZEtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLm9ubWVzc2FnZSA9IChlKT0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGl2ZU1lc3NhZ2UoZS5kYXRhKVxyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJsaXZlRGF0YVwiLFwiYm9keVwiOmUuZGF0YSB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgIH1cclxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnByb2Nlc3NMaXZlTWVzc2FnZT1mdW5jdGlvbihtc2dCb2R5KXtcclxuICAgIC8vY29uc29sZS5sb2cobXNnQm9keSlcclxuICAgIGlmKG1zZ0JvZHkuY29ubmVjdGlvblN0YXRlICYmIG1zZ0JvZHkucHJvamVjdElEPT1nbG9iYWxDYWNoZS5jdXJyZW50UHJvamVjdElEKXtcclxuICAgICAgICB2YXIgdHdpbklEPW1zZ0JvZHkudHdpbklEXHJcbiAgICAgICAgdmFyIHR3aW5EQkluZm89Z2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICAgICAgaWYobXNnQm9keS5jb25uZWN0aW9uU3RhdGU9PVwiZGV2aWNlQ29ubmVjdGVkXCIpIHR3aW5EQkluZm8uY29ubmVjdFN0YXRlPXRydWVcclxuICAgICAgICBlbHNlIHR3aW5EQkluZm8uY29ubmVjdFN0YXRlPWZhbHNlXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhtc2dCb2R5KVxyXG4gICAgfWVsc2UgaWYobXNnQm9keS5wcm9wZXJ0eVBhdGgpe1xyXG4gICAgICAgIHZhciB0d2luSW5mbz1nbG9iYWxDYWNoZS5zdG9yZWRUd2luc1ttc2dCb2R5LnR3aW5JRF1cclxuICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlKHR3aW5JbmZvLG1zZ0JvZHkucHJvcGVydHlQYXRoLG1zZ0JvZHkudmFsdWUpXHJcbiAgICB9XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnVwZGF0ZU9yaWdpbk9iamVjdFZhbHVlPWZ1bmN0aW9uKG5vZGVJbmZvLCBwYXRoQXJyLCBuZXdWYWwpIHtcclxuICAgIGlmIChwYXRoQXJyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICB2YXIgdGhlSnNvbiA9IG5vZGVJbmZvXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gcGF0aEFycltpXVxyXG5cclxuICAgICAgICBpZiAoaSA9PSBwYXRoQXJyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgdGhlSnNvbltrZXldID0gbmV3VmFsXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGVKc29uW2tleV0gPT0gbnVsbCkgdGhlSnNvbltrZXldID0ge31cclxuICAgICAgICB0aGVKc29uID0gdGhlSnNvbltrZXldXHJcbiAgICB9XHJcbn1cclxuXHJcbnNlcnZpY2VXb3JrZXJIZWxwZXIucHJvdG90eXBlLnJ4TWVzc2FnZT1mdW5jdGlvbihtc2dQYXlsb2FkKXtcclxuICAgIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJwcm9qZWN0SXNDaGFuZ2VkXCIpe1xyXG4gICAgICAgIGZvcih2YXIgaW5kIGluIHRoaXMuYWxsTGl2ZU1vbml0b3IpIGRlbGV0ZSB0aGlzLmFsbExpdmVNb25pdG9yW2luZF1cclxuICAgICAgICB0aGlzLnByb2plY3RJRD1tc2dQYXlsb2FkLnByb2plY3RJRFxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlSW1wb3J0YW50RXZlbnQobXNnUGF5bG9hZC5wcm9qZWN0SUQpXHJcbiAgICB9ZWxzZSBpZihtc2dQYXlsb2FkLm1lc3NhZ2U9PVwiYWRkTGl2ZU1vbml0b3JcIil7XHJcbiAgICAgICAgdmFyIHN0cj10aGlzLmdlbmVyYXRlSUQobXNnUGF5bG9hZC50d2luSUQsbXNnUGF5bG9hZC5wcm9wZXJ0eVBhdGgpXHJcbiAgICAgICAgdGhpcy5hbGxMaXZlTW9uaXRvcltzdHJdPW1zZ1BheWxvYWRcclxuICAgICAgICB0aGlzLnN1YnNjcmliZUxpdmVQcm9wZXJ0eShtc2dQYXlsb2FkLnR3aW5JRCxtc2dQYXlsb2FkLnByb3BlcnR5UGF0aClcclxuICAgIH1lbHNlIGlmKG1zZ1BheWxvYWQubWVzc2FnZT09XCJyZW1vdmVMaXZlTW9uaXRvclwiKXtcclxuICAgICAgICB2YXIgc3RyPXRoaXMuZ2VuZXJhdGVJRChtc2dQYXlsb2FkLnR3aW5JRCxtc2dQYXlsb2FkLnByb3BlcnR5UGF0aClcclxuICAgICAgICBkZWxldGUgdGhpcy5hbGxMaXZlTW9uaXRvcltzdHJdXHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUxpdmVQcm9wZXJ0eShtc2dQYXlsb2FkLnR3aW5JRCxtc2dQYXlsb2FkLnByb3BlcnR5UGF0aClcclxuICAgIH1cclxufVxyXG5cclxuc2VydmljZVdvcmtlckhlbHBlci5wcm90b3R5cGUuZ2VuZXJhdGVJRD1mdW5jdGlvbih0d2luSUQscHJvcGVydHlQYXRoKXtcclxuICAgIHJldHVybiB0d2luSUQrXCIuXCIrcHJvcGVydHlQYXRoLmpvaW4oXCIuXCIpXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBzZXJ2aWNlV29ya2VySGVscGVyKCk7IiwiZnVuY3Rpb24gc2ltcGxlQ2hhcnQocGFyZW50RG9tLHhMZW5ndGgsY3NzT3B0aW9ucyxjdXN0b21EcmF3aW5nKXtcclxuICAgIHRoaXMuY2hhcnRET009JChcIjxkaXYvPlwiKVxyXG4gICAgcGFyZW50RG9tLmFwcGVuZCh0aGlzLmNoYXJ0RE9NKVxyXG4gICAgaWYoY3VzdG9tRHJhd2luZyl7XHJcbiAgICAgICAgY3VzdG9tRHJhd2luZyh0aGlzLmNoYXJ0RE9NKVxyXG4gICAgfVxyXG4gICAgdGhpcy5jYW52YXMgPSAkKCc8Y2FudmFzPjwvY2FudmFzPicpXHJcbiAgICB0aGlzLmNhbnZhcy5jc3MoY3NzT3B0aW9ucylcclxuICAgIHRoaXMuY2hhcnRET00uYXBwZW5kKHRoaXMuY2FudmFzKVxyXG4gICAgXHJcbiAgICB0aGlzLmNoYXJ0PW5ldyBDaGFydCh0aGlzLmNhbnZhcywge1xyXG4gICAgICAgIHR5cGU6IFwibGluZVwiLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgbGFiZWxzOiBbXSxcclxuICAgICAgICAgICAgZGF0YXNldHM6IFt7c3RlcHBlZDp0cnVlLCBkYXRhOiBbXX1dXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIGRhdGFzZXRzOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhbkdhcHM6dHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2JhKDAsMCwyNTUsMC43KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOjEsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6MFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwbHVnaW5zOntcclxuICAgICAgICAgICAgICAgIGxlZ2VuZDogeyBkaXNwbGF5OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcDp7ZW5hYmxlZDpmYWxzZX1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2NhbGVzOiB7XHJcbiAgICAgICAgICAgICAgICB4OntncmlkOntkaXNwbGF5OmZhbHNlfSx0aWNrczp7ZGlzcGxheTpmYWxzZX19XHJcbiAgICAgICAgICAgICAgICAseTp7Z3JpZDp7dGlja0xlbmd0aDowfSx0aWNrczp7Zm9udDp7c2l6ZTo5fX19XHJcbiAgICAgICAgICAgICAgICAseDI6IHtwb3NpdGlvbjondG9wJyxncmlkOntkaXNwbGF5OmZhbHNlfSx0aWNrczp7ZGlzcGxheTpmYWxzZX19XHJcbiAgICAgICAgICAgICAgICAseTI6IHtwb3NpdGlvbjoncmlnaHQnLGdyaWQ6e2Rpc3BsYXk6ZmFsc2V9LHRpY2tzOntkaXNwbGF5OmZhbHNlfX0gICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5zZXRYTGVuZ3RoKHhMZW5ndGgpXHJcbn1cclxuXHJcbnNpbXBsZUNoYXJ0LnByb3RvdHlwZS5zZXREYXRhQXJyPWZ1bmN0aW9uKGRhdGFBcnIpe1xyXG4gICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGE9ZGF0YUFyclxyXG4gICAgdGhpcy5jaGFydC51cGRhdGUoKVxyXG59XHJcblxyXG5zaW1wbGVDaGFydC5wcm90b3R5cGUuYWRkRGF0YVZhbHVlPWZ1bmN0aW9uKGRhdGFJbmRleCx2YWx1ZSl7XHJcbiAgICB2YXIgZGF0YUFycj10aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVxyXG5cclxuICAgIHZhciB0b3RhbFBvaW50cz1kYXRhQXJyLmxlbmd0aFxyXG5cclxuICAgIGlmKHRoaXMubGFzdERhdGFJbmRleD09bnVsbCkgdGhpcy5sYXN0RGF0YUluZGV4PWRhdGFJbmRleC0xXHJcbiAgICBpZihkYXRhSW5kZXg8dGhpcy5sYXN0RGF0YUluZGV4KXtcclxuICAgICAgICBpZih0aGlzLmxhc3REYXRhSW5kZXgtZGF0YUluZGV4Pj10b3RhbFBvaW50cykgcmV0dXJuOyAvL2lnbm9yZSByZWNlaXZpbmcgdG9vIG9sZCBwb2ludHNcclxuICAgICAgICB2YXIgZGlmZj10aGlzLmxhc3REYXRhSW5kZXggLSBkYXRhSW5kZXhcclxuICAgICAgICBkYXRhQXJyW3RvdGFsUG9pbnRzLTEtZGlmZl09dmFsdWVcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHZhciBudW1PZlBhc3NlZFBvaW50cz1kYXRhSW5kZXgtdGhpcy5sYXN0RGF0YUluZGV4XHJcbiAgICAgICAgZGF0YUFycj1kYXRhQXJyLnNsaWNlKG51bU9mUGFzc2VkUG9pbnRzKVxyXG4gICAgICAgIGRhdGFBcnJbdG90YWxQb2ludHMtMV09dmFsdWVcclxuICAgIH1cclxuICAgIHRoaXMuc2V0RGF0YUFycihkYXRhQXJyKVxyXG4gICAgdGhpcy5sYXN0RGF0YUluZGV4PWRhdGFJbmRleFxyXG59XHJcblxyXG5zaW1wbGVDaGFydC5wcm90b3R5cGUuc2V0WExlbmd0aD1mdW5jdGlvbih4bGVuKXtcclxuICAgIHZhciBsYWJlbHM9dGhpcy5jaGFydC5kYXRhLmxhYmVsc1xyXG4gICAgbGFiZWxzLmxlbmd0aD0wXHJcbiAgICBmb3IodmFyIGk9MDtpPHhsZW47aSsrKSBsYWJlbHMucHVzaChpKVxyXG4gICAgLy9zaG9ydGVuIG9yIGV4cGFuZCB0aGUgbGVuZ3RoIG9mIGRhdGEgYXJyYXlcclxuICAgIHZhciBkYXRhQXJyPXRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhXHJcbiAgICBpZihkYXRhQXJyLmxlbmd0aD54bGVuKSBkYXRhQXJyPWRhdGFBcnIuc2xpY2UoZGF0YUFyci5sZW5ndGgteGxlbilcclxuICAgIGVsc2UgaWYoZGF0YUFyci5sZW5ndGg8eGxlbil7XHJcbiAgICAgICAgdmFyIG51bWJlclRvQWRkPXhsZW4tZGF0YUFyci5sZW5ndGhcclxuICAgICAgICB2YXIgdG1wQXJyPVtdXHJcbiAgICAgICAgdG1wQXJyW251bWJlclRvQWRkLTFdPW51bGxcclxuICAgICAgICBkYXRhQXJyPXRtcEFyci5jb25jYXQoZGF0YUFycilcclxuICAgIH1cclxuICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhPWRhdGFBcnJcclxuICAgIHRoaXMuY2hhcnQudXBkYXRlKClcclxufVxyXG5cclxuc2ltcGxlQ2hhcnQucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuY2hhcnRET00ucmVtb3ZlKClcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzaW1wbGVDaGFydDsiLCJjb25zdCBnbG9iYWxDYWNoZT1yZXF1aXJlKCcuL2dsb2JhbENhY2hlJylcclxuZnVuY3Rpb24gc2ltcGxlQ29uZmlybURpYWxvZygpe1xyXG4gICAgdGhpcy5ET00gPSAkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO2xlZnQ6NTAlO3RyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6MTAyXCIgY2xhc3M9XCJ3My1jYXJkLTRcIj48L2Rpdj4nKVxyXG4gICAgZ2xvYmFsQ2FjaGUubWFrZURPTURyYWdnYWJsZSh0aGlzLkRPTSlcclxuICAgIC8vdGhpcy5ET00uY3NzKFwib3ZlcmZsb3dcIixcImhpZGRlblwiKVxyXG59XHJcblxyXG5zaW1wbGVDb25maXJtRGlhbG9nLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKGNzc09wdGlvbnMsb3RoZXJPcHRpb25zKXtcclxuICAgIHRoaXMuRE9NLmNzcyhjc3NPcHRpb25zKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKCQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6NDBweFwiIGNsYXNzPVwidzMtYmFyIHczLXJlZFwiPjxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbVwiIHN0eWxlPVwiZm9udC1zaXplOjEuMmVtXCI+JyArIG90aGVyT3B0aW9ucy50aXRsZSArICc8L2Rpdj48L2Rpdj4nKSlcclxuICAgIHZhciBjbG9zZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b24gdzMtcmlnaHRcIiBzdHlsZT1cImZvbnQtc2l6ZToyZW07cGFkZGluZy10b3A6NHB4XCI+w5c8L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5ET00uY2hpbGRyZW4oJzpmaXJzdCcpLmFwcGVuZChjbG9zZUJ1dHRvbilcclxuICAgIGNsb3NlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLmNsb3NlKCkgfSlcclxuXHJcbiAgICB2YXIgZGlhbG9nRGl2PSQoJzxkaXYgY2xhc3M9XCJ3My1jb250YWluZXJcIiBzdHlsZT1cIm1hcmdpbi10b3A6MTBweDttYXJnaW4tYm90dG9tOjEwcHhcIj48L2Rpdj4nKVxyXG4gICAgaWYob3RoZXJPcHRpb25zLmN1c3RvbURyYXdpbmcpe1xyXG4gICAgICAgIG90aGVyT3B0aW9ucy5jdXN0b21EcmF3aW5nKGRpYWxvZ0RpdilcclxuICAgIH1lbHNle1xyXG4gICAgICAgIGRpYWxvZ0Rpdi50ZXh0KG90aGVyT3B0aW9ucy5jb250ZW50KVxyXG4gICAgfVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKGRpYWxvZ0RpdilcclxuICAgIHRoaXMuZGlhbG9nRGl2PWRpYWxvZ0RpdlxyXG5cclxuICAgIHRoaXMuYm90dG9tQmFyPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKHRoaXMuYm90dG9tQmFyKVxyXG5cclxuICAgIGlmKCFvdGhlck9wdGlvbnMuYnV0dG9ucykgb3RoZXJPcHRpb25zLmJ1dHRvbnM9W11cclxuICAgIG90aGVyT3B0aW9ucy5idXR0b25zLmZvckVhY2goYnRuPT57XHJcbiAgICAgICAgdmFyIGFCdXR0b249JCgnPGJ1dHRvbiBjbGFzcz1cInczLXJpcHBsZSB3My1idXR0b24gdzMtcmlnaHQgJysoYnRuLmNvbG9yQ2xhc3N8fFwiXCIpKydcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDoycHg7bWFyZ2luLWxlZnQ6MnB4XCI+JytidG4udGV4dCsnPC9idXR0b24+JylcclxuICAgICAgICBhQnV0dG9uLm9uKFwiY2xpY2tcIiwoKT0+IHsgYnRuLmNsaWNrRnVuYygpICB9ICApXHJcbiAgICAgICAgdGhpcy5ib3R0b21CYXIuYXBwZW5kKGFCdXR0b24pICAgIFxyXG4gICAgfSlcclxuICAgICQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLkRPTSlcclxufVxyXG5cclxuc2ltcGxlQ29uZmlybURpYWxvZy5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NLnJlbW92ZSgpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2ltcGxlQ29uZmlybURpYWxvZzsiLCJmdW5jdGlvbiBzaW1wbGVFeHBhbmRhYmxlU2VjdGlvbih0aXRsZVN0cixwYXJlbnRET00sb3B0aW9ucykge1xyXG4gICAgdGhpcy5leHBhbmRTdGF0dXM9ZmFsc2VcclxuICAgIG9wdGlvbnM9b3B0aW9uc3x8e31cclxuICAgIHZhciBtYXJnaW5Ub3A9MTBcclxuICAgIGlmKG9wdGlvbnMubWFyZ2luVG9wIT1udWxsKSBtYXJnaW5Ub3A9b3B0aW9ucy5tYXJnaW5Ub3BcclxuICAgIHRoaXMuaGVhZGVyRE9NID0gJChgPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1ibG9jayB3My1saWdodC1ncmV5IHczLWxlZnQtYWxpZ24gdzMtYm9yZGVyLWJvdHRvbSB3My1ob3Zlci1hbWJlciB3My10ZXh0LWdyYXlcIiBzdHlsZT1cIm1hcmdpbi10b3A6JHttYXJnaW5Ub3B9cHg7Zm9udC13ZWlnaHQ6Ym9sZFwiPjxhPiR7dGl0bGVTdHJ9PC9hPjxpIGNsYXNzPVwidzMtbWFyZ2luLWxlZnQgZmFzIGZhLWNhcmV0LXVwXCI+PC9pPjwvYnV0dG9uPmApXHJcbiAgICB0aGlzLmxpc3RET00gPSAkKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyIHczLWhpZGVcIiBzdHlsZT1cInBhZGRpbmctdG9wOjJweFwiPjwvZGl2PicpXHJcblxyXG4gICAgdGhpcy5oZWFkZXJUZXh0RE9NPXRoaXMuaGVhZGVyRE9NLmNoaWxkcmVuKFwiOmZpcnN0XCIpXHJcblxyXG4gICAgdGhpcy50cmlhbmdsZT10aGlzLmhlYWRlckRPTS5jaGlsZHJlbignaScpLmVxKDApXHJcbiAgICBwYXJlbnRET00uYXBwZW5kKHRoaXMuaGVhZGVyRE9NLCB0aGlzLmxpc3RET00pXHJcbiAgICB0aGlzLmhlYWRlckRPTS5vbihcImNsaWNrXCIsIChldnQpID0+IHtcclxuICAgICAgICBpZih0aGlzLmV4cGFuZFN0YXR1cykgdGhpcy5zaHJpbmsoKVxyXG4gICAgICAgIGVsc2UgdGhpcy5leHBhbmQoKVxyXG4gICAgICAgIHRoaXMuY2FsbEJhY2tfY2hhbmdlKHRoaXMuZXhwYW5kU3RhdHVzKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5jYWxsQmFja19jaGFuZ2U9KHN0YXR1cyk9Pnt9XHJcbn1cclxuXHJcbnNpbXBsZUV4cGFuZGFibGVTZWN0aW9uLnByb3RvdHlwZS5kZWxldGVTZWxmPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmhlYWRlckRPTS5yZW1vdmUoKVxyXG4gICAgdGhpcy5saXN0RE9NLnJlbW92ZSgpXHJcbn1cclxuXHJcbnNpbXBsZUV4cGFuZGFibGVTZWN0aW9uLnByb3RvdHlwZS5leHBhbmQ9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubGlzdERPTS5hZGRDbGFzcyhcInczLXNob3dcIilcclxuICAgIHRoaXMudHJpYW5nbGUuYWRkQ2xhc3MoXCJmYS1jYXJldC1kb3duXCIpXHJcbiAgICB0aGlzLnRyaWFuZ2xlLnJlbW92ZUNsYXNzKFwiZmEtY2FyZXQtdXBcIilcclxuICAgIHRoaXMuZXhwYW5kU3RhdHVzID0gdHJ1ZVxyXG59XHJcblxyXG5zaW1wbGVFeHBhbmRhYmxlU2VjdGlvbi5wcm90b3R5cGUuc2hyaW5rPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmxpc3RET00ucmVtb3ZlQ2xhc3MoXCJ3My1zaG93XCIpXHJcbiAgICB0aGlzLnRyaWFuZ2xlLnJlbW92ZUNsYXNzKFwiZmEtY2FyZXQtZG93blwiKVxyXG4gICAgdGhpcy50cmlhbmdsZS5hZGRDbGFzcyhcImZhLWNhcmV0LXVwXCIpXHJcbiAgICB0aGlzLmV4cGFuZFN0YXR1cyA9IGZhbHNlXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2ltcGxlRXhwYW5kYWJsZVNlY3Rpb247IiwiZnVuY3Rpb24gc2ltcGxlU2VsZWN0TWVudShidXR0b25OYW1lLG9wdGlvbnMpe1xyXG4gICAgb3B0aW9ucz1vcHRpb25zfHx7fSAvL3tpc0NsaWNrYWJsZToxLHdpdGhCb3JkZXI6MSxmb250U2l6ZTpcIlwiLGNvbG9yQ2xhc3M6XCJcIixidXR0b25DU1M6XCJcIn1cclxuICAgIGlmKG9wdGlvbnMuaXNDbGlja2FibGUpe1xyXG4gICAgICAgIHRoaXMuaXNDbGlja2FibGU9dHJ1ZVxyXG4gICAgICAgIHRoaXMuRE9NPSQoJzxkaXYgY2xhc3M9XCJ3My1kcm9wZG93bi1jbGlja1wiPjwvZGl2PicpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLkRPTT0kKCc8ZGl2IGNsYXNzPVwidzMtZHJvcGRvd24taG92ZXIgXCI+PC9kaXY+JylcclxuICAgICAgICB0aGlzLkRPTS5vbihcIm1vdXNlb3ZlclwiLChlKT0+e1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdERyb3BEb3duUG9zaXRpb24oKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vaXQgc2VlbXMgdGhhdCB0aGUgc2VsZWN0IG1lbnUgb25seSBjYW4gc2hvdyBvdXRzaWRlIG9mIGEgcGFyZW50IHNjcm9sbGFibGUgZG9tIHdoZW4gaXQgaXMgaW5zaWRlIGEgdzMtYmFyIGl0ZW0uLi4gbm90IHZlcnkgc3VyZSBhYm91dCB3aHkgXHJcbiAgICB2YXIgcm93RE9NPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXJcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0OjVweFwiPjwvZGl2PicpXHJcbiAgICByb3dET00uY3NzKFwid2lkdGhcIiwob3B0aW9ucy53aWR0aHx8MTAwKStcInB4XCIpXHJcbiAgICB0aGlzLnJvd0RPTT1yb3dET01cclxuICAgIHRoaXMucm93RE9NLmFwcGVuZCh0aGlzLkRPTSlcclxuICAgIFxyXG4gICAgdGhpcy5idXR0b249JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvblwiIHN0eWxlPVwib3V0bGluZTogbm9uZTtcIj48YT4nK2J1dHRvbk5hbWUrJzwvYT48YSBzdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGQ7cGFkZGluZy1sZWZ0OjJweFwiPjwvYT48aSBjbGFzcz1cImZhIGZhLWNhcmV0LWRvd25cIiBzdHlsZT1cInBhZGRpbmctbGVmdDozcHhcIj48L2k+PC9idXR0b24+JylcclxuICAgIGlmKG9wdGlvbnMud2l0aEJvcmRlcikgdGhpcy5idXR0b24uYWRkQ2xhc3MoXCJ3My1ib3JkZXJcIilcclxuICAgIGlmKG9wdGlvbnMuZm9udFNpemUpIHRoaXMuRE9NLmNzcyhcImZvbnQtc2l6ZVwiLG9wdGlvbnMuZm9udFNpemUpXHJcbiAgICBpZihvcHRpb25zLmNvbG9yQ2xhc3MpIHRoaXMuYnV0dG9uLmFkZENsYXNzKG9wdGlvbnMuY29sb3JDbGFzcylcclxuICAgIGlmKG9wdGlvbnMud2lkdGgpIHRoaXMuYnV0dG9uLmNzcyhcIndpZHRoXCIsb3B0aW9ucy53aWR0aClcclxuICAgIGlmKG9wdGlvbnMuYnV0dG9uQ1NTKSB0aGlzLmJ1dHRvbi5jc3Mob3B0aW9ucy5idXR0b25DU1MpXHJcbiAgICBpZihvcHRpb25zLmFkanVzdFBvc2l0aW9uQW5jaG9yKSB0aGlzLmFkanVzdFBvc2l0aW9uQW5jaG9yPW9wdGlvbnMuYWRqdXN0UG9zaXRpb25BbmNob3JcclxuXHJcbiAgICB0aGlzLm9wdGlvbkNvbnRlbnRET009JCgnPGRpdiBjbGFzcz1cInczLWRyb3Bkb3duLWNvbnRlbnQgdzMtYmFyLWJsb2NrIHczLWNhcmQtNFwiPjwvZGl2PicpXHJcbiAgICBpZihvcHRpb25zLm9wdGlvbkxpc3RIZWlnaHQpIHRoaXMub3B0aW9uQ29udGVudERPTS5jc3Moe1wibWF4LWhlaWdodFwiOm9wdGlvbnMub3B0aW9uTGlzdEhlaWdodCtcInB4XCIsXCJvdmVyZmxvdy15XCI6XCJhdXRvXCIsXCJvdmVyZmxvdy14XCI6XCJ2aXNpYmxlXCJ9KVxyXG4gICAgaWYob3B0aW9ucy5vcHRpb25MaXN0TWFyZ2luVG9wKSB0aGlzLm9wdGlvbkNvbnRlbnRET00uY3NzKHtcIm1hcmdpbi10b3BcIjpvcHRpb25zLm9wdGlvbkxpc3RNYXJnaW5Ub3ArXCJweFwifSlcclxuICAgIGlmKG9wdGlvbnMub3B0aW9uTGlzdE1hcmdpbkxlZnQpIHRoaXMub3B0aW9uQ29udGVudERPTS5jc3Moe1wibWFyZ2luLWxlZnRcIjpvcHRpb25zLm9wdGlvbkxpc3RNYXJnaW5MZWZ0K1wicHhcIn0pXHJcbiAgICBcclxuICAgIHRoaXMuRE9NLmFwcGVuZCh0aGlzLmJ1dHRvbix0aGlzLm9wdGlvbkNvbnRlbnRET00pXHJcbiAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsO1xyXG5cclxuICAgIGlmKG9wdGlvbnMuaXNDbGlja2FibGUpe1xyXG4gICAgICAgIHRoaXMuYnV0dG9uLm9uKFwiY2xpY2tcIiwoZSk9PntcclxuICAgICAgICAgICAgdGhpcy5hZGp1c3REcm9wRG93blBvc2l0aW9uKClcclxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25Db250ZW50RE9NLmhhc0NsYXNzKFwidzMtc2hvd1wiKSkgIHRoaXMub3B0aW9uQ29udGVudERPTS5yZW1vdmVDbGFzcyhcInczLXNob3dcIilcclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEJhY2tfYmVmb3JlQ2xpY2tFeHBhbmQoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25Db250ZW50RE9NLmFkZENsYXNzKFwidzMtc2hvd1wiKVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSkgICAgXHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLnNocmluaz1mdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5vcHRpb25Db250ZW50RE9NLmhhc0NsYXNzKFwidzMtc2hvd1wiKSkgIHRoaXMub3B0aW9uQ29udGVudERPTS5yZW1vdmVDbGFzcyhcInczLXNob3dcIilcclxufVxyXG5cclxuc2ltcGxlU2VsZWN0TWVudS5wcm90b3R5cGUuYWRqdXN0RHJvcERvd25Qb3NpdGlvbj1mdW5jdGlvbigpe1xyXG4gICAgaWYoIXRoaXMuYWRqdXN0UG9zaXRpb25BbmNob3IpIHJldHVybjtcclxuICAgIHZhciBvZmZzZXQ9dGhpcy5ET00ub2Zmc2V0KClcclxuICAgIHZhciBuZXdUb3A9b2Zmc2V0LnRvcC10aGlzLmFkanVzdFBvc2l0aW9uQW5jaG9yLnRvcFxyXG4gICAgdmFyIG5ld0xlZnQ9b2Zmc2V0LmxlZnQtdGhpcy5hZGp1c3RQb3NpdGlvbkFuY2hvci5sZWZ0XHJcbiAgICB0aGlzLm9wdGlvbkNvbnRlbnRET00uY3NzKHtcInRvcFwiOm5ld1RvcCtcInB4XCIsXCJsZWZ0XCI6bmV3TGVmdCtcInB4XCJ9KVxyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS5maW5kT3B0aW9uPWZ1bmN0aW9uKG9wdGlvblZhbHVlKXtcclxuICAgIHZhciBvcHRpb25zPXRoaXMub3B0aW9uQ29udGVudERPTS5jaGlsZHJlbigpXHJcbiAgICBmb3IodmFyIGk9MDtpPG9wdGlvbnMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdmFyIGFuT3B0aW9uPSQob3B0aW9uc1tpXSlcclxuICAgICAgICBpZihvcHRpb25WYWx1ZT09YW5PcHRpb24uZGF0YShcIm9wdGlvblZhbHVlXCIpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHtcInRleHRcIjphbk9wdGlvbi50ZXh0KCksXCJ2YWx1ZVwiOmFuT3B0aW9uLmRhdGEoXCJvcHRpb25WYWx1ZVwiKSxcImNvbG9yQ2xhc3NcIjphbk9wdGlvbi5kYXRhKFwib3B0aW9uQ29sb3JDbGFzc1wiKX1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLmZpbmRPcHRpb25CeVRleHQ9ZnVuY3Rpb24ob3B0aW9uVGV4dCl7XHJcbiAgICB2YXIgb3B0aW9ucz10aGlzLm9wdGlvbkNvbnRlbnRET00uY2hpbGRyZW4oKVxyXG4gICAgZm9yKHZhciBpPTA7aTxvcHRpb25zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBhbk9wdGlvbj0kKG9wdGlvbnNbaV0pXHJcbiAgICAgICAgaWYob3B0aW9uVGV4dD09YW5PcHRpb24udGV4dCgpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHtcInRleHRcIjphbk9wdGlvbi50ZXh0KCksXCJ2YWx1ZVwiOmFuT3B0aW9uLmRhdGEoXCJvcHRpb25WYWx1ZVwiKSxcImNvbG9yQ2xhc3NcIjphbk9wdGlvbi5kYXRhKFwib3B0aW9uQ29sb3JDbGFzc1wiKX1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLmFkZE9wdGlvbkFycj1mdW5jdGlvbihhcnIpe1xyXG4gICAgYXJyLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgdGhpcy5hZGRPcHRpb24oZWxlbWVudClcclxuICAgIH0pO1xyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS5hZGRPcHRpb249ZnVuY3Rpb24ob3B0aW9uVGV4dCxvcHRpb25WYWx1ZSxjb2xvckNsYXNzKXtcclxuICAgIHZhciBvcHRpb25JdGVtPSQoJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1idXR0b25cIiBzdHlsZT1cIndoaXRlLXNwYWNlOm5vd3JhcFwiPicrb3B0aW9uVGV4dCsnPC9hPicpXHJcbiAgICBpZihjb2xvckNsYXNzKSBvcHRpb25JdGVtLmFkZENsYXNzKGNvbG9yQ2xhc3MpXHJcbiAgICB0aGlzLm9wdGlvbkNvbnRlbnRET00uYXBwZW5kKG9wdGlvbkl0ZW0pXHJcbiAgICBvcHRpb25JdGVtLmRhdGEoXCJvcHRpb25WYWx1ZVwiLG9wdGlvblZhbHVlfHxvcHRpb25UZXh0KVxyXG4gICAgb3B0aW9uSXRlbS5kYXRhKFwib3B0aW9uQ29sb3JDbGFzc1wiLGNvbG9yQ2xhc3MpXHJcbiAgICBvcHRpb25JdGVtLm9uKCdjbGljaycsKGUpPT57XHJcbiAgICAgICAgdGhpcy5jdXJTZWxlY3RWYWw9b3B0aW9uSXRlbS5kYXRhKFwib3B0aW9uVmFsdWVcIilcclxuICAgICAgICBpZih0aGlzLmlzQ2xpY2thYmxlKXtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25Db250ZW50RE9NLnJlbW92ZUNsYXNzKFwidzMtc2hvd1wiKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLkRPTS5yZW1vdmVDbGFzcygndzMtZHJvcGRvd24taG92ZXInKVxyXG4gICAgICAgICAgICB0aGlzLkRPTS5hZGRDbGFzcygndzMtZHJvcGRvd24tY2xpY2snKVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgLy90aGlzIGlzIHRvIGhpZGUgdGhlIGRyb3AgZG93biBtZW51IGFmdGVyIGNsaWNrXHJcbiAgICAgICAgICAgICAgICB0aGlzLkRPTS5hZGRDbGFzcygndzMtZHJvcGRvd24taG92ZXInKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ET00ucmVtb3ZlQ2xhc3MoJ3czLWRyb3Bkb3duLWNsaWNrJylcclxuICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQmFja19jbGlja09wdGlvbihvcHRpb25UZXh0LG9wdGlvbkl0ZW0uZGF0YShcIm9wdGlvblZhbHVlXCIpLFwicmVhbE1vdXNlQ2xpY2tcIixvcHRpb25JdGVtLmRhdGEoXCJvcHRpb25Db2xvckNsYXNzXCIpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSlcclxufVxyXG5cclxuc2ltcGxlU2VsZWN0TWVudS5wcm90b3R5cGUuY2hhbmdlTmFtZT1mdW5jdGlvbihuYW1lU3RyMSxuYW1lU3RyMil7XHJcbiAgICB0aGlzLmJ1dHRvbi5jaGlsZHJlbihcIjpmaXJzdFwiKS50ZXh0KG5hbWVTdHIxKVxyXG4gICAgdGhpcy5idXR0b24uY2hpbGRyZW4oKS5lcSgxKS50ZXh0KG5hbWVTdHIyKVxyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS50cmlnZ2VyT3B0aW9uSW5kZXg9ZnVuY3Rpb24ob3B0aW9uSW5kZXgpe1xyXG4gICAgdmFyIHRoZU9wdGlvbj10aGlzLm9wdGlvbkNvbnRlbnRET00uY2hpbGRyZW4oKS5lcShvcHRpb25JbmRleClcclxuICAgIGlmKHRoZU9wdGlvbi5sZW5ndGg9PTApIHtcclxuICAgICAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsO1xyXG4gICAgICAgIHRoaXMuY2FsbEJhY2tfY2xpY2tPcHRpb24obnVsbCxudWxsKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuY3VyU2VsZWN0VmFsPXRoZU9wdGlvbi5kYXRhKFwib3B0aW9uVmFsdWVcIilcclxuICAgIHRoaXMuY2FsbEJhY2tfY2xpY2tPcHRpb24odGhlT3B0aW9uLnRleHQoKSx0aGVPcHRpb24uZGF0YShcIm9wdGlvblZhbHVlXCIpLG51bGwsdGhlT3B0aW9uLmRhdGEoXCJvcHRpb25Db2xvckNsYXNzXCIpKVxyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS50cmlnZ2VyT3B0aW9uVmFsdWU9ZnVuY3Rpb24ob3B0aW9uVmFsdWUpe1xyXG4gICAgdmFyIHJlPXRoaXMuZmluZE9wdGlvbihvcHRpb25WYWx1ZSlcclxuICAgIGlmKHJlPT1udWxsKXtcclxuICAgICAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsXHJcbiAgICAgICAgdGhpcy5jYWxsQmFja19jbGlja09wdGlvbihudWxsLG51bGwpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmN1clNlbGVjdFZhbD1yZS52YWx1ZVxyXG4gICAgICAgIHRoaXMuY2FsbEJhY2tfY2xpY2tPcHRpb24ocmUudGV4dCxyZS52YWx1ZSxudWxsLHJlLmNvbG9yQ2xhc3MpXHJcbiAgICB9XHJcbn1cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLnRyaWdnZXJPcHRpb25UZXh0PWZ1bmN0aW9uKG9wdGlvblRleHQpe1xyXG4gICAgdmFyIHJlPXRoaXMuZmluZE9wdGlvbkJ5VGV4dChvcHRpb25UZXh0KVxyXG4gICAgaWYocmU9PW51bGwpe1xyXG4gICAgICAgIHRoaXMuY3VyU2VsZWN0VmFsPW51bGxcclxuICAgICAgICB0aGlzLmNhbGxCYWNrX2NsaWNrT3B0aW9uKG51bGwsbnVsbClcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuY3VyU2VsZWN0VmFsPXJlLnZhbHVlXHJcbiAgICAgICAgdGhpcy5jYWxsQmFja19jbGlja09wdGlvbihyZS50ZXh0LHJlLnZhbHVlLG51bGwscmUuY29sb3JDbGFzcylcclxuICAgIH1cclxufVxyXG5cclxuXHJcbnNpbXBsZVNlbGVjdE1lbnUucHJvdG90eXBlLmNsZWFyT3B0aW9ucz1mdW5jdGlvbihvcHRpb25UZXh0LG9wdGlvblZhbHVlKXtcclxuICAgIHRoaXMub3B0aW9uQ29udGVudERPTS5lbXB0eSgpXHJcbiAgICB0aGlzLmN1clNlbGVjdFZhbD1udWxsO1xyXG59XHJcblxyXG5zaW1wbGVTZWxlY3RNZW51LnByb3RvdHlwZS5jYWxsQmFja19jbGlja09wdGlvbj1mdW5jdGlvbihvcHRpb250ZXh0LG9wdGlvblZhbHVlLHJlYWxNb3VzZUNsaWNrKXtcclxufVxyXG5cclxuc2ltcGxlU2VsZWN0TWVudS5wcm90b3R5cGUuY2FsbEJhY2tfYmVmb3JlQ2xpY2tFeHBhbmQ9ZnVuY3Rpb24ob3B0aW9udGV4dCxvcHRpb25WYWx1ZSxyZWFsTW91c2VDbGljayl7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsZVNlbGVjdE1lbnU7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gc2ltcGxlVHJlZShET00sb3B0aW9ucyl7XHJcbiAgICB0aGlzLkRPTT1ET01cclxuICAgIHRoaXMuZ3JvdXBOb2Rlcz1bXSAvL2VhY2ggZ3JvdXAgaGVhZGVyIGlzIG9uZSBub2RlXHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXM9W107XHJcbiAgICB0aGlzLm9wdGlvbnM9b3B0aW9ucyB8fCB7fVxyXG5cclxuICAgIHRoaXMubGFzdENsaWNrZWROb2RlPW51bGw7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNjcm9sbFRvTGVhZk5vZGU9ZnVuY3Rpb24oYU5vZGUpe1xyXG4gICAgdmFyIHNjcm9sbFRvcD10aGlzLkRPTS5zY3JvbGxUb3AoKVxyXG4gICAgdmFyIHRyZWVIZWlnaHQ9dGhpcy5ET00uaGVpZ2h0KClcclxuICAgIHZhciBub2RlUG9zaXRpb249YU5vZGUuRE9NLnBvc2l0aW9uKCkudG9wIC8vd2hpY2ggZG9lcyBub3QgY29uc2lkZXIgcGFyZW50IERPTSdzIHNjcm9sbCBoZWlnaHRcclxuICAgIC8vY29uc29sZS5sb2coc2Nyb2xsVG9wLHRyZWVIZWlnaHQsbm9kZVBvc2l0aW9uKVxyXG4gICAgaWYodHJlZUhlaWdodC01MDxub2RlUG9zaXRpb24pe1xyXG4gICAgICAgIHRoaXMuRE9NLnNjcm9sbFRvcChzY3JvbGxUb3AgKyBub2RlUG9zaXRpb24tKHRyZWVIZWlnaHQtNTApKSBcclxuICAgIH1lbHNlIGlmKG5vZGVQb3NpdGlvbjw1MCl7XHJcbiAgICAgICAgdGhpcy5ET00uc2Nyb2xsVG9wKHNjcm9sbFRvcCArIChub2RlUG9zaXRpb24tNTApKSBcclxuICAgIH1cclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuY2xlYXJBbGxMZWFmTm9kZXM9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubGFzdENsaWNrZWROb2RlPW51bGxcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKChnTm9kZSk9PntcclxuICAgICAgICBnTm9kZS5saXN0RE9NLmVtcHR5KClcclxuICAgICAgICBnTm9kZS5jaGlsZExlYWZOb2Rlcy5sZW5ndGg9MFxyXG4gICAgICAgIGdOb2RlLnJlZnJlc2hOYW1lKClcclxuICAgIH0pXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLmZpcnN0TGVhZk5vZGU9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMuZ3JvdXBOb2Rlcy5sZW5ndGg9PTApIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGZpcnN0TGVhZk5vZGU9bnVsbDtcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKGFHcm91cE5vZGU9PntcclxuICAgICAgICBpZihmaXJzdExlYWZOb2RlIT1udWxsKSByZXR1cm47XHJcbiAgICAgICAgaWYoYUdyb3VwTm9kZS5jaGlsZExlYWZOb2Rlcy5sZW5ndGg+MCkgZmlyc3RMZWFmTm9kZT1hR3JvdXBOb2RlLmNoaWxkTGVhZk5vZGVzWzBdXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBmaXJzdExlYWZOb2RlXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLm5leHRHcm91cE5vZGU9ZnVuY3Rpb24oYUdyb3VwTm9kZSl7XHJcbiAgICBpZihhR3JvdXBOb2RlPT1udWxsKSByZXR1cm47XHJcbiAgICB2YXIgaW5kZXg9dGhpcy5ncm91cE5vZGVzLmluZGV4T2YoYUdyb3VwTm9kZSlcclxuICAgIGlmKHRoaXMuZ3JvdXBOb2Rlcy5sZW5ndGgtMT5pbmRleCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBOb2Rlc1tpbmRleCsxXVxyXG4gICAgfWVsc2V7IC8vcm90YXRlIGJhY2t3YXJkIHRvIGZpcnN0IGdyb3VwIG5vZGVcclxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cE5vZGVzWzBdIFxyXG4gICAgfVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5uZXh0TGVhZk5vZGU9ZnVuY3Rpb24oYUxlYWZOb2RlKXtcclxuICAgIGlmKGFMZWFmTm9kZT09bnVsbCkgcmV0dXJuO1xyXG4gICAgdmFyIGFHcm91cE5vZGU9YUxlYWZOb2RlLnBhcmVudEdyb3VwTm9kZVxyXG4gICAgdmFyIGluZGV4PWFHcm91cE5vZGUuY2hpbGRMZWFmTm9kZXMuaW5kZXhPZihhTGVhZk5vZGUpXHJcbiAgICBpZihhR3JvdXBOb2RlLmNoaWxkTGVhZk5vZGVzLmxlbmd0aC0xPmluZGV4KXtcclxuICAgICAgICAvL25leHQgbm9kZSBpcyBpbiBzYW1lIGdyb3VwXHJcbiAgICAgICAgcmV0dXJuIGFHcm91cE5vZGUuY2hpbGRMZWFmTm9kZXNbaW5kZXgrMV1cclxuICAgIH1lbHNle1xyXG4gICAgICAgIC8vZmluZCBuZXh0IGdyb3VwIGZpcnN0IG5vZGVcclxuICAgICAgICB3aGlsZSh0cnVlKXtcclxuICAgICAgICAgICAgdmFyIG5leHRHcm91cE5vZGUgPSB0aGlzLm5leHRHcm91cE5vZGUoYUdyb3VwTm9kZSlcclxuICAgICAgICAgICAgaWYobmV4dEdyb3VwTm9kZS5jaGlsZExlYWZOb2Rlcy5sZW5ndGg9PTApe1xyXG4gICAgICAgICAgICAgICAgYUdyb3VwTm9kZT1uZXh0R3JvdXBOb2RlXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRHcm91cE5vZGUuY2hpbGRMZWFmTm9kZXNbMF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuc2VhcmNoVGV4dD1mdW5jdGlvbihzdHIpe1xyXG4gICAgaWYoc3RyPT1cIlwiKSByZXR1cm4gbnVsbDtcclxuICAgIC8vc2VhcmNoIGZyb20gY3VycmVudCBzZWxlY3QgaXRlbSB0aGUgbmV4dCBsZWFmIGl0ZW0gY29udGFpbnMgdGhlIHRleHRcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoc3RyLCAnaScpO1xyXG4gICAgdmFyIHN0YXJ0Tm9kZVxyXG4gICAgaWYodGhpcy5zZWxlY3RlZE5vZGVzLmxlbmd0aD09MCkge1xyXG4gICAgICAgIHN0YXJ0Tm9kZT10aGlzLmZpcnN0TGVhZk5vZGUoKVxyXG4gICAgICAgIGlmKHN0YXJ0Tm9kZT09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIHZhciB0aGVTdHI9c3RhcnROb2RlLm5hbWU7XHJcbiAgICAgICAgaWYodGhlU3RyLm1hdGNoKHJlZ2V4KSE9bnVsbCl7XHJcbiAgICAgICAgICAgIC8vZmluZCB0YXJnZXQgbm9kZSBcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0Tm9kZVxyXG4gICAgICAgIH1cclxuICAgIH1lbHNlIHN0YXJ0Tm9kZT10aGlzLnNlbGVjdGVkTm9kZXNbMF1cclxuXHJcbiAgICBpZihzdGFydE5vZGU9PW51bGwpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICB2YXIgZnJvbU5vZGU9c3RhcnROb2RlO1xyXG4gICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgdmFyIG5leHROb2RlPXRoaXMubmV4dExlYWZOb2RlKGZyb21Ob2RlKVxyXG4gICAgICAgIGlmKG5leHROb2RlPT1zdGFydE5vZGUpIHJldHVybiBudWxsO1xyXG4gICAgICAgIHZhciBuZXh0Tm9kZVN0cj1uZXh0Tm9kZS5uYW1lO1xyXG4gICAgICAgIGlmKG5leHROb2RlU3RyLm1hdGNoKHJlZ2V4KSE9bnVsbCl7XHJcbiAgICAgICAgICAgIC8vZmluZCB0YXJnZXQgbm9kZVxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGVcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgZnJvbU5vZGU9bmV4dE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSAgICBcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuZ2V0QWxsTGVhZk5vZGVBcnI9ZnVuY3Rpb24oKXtcclxuICAgIHZhciBhbGxMZWFmPVtdXHJcbiAgICB0aGlzLmdyb3VwTm9kZXMuZm9yRWFjaChnbj0+e1xyXG4gICAgICAgIGFsbExlYWY9YWxsTGVhZi5jb25jYXQoZ24uY2hpbGRMZWFmTm9kZXMpXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIGFsbExlYWY7XHJcbn1cclxuXHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5hZGRMZWFmbm9kZVRvR3JvdXA9ZnVuY3Rpb24oZ3JvdXBOYW1lLG9iaixza2lwUmVwZWF0KXtcclxuICAgIHZhciBhR3JvdXBOb2RlPXRoaXMuZmluZEdyb3VwTm9kZShncm91cE5hbWUpXHJcbiAgICBpZihhR3JvdXBOb2RlID09IG51bGwpIHJldHVybjtcclxuICAgIGFHcm91cE5vZGUuYWRkTm9kZShvYmosc2tpcFJlcGVhdClcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUucmVtb3ZlQWxsTm9kZXM9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubGFzdENsaWNrZWROb2RlPW51bGxcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5sZW5ndGg9MDtcclxuICAgIHRoaXMuc2VsZWN0ZWROb2Rlcy5sZW5ndGg9MDtcclxuICAgIHRoaXMuRE9NLmVtcHR5KClcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuZmluZEdyb3VwTm9kZT1mdW5jdGlvbihncm91cE5hbWUpe1xyXG4gICAgdmFyIGZvdW5kR3JvdXBOb2RlPW51bGxcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKGFHcm91cE5vZGU9PntcclxuICAgICAgICBpZihhR3JvdXBOb2RlLm5hbWU9PWdyb3VwTmFtZSl7XHJcbiAgICAgICAgICAgIGZvdW5kR3JvdXBOb2RlPWFHcm91cE5vZGVcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gZm91bmRHcm91cE5vZGU7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLmRlbEdyb3VwTm9kZT1mdW5jdGlvbihnbm9kZSl7XHJcbiAgICB0aGlzLmxhc3RDbGlja2VkTm9kZT1udWxsXHJcbiAgICBnbm9kZS5kZWxldGVTZWxmKClcclxufVxyXG5cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuZGVsZXRlTGVhZk5vZGU9ZnVuY3Rpb24obm9kZU5hbWUpe1xyXG4gICAgdGhpcy5sYXN0Q2xpY2tlZE5vZGU9bnVsbFxyXG4gICAgdmFyIGZpbmRMZWFmTm9kZT1udWxsXHJcbiAgICB0aGlzLmdyb3VwTm9kZXMuZm9yRWFjaCgoZ05vZGUpPT57XHJcbiAgICAgICAgaWYoZmluZExlYWZOb2RlIT1udWxsKSByZXR1cm47XHJcbiAgICAgICAgZ05vZGUuY2hpbGRMZWFmTm9kZXMuZm9yRWFjaCgoYUxlYWYpPT57XHJcbiAgICAgICAgICAgIGlmKGFMZWFmLm5hbWU9PW5vZGVOYW1lKXtcclxuICAgICAgICAgICAgICAgIGZpbmRMZWFmTm9kZT1hTGVhZlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbiAgICBpZihmaW5kTGVhZk5vZGU9PW51bGwpIHJldHVybjtcclxuICAgIGZpbmRMZWFmTm9kZS5kZWxldGVTZWxmKClcclxufVxyXG5cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLmluc2VydEdyb3VwTm9kZT1mdW5jdGlvbihvYmosaW5kZXgpe1xyXG4gICAgdmFyIGFOZXdHcm91cE5vZGUgPSBuZXcgc2ltcGxlVHJlZUdyb3VwTm9kZSh0aGlzLG9iailcclxuICAgIHZhciBleGlzdEdyb3VwTm9kZT0gdGhpcy5maW5kR3JvdXBOb2RlKGFOZXdHcm91cE5vZGUubmFtZSlcclxuICAgIGlmKGV4aXN0R3JvdXBOb2RlIT1udWxsKSByZXR1cm47XHJcbiAgICB0aGlzLmdyb3VwTm9kZXMuc3BsaWNlKGluZGV4LCAwLCBhTmV3R3JvdXBOb2RlKTtcclxuXHJcbiAgICBpZihpbmRleD09MCl7XHJcbiAgICAgICAgdGhpcy5ET00uYXBwZW5kKGFOZXdHcm91cE5vZGUuaGVhZGVyRE9NKVxyXG4gICAgICAgIHRoaXMuRE9NLmFwcGVuZChhTmV3R3JvdXBOb2RlLmxpc3RET00pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgcHJldkdyb3VwTm9kZT10aGlzLmdyb3VwTm9kZXNbaW5kZXgtMV1cclxuICAgICAgICBhTmV3R3JvdXBOb2RlLmhlYWRlckRPTS5pbnNlcnRBZnRlcihwcmV2R3JvdXBOb2RlLmxpc3RET00pXHJcbiAgICAgICAgYU5ld0dyb3VwTm9kZS5saXN0RE9NLmluc2VydEFmdGVyKGFOZXdHcm91cE5vZGUuaGVhZGVyRE9NKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhTmV3R3JvdXBOb2RlO1xyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5hZGRHcm91cE5vZGU9ZnVuY3Rpb24ob2JqKXtcclxuICAgIHZhciBhTmV3R3JvdXBOb2RlID0gbmV3IHNpbXBsZVRyZWVHcm91cE5vZGUodGhpcyxvYmopXHJcbiAgICB2YXIgZXhpc3RHcm91cE5vZGU9IHRoaXMuZmluZEdyb3VwTm9kZShhTmV3R3JvdXBOb2RlLm5hbWUpXHJcbiAgICBpZihleGlzdEdyb3VwTm9kZSE9bnVsbCkgcmV0dXJuIGV4aXN0R3JvdXBOb2RlO1xyXG4gICAgdGhpcy5ncm91cE5vZGVzLnB1c2goYU5ld0dyb3VwTm9kZSk7XHJcbiAgICB0aGlzLkRPTS5hcHBlbmQoYU5ld0dyb3VwTm9kZS5oZWFkZXJET00pXHJcbiAgICB0aGlzLkRPTS5hcHBlbmQoYU5ld0dyb3VwTm9kZS5saXN0RE9NKVxyXG4gICAgcmV0dXJuIGFOZXdHcm91cE5vZGU7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNlbGVjdExlYWZOb2RlPWZ1bmN0aW9uKGxlYWZOb2RlLG1vdXNlQ2xpY2tEZXRhaWwpe1xyXG4gICAgdGhpcy5zZWxlY3RMZWFmTm9kZUFycihbbGVhZk5vZGVdLG1vdXNlQ2xpY2tEZXRhaWwpXHJcbn1cclxuc2ltcGxlVHJlZS5wcm90b3R5cGUuYXBwZW5kTGVhZk5vZGVUb1NlbGVjdGlvbj1mdW5jdGlvbihsZWFmTm9kZSl7XHJcbiAgICB2YXIgbmV3QXJyPVtdLmNvbmNhdCh0aGlzLnNlbGVjdGVkTm9kZXMpXHJcbiAgICBuZXdBcnIucHVzaChsZWFmTm9kZSlcclxuICAgIHRoaXMuc2VsZWN0TGVhZk5vZGVBcnIobmV3QXJyKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5hZGROb2RlQXJyYXlUb1NlbGVjdGlvbj1mdW5jdGlvbihhcnIpe1xyXG4gICAgdmFyIG5ld0FyciA9IHRoaXMuc2VsZWN0ZWROb2Rlc1xyXG4gICAgdmFyIGZpbHRlckFycj1hcnIuZmlsdGVyKChpdGVtKSA9PiBuZXdBcnIuaW5kZXhPZihpdGVtKSA8IDApXHJcbiAgICBuZXdBcnIgPSBuZXdBcnIuY29uY2F0KGZpbHRlckFycilcclxuICAgIHRoaXMuc2VsZWN0TGVhZk5vZGVBcnIobmV3QXJyKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5zZWxlY3RHcm91cE5vZGU9ZnVuY3Rpb24oZ3JvdXBOb2RlKXtcclxuICAgIGlmKHRoaXMuY2FsbGJhY2tfYWZ0ZXJTZWxlY3RHcm91cE5vZGUpIHRoaXMuY2FsbGJhY2tfYWZ0ZXJTZWxlY3RHcm91cE5vZGUoZ3JvdXBOb2RlLmluZm8pXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNlbGVjdExlYWZOb2RlQXJyPWZ1bmN0aW9uKGxlYWZOb2RlQXJyLG1vdXNlQ2xpY2tEZXRhaWwpe1xyXG4gICAgZm9yKHZhciBpPTA7aTx0aGlzLnNlbGVjdGVkTm9kZXMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzW2ldLmRpbSgpXHJcbiAgICB9XHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXMubGVuZ3RoPTA7XHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXM9dGhpcy5zZWxlY3RlZE5vZGVzLmNvbmNhdChsZWFmTm9kZUFycilcclxuICAgIGZvcih2YXIgaT0wO2k8dGhpcy5zZWxlY3RlZE5vZGVzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2Rlc1tpXS5oaWdobGlnaHQoKVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuY2FsbGJhY2tfYWZ0ZXJTZWxlY3ROb2RlcykgdGhpcy5jYWxsYmFja19hZnRlclNlbGVjdE5vZGVzKHRoaXMuc2VsZWN0ZWROb2Rlcyxtb3VzZUNsaWNrRGV0YWlsKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlLnByb3RvdHlwZS5kYmxDbGlja05vZGU9ZnVuY3Rpb24odGhlTm9kZSl7XHJcbiAgICBpZih0aGlzLmNhbGxiYWNrX2FmdGVyRGJsY2xpY2tOb2RlKSB0aGlzLmNhbGxiYWNrX2FmdGVyRGJsY2xpY2tOb2RlKHRoZU5vZGUpXHJcbn1cclxuXHJcbnNpbXBsZVRyZWUucHJvdG90eXBlLnNvcnRBbGxMZWF2ZXM9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuZ3JvdXBOb2Rlcy5mb3JFYWNoKG9uZUdyb3VwTm9kZT0+e29uZUdyb3VwTm9kZS5zb3J0Tm9kZXNCeU5hbWUoKX0pXHJcbn1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXRyZWUgZ3JvdXAgbm9kZS0tLS0tLS0tLS0tLS0tLVxyXG5mdW5jdGlvbiBzaW1wbGVUcmVlR3JvdXBOb2RlKHBhcmVudFRyZWUsb2JqKXtcclxuICAgIHRoaXMucGFyZW50VHJlZT1wYXJlbnRUcmVlXHJcbiAgICB0aGlzLmluZm89b2JqXHJcbiAgICB0aGlzLmNoaWxkTGVhZk5vZGVzPVtdIC8vaXQncyBjaGlsZCBsZWFmIG5vZGVzIGFycmF5XHJcbiAgICB0aGlzLm5hbWU9b2JqLmRpc3BsYXlOYW1lO1xyXG4gICAgdGhpcy5jcmVhdGVET00oKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5yZWZyZXNoTmFtZT1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5oZWFkZXJET00uZW1wdHkoKVxyXG4gICAgdmFyIG5hbWVEaXY9JChcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO3BhZGRpbmctbGVmdDo1cHg7cGFkZGluZy1yaWdodDozcHg7dmVydGljYWwtYWxpZ246bWlkZGxlJz48L2Rpdj5cIilcclxuICAgIG5hbWVEaXYudGV4dCh0aGlzLm5hbWUpXHJcbiAgICBcclxuICAgIGlmKHRoaXMuY2hpbGRMZWFmTm9kZXMubGVuZ3RoPjApIGxibENvbG9yPVwidzMtbGltZVwiXHJcbiAgICBlbHNlIHZhciBsYmxDb2xvcj1cInczLWdyYXlcIiBcclxuICAgIHRoaXMuaGVhZGVyRE9NLmNzcyhcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpXHJcblxyXG4gICAgXHJcbiAgICBpZih0aGlzLnBhcmVudFRyZWUub3B0aW9ucy5ncm91cE5vZGVJY29uRnVuYyl7XHJcbiAgICAgICAgdmFyIGljb25MYWJlbD10aGlzLnBhcmVudFRyZWUub3B0aW9ucy5ncm91cE5vZGVJY29uRnVuYyh0aGlzKVxyXG4gICAgICAgIGlmKGljb25MYWJlbCl7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRE9NLmFwcGVuZChpY29uTGFiZWwpXHJcbiAgICAgICAgICAgIHZhciByb3dIZWlnaHQ9aWNvbkxhYmVsLmhlaWdodCgpXHJcbiAgICAgICAgICAgIG5hbWVEaXYuY3NzKFwibGluZS1oZWlnaHRcIixyb3dIZWlnaHQrXCJweFwiKSAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBudW1iZXJsYWJlbD0kKFwiPGxhYmVsIGNsYXNzPSdcIitsYmxDb2xvcitcIicgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO2ZvbnQtc2l6ZTo5cHg7cGFkZGluZzoycHggNHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtib3JkZXItcmFkaXVzOiAycHg7Jz5cIit0aGlzLmNoaWxkTGVhZk5vZGVzLmxlbmd0aCtcIjwvbGFiZWw+XCIpXHJcbiAgICB0aGlzLmhlYWRlckRPTS5hcHBlbmQobmFtZURpdixudW1iZXJsYWJlbClcclxuXHJcblxyXG4gICAgaWYodGhpcy5wYXJlbnRUcmVlLm9wdGlvbnMuZ3JvdXBOb2RlVGFpbEJ1dHRvbkZ1bmMpe1xyXG4gICAgICAgIHZhciB0YWlsQnV0dG9uPXRoaXMucGFyZW50VHJlZS5vcHRpb25zLmdyb3VwTm9kZVRhaWxCdXR0b25GdW5jKHRoaXMpXHJcbiAgICAgICAgdGhpcy5oZWFkZXJET00uYXBwZW5kKHRhaWxCdXR0b24pXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jaGVja09wdGlvbkhpZGVFbXB0eUdyb3VwKClcclxuXHJcbn1cclxuc2ltcGxlVHJlZUdyb3VwTm9kZS5wcm90b3R5cGUuY2hlY2tPcHRpb25IaWRlRW1wdHlHcm91cD1mdW5jdGlvbigpe1xyXG4gICAgaWYgKHRoaXMucGFyZW50VHJlZS5vcHRpb25zLmhpZGVFbXB0eUdyb3VwICYmIHRoaXMuY2hpbGRMZWFmTm9kZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICB0aGlzLnNocmluaygpXHJcbiAgICAgICAgdGhpcy5oZWFkZXJET00uaGlkZSgpXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdERPTSkgdGhpcy5saXN0RE9NLmhpZGUoKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmhlYWRlckRPTS5zaG93KClcclxuICAgICAgICBpZiAodGhpcy5saXN0RE9NKSB0aGlzLmxpc3RET00uc2hvdygpXHJcbiAgICB9XHJcblxyXG59XHJcbnNpbXBsZVRyZWVHcm91cE5vZGUucHJvdG90eXBlLmRlbGV0ZVNlbGYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmhlYWRlckRPTS5yZW1vdmUoKVxyXG4gICAgdGhpcy5saXN0RE9NLnJlbW92ZSgpXHJcbiAgICB2YXIgcGFyZW50QXJyID0gdGhpcy5wYXJlbnRUcmVlLmdyb3VwTm9kZXNcclxuICAgIGNvbnN0IGluZGV4ID0gcGFyZW50QXJyLmluZGV4T2YodGhpcyk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkgcGFyZW50QXJyLnNwbGljZShpbmRleCwgMSk7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWVHcm91cE5vZGUucHJvdG90eXBlLmNyZWF0ZURPTT1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5oZWFkZXJET009JCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1ibG9jayB3My1saWdodC1ncmV5IHczLWxlZnQtYWxpZ24gdzMtYm9yZGVyLWJvdHRvbVwiIHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmVcIj48L2J1dHRvbj4nKVxyXG4gICAgdGhpcy5yZWZyZXNoTmFtZSgpXHJcbiAgICB0aGlzLmxpc3RET009JCgnPGRpdiBjbGFzcz1cInczLWNvbnRhaW5lciB3My1oaWRlIHczLWJvcmRlclwiIHN0eWxlPVwicGFkZGluZzo4cHhcIj48L2Rpdj4nKVxyXG5cclxuICAgIHRoaXMuaGVhZGVyRE9NLm9uKFwiY2xpY2tcIiwoZXZ0KT0+IHtcclxuICAgICAgICBpZih0aGlzLmxpc3RET00uaGFzQ2xhc3MoXCJ3My1zaG93XCIpKSB0aGlzLmxpc3RET00ucmVtb3ZlQ2xhc3MoXCJ3My1zaG93XCIpXHJcbiAgICAgICAgZWxzZSB0aGlzLmxpc3RET00uYWRkQ2xhc3MoXCJ3My1zaG93XCIpXHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50VHJlZS5zZWxlY3RHcm91cE5vZGUodGhpcykgICAgXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnNpbXBsZVRyZWVHcm91cE5vZGUucHJvdG90eXBlLmlzT3Blbj1mdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuICB0aGlzLmxpc3RET00uaGFzQ2xhc3MoXCJ3My1zaG93XCIpXHJcbn1cclxuXHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5leHBhbmQ9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMubGlzdERPTSkgdGhpcy5saXN0RE9NLmFkZENsYXNzKFwidzMtc2hvd1wiKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5zaHJpbms9ZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMubGlzdERPTSkgdGhpcy5saXN0RE9NLnJlbW92ZUNsYXNzKFwidzMtc2hvd1wiKVxyXG59XHJcblxyXG5zaW1wbGVUcmVlR3JvdXBOb2RlLnByb3RvdHlwZS5zb3J0Tm9kZXNCeU5hbWU9ZnVuY3Rpb24oKXtcclxuICAgIHZhciB0cmVlT3B0aW9ucz10aGlzLnBhcmVudFRyZWUub3B0aW9uc1xyXG4gICAgaWYodHJlZU9wdGlvbnMubGVhZk5hbWVQcm9wZXJ0eSkgdmFyIGxlYWZOYW1lUHJvcGVydHk9dHJlZU9wdGlvbnMubGVhZk5hbWVQcm9wZXJ0eVxyXG4gICAgZWxzZSBsZWFmTmFtZVByb3BlcnR5PVwiJGR0SWRcIlxyXG4gICAgdGhpcy5jaGlsZExlYWZOb2Rlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IFxyXG4gICAgICAgIHZhciBhTmFtZT1hLm5hbWUudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIHZhciBiTmFtZT1iLm5hbWUudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIHJldHVybiBhTmFtZS5sb2NhbGVDb21wYXJlKGJOYW1lKSBcclxuICAgIH0pO1xyXG4gICAgLy90aGlzLmxpc3RET00uZW1wdHkoKSAvL05PVEU6IENhbiBub3QgZGVsZXRlIHRob3NlIGxlYWYgbm9kZSBvdGhlcndpc2UgdGhlIGV2ZW50IGhhbmRsZSBpcyBsb3N0XHJcbiAgICB0aGlzLmNoaWxkTGVhZk5vZGVzLmZvckVhY2gob25lTGVhZj0+e3RoaXMubGlzdERPTS5hcHBlbmQob25lTGVhZi5ET00pfSlcclxufVxyXG5cclxuc2ltcGxlVHJlZUdyb3VwTm9kZS5wcm90b3R5cGUuYWRkTm9kZT1mdW5jdGlvbihvYmosc2tpcFJlcGVhdCl7XHJcbiAgICB2YXIgdHJlZU9wdGlvbnM9dGhpcy5wYXJlbnRUcmVlLm9wdGlvbnNcclxuICAgIGlmKHRyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHkpIHZhciBsZWFmTmFtZVByb3BlcnR5PXRyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHlcclxuICAgIGVsc2UgbGVhZk5hbWVQcm9wZXJ0eT1cIiRkdElkXCJcclxuXHJcbiAgICBpZihza2lwUmVwZWF0KXtcclxuICAgICAgICB2YXIgZm91bmRSZXBlYXQ9ZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jaGlsZExlYWZOb2Rlcy5mb3JFYWNoKGFOb2RlPT57XHJcbiAgICAgICAgICAgIGlmKGFOb2RlLm5hbWU9PW9ialtsZWFmTmFtZVByb3BlcnR5XSkge1xyXG4gICAgICAgICAgICAgICAgZm91bmRSZXBlYXQ9dHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZihmb3VuZFJlcGVhdCkgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhTmV3Tm9kZSA9IG5ldyBzaW1wbGVUcmVlTGVhZk5vZGUodGhpcyxvYmopXHJcbiAgICB0aGlzLmNoaWxkTGVhZk5vZGVzLnB1c2goYU5ld05vZGUpXHJcbiAgICB0aGlzLnJlZnJlc2hOYW1lKClcclxuICAgIHRoaXMubGlzdERPTS5hcHBlbmQoYU5ld05vZGUuRE9NKVxyXG59XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS10cmVlIGxlYWYgbm9kZS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5mdW5jdGlvbiBzaW1wbGVUcmVlTGVhZk5vZGUocGFyZW50R3JvdXBOb2RlLG9iail7XHJcbiAgICB0aGlzLnBhcmVudEdyb3VwTm9kZT1wYXJlbnRHcm91cE5vZGVcclxuICAgIHRoaXMubGVhZkluZm89b2JqO1xyXG5cclxuICAgIHZhciB0cmVlT3B0aW9ucz10aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLm9wdGlvbnNcclxuICAgIGlmKHRyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHkpIHRoaXMubmFtZT10aGlzLmxlYWZJbmZvW3RyZWVPcHRpb25zLmxlYWZOYW1lUHJvcGVydHldXHJcbiAgICBlbHNlIHRoaXMubmFtZT10aGlzLmxlYWZJbmZvW1wiJGR0SWRcIl1cclxuXHJcbiAgICB0aGlzLmNyZWF0ZUxlYWZOb2RlRE9NKClcclxufVxyXG5cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5kZWxldGVTZWxmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5ET00ucmVtb3ZlKClcclxuICAgIHZhciBnTm9kZSA9IHRoaXMucGFyZW50R3JvdXBOb2RlXHJcbiAgICBjb25zdCBpbmRleCA9IGdOb2RlLmNoaWxkTGVhZk5vZGVzLmluZGV4T2YodGhpcyk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkgZ05vZGUuY2hpbGRMZWFmTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIGdOb2RlLnJlZnJlc2hOYW1lKClcclxufVxyXG5cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5jbGlja1NlbGY9ZnVuY3Rpb24obW91c2VDbGlja0RldGFpbCl7XHJcbiAgICB0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmxhc3RDbGlja2VkTm9kZT10aGlzO1xyXG4gICAgdGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5zZWxlY3RMZWFmTm9kZSh0aGlzLG1vdXNlQ2xpY2tEZXRhaWwpXHJcbn1cclxuXHJcbnNpbXBsZVRyZWVMZWFmTm9kZS5wcm90b3R5cGUuY3JlYXRlTGVhZk5vZGVET009ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NPSQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtd2hpdGVcIiBzdHlsZT1cImRpc3BsYXk6YmxvY2s7dGV4dC1hbGlnbjpsZWZ0O3dpZHRoOjk4JVwiPjwvYnV0dG9uPicpXHJcbiAgICB0aGlzLnJlZHJhd0xhYmVsKClcclxuXHJcblxyXG4gICAgdmFyIGNsaWNrRj0oZSk9PntcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHZhciBjbGlja0RldGFpbD1lLmRldGFpbFxyXG4gICAgICAgIGlmIChlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5vcHRpb25zLm5vTXVsdGlwbGVTZWxlY3RBbGxvd2VkKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tTZWxmKClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmFwcGVuZExlYWZOb2RlVG9TZWxlY3Rpb24odGhpcylcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5sYXN0Q2xpY2tlZE5vZGU9dGhpcztcclxuICAgICAgICB9ZWxzZSBpZihlLnNoaWZ0S2V5KXtcclxuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5vcHRpb25zLm5vTXVsdGlwbGVTZWxlY3RBbGxvd2VkKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tTZWxmKClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmxhc3RDbGlja2VkTm9kZT09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrU2VsZigpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdmFyIGFsbExlYWZOb2RlQXJyPXRoaXMucGFyZW50R3JvdXBOb2RlLnBhcmVudFRyZWUuZ2V0QWxsTGVhZk5vZGVBcnIoKVxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4MSA9IGFsbExlYWZOb2RlQXJyLmluZGV4T2YodGhpcy5wYXJlbnRHcm91cE5vZGUucGFyZW50VHJlZS5sYXN0Q2xpY2tlZE5vZGUpXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgyID0gYWxsTGVhZk5vZGVBcnIuaW5kZXhPZih0aGlzKVxyXG4gICAgICAgICAgICAgICAgaWYoaW5kZXgxPT0tMSB8fCBpbmRleDI9PS0xKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrU2VsZigpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAvL3NlbGVjdCBhbGwgbGVhZiBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyST0gTWF0aC5taW4oaW5kZXgxLGluZGV4MilcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGVyST0gTWF0aC5tYXgoaW5kZXgxLGluZGV4MilcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkZGxlQXJyPWFsbExlYWZOb2RlQXJyLnNsaWNlKGxvd2VySSxoaWdoZXJJKSAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZUFyci5wdXNoKGFsbExlYWZOb2RlQXJyW2hpZ2hlckldKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50R3JvdXBOb2RlLnBhcmVudFRyZWUuYWRkTm9kZUFycmF5VG9TZWxlY3Rpb24obWlkZGxlQXJyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpY2tTZWxmKGNsaWNrRGV0YWlsKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuRE9NLm9uKFwiY2xpY2tcIiwoZSk9PntjbGlja0YoZSl9KVxyXG5cclxuICAgIHRoaXMuRE9NLm9uKFwiZGJsY2xpY2tcIiwoZSk9PntcclxuICAgICAgICB0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLmRibENsaWNrTm9kZSh0aGlzKVxyXG4gICAgfSlcclxufVxyXG5cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5yZWRyYXdMYWJlbD1mdW5jdGlvbigpe1xyXG4gICAgdGhpcy5ET00uZW1wdHkoKVxyXG5cclxuICAgIHZhciBuYW1lRGl2PSQoXCI8bGFiZWwgc3R5bGU9J2Rpc3BsYXk6aW5saW5lO3BhZGRpbmctbGVmdDo1cHg7cGFkZGluZy1yaWdodDozcHg7dmVydGljYWwtYWxpZ246bWlkZGxlJz48L2xhYmVsPlwiKVxyXG4gICAgbmFtZURpdi50ZXh0KHRoaXMubmFtZSlcclxuXHJcbiAgICBpZih0aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLm9wdGlvbnMubGVhZk5vZGVJY29uRnVuYyl7XHJcbiAgICAgICAgdmFyIGljb25MYWJlbD10aGlzLnBhcmVudEdyb3VwTm9kZS5wYXJlbnRUcmVlLm9wdGlvbnMubGVhZk5vZGVJY29uRnVuYyh0aGlzKVxyXG4gICAgICAgIHRoaXMuRE9NLmFwcGVuZChpY29uTGFiZWwpXHJcbiAgICAgICAgdmFyIHJvd0hlaWdodD1pY29uTGFiZWwuaGVpZ2h0KClcclxuICAgICAgICBuYW1lRGl2LmNzcyhcImxpbmUtaGVpZ2h0XCIscm93SGVpZ2h0K1wicHhcIilcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5ET00uYXBwZW5kKG5hbWVEaXYpXHJcbn1cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5oaWdobGlnaHQ9ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NLmFkZENsYXNzKFwidzMtb3JhbmdlXCIpXHJcbiAgICB0aGlzLkRPTS5hZGRDbGFzcyhcInczLWhvdmVyLWFtYmVyXCIpXHJcbiAgICB0aGlzLkRPTS5yZW1vdmVDbGFzcyhcInczLXdoaXRlXCIpXHJcbn1cclxuc2ltcGxlVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5kaW09ZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuRE9NLnJlbW92ZUNsYXNzKFwidzMtb3JhbmdlXCIpXHJcbiAgICB0aGlzLkRPTS5yZW1vdmVDbGFzcyhcInczLWhvdmVyLWFtYmVyXCIpXHJcbiAgICB0aGlzLkRPTS5hZGRDbGFzcyhcInczLXdoaXRlXCIpXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsZVRyZWU7IiwiY29uc3QgZ2xvYmFsQ2FjaGUgPSByZXF1aXJlKFwiLi9nbG9iYWxDYWNoZVwiKVxyXG5jb25zdCBzaW1wbGVTZWxlY3RNZW51PXJlcXVpcmUoXCIuL3NpbXBsZVNlbGVjdE1lbnVcIilcclxuY29uc3QgbXNhbEhlbHBlcj1yZXF1aXJlKFwiLi4vbXNhbEhlbHBlclwiKVxyXG5jb25zdCBlZGl0UHJvamVjdERpYWxvZz1yZXF1aXJlKFwiLi9lZGl0UHJvamVjdERpYWxvZ1wiKVxyXG5jb25zdCBtb2RlbE1hbmFnZXJEaWFsb2cgPSByZXF1aXJlKFwiLi9tb2RlbE1hbmFnZXJEaWFsb2dcIilcclxuY29uc3QgbW9kZWxBbmFseXplciA9IHJlcXVpcmUoXCIuL21vZGVsQW5hbHl6ZXJcIilcclxuXHJcbmZ1bmN0aW9uIHN0YXJ0U2VsZWN0aW9uRGlhbG9nKCkge1xyXG4gICAgaWYoIXRoaXMuRE9NKXtcclxuICAgICAgICB0aGlzLkRPTSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2JhY2tncm91bmQtY29sb3I6d2hpdGU7bGVmdDo1MCU7dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7ei1pbmRleDo5OVwiIGNsYXNzPVwidzMtY2FyZC0yXCI+PC9kaXY+JylcclxuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5ET00pXHJcbiAgICAgICAgdGhpcy5ET00uaGlkZSgpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUubWFrZURPTURyYWdnYWJsZSh0aGlzLkRPTSlcclxuICAgIH1cclxufVxyXG5cclxuc3RhcnRTZWxlY3Rpb25EaWFsb2cucHJvdG90eXBlLnBvcHVwID0gYXN5bmMgZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLkRPTS5zaG93KClcclxuICAgIHRoaXMuRE9NLmVtcHR5KClcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRET00gPSAkKCc8ZGl2IHN0eWxlPVwid2lkdGg6NjgwcHhcIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5ET00uYXBwZW5kKHRoaXMuY29udGVudERPTSlcclxuICAgIHZhciB0aXRsZURpdj0kKCc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjQwcHhcIiBjbGFzcz1cInczLWJhciB3My1yZWRcIj48ZGl2IGNsYXNzPVwidzMtYmFyLWl0ZW1cIiBzdHlsZT1cImZvbnQtc2l6ZToxLjVlbVwiPlNlbGVjdCBUd2luczwvZGl2PjwvZGl2PicpXHJcbiAgICB0aGlzLmNvbnRlbnRET00uYXBwZW5kKHRpdGxlRGl2KVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvbiB3My1yaWdodFwiIHN0eWxlPVwiZm9udC1zaXplOjJlbTtwYWRkaW5nLXRvcDo0cHhcIj7DlzwvYnV0dG9uPicpXHJcbiAgICB0aXRsZURpdi5hcHBlbmQoY2xvc2VCdXR0b24pXHJcblxyXG4gICAgdGhpcy5idXR0b25Ib2xkZXIgPSAkKFwiPGRpdiBzdHlsZT0naGVpZ2h0OjEwMCUnPjwvZGl2PlwiKVxyXG4gICAgdGl0bGVEaXYuYXBwZW5kKHRoaXMuYnV0dG9uSG9sZGVyKVxyXG4gICAgY2xvc2VCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51c2VTdGFydFNlbGVjdGlvbihcImFwcGVuZFwiKVxyXG4gICAgICAgIHRoaXMuY2xvc2VEaWFsb2coKSBcclxuICAgIH0pXHJcblxyXG4gICAgdmFyIHJvdzE9JCgnPGRpdiBjbGFzcz1cInczLWJhclwiIHN0eWxlPVwicGFkZGluZzoycHhcIj48L2Rpdj4nKVxyXG4gICAgdGhpcy5jb250ZW50RE9NLmFwcGVuZChyb3cxKVxyXG4gICAgdmFyIGxhYmxlPSQoJzxkaXYgY2xhc3M9XCJ3My1iYXItaXRlbSB3My1vcGFjaXR5XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OjVweDtcIj5Qcm9qZWN0IDwvZGl2PicpXHJcbiAgICByb3cxLmFwcGVuZChsYWJsZSlcclxuICAgIHZhciBzd2l0Y2hQcm9qZWN0U2VsZWN0b3I9bmV3IHNpbXBsZVNlbGVjdE1lbnUoXCIgXCIse3dpdGhCb3JkZXI6MSxjb2xvckNsYXNzOlwidzMtbGlnaHQtZ3JheVwiLGJ1dHRvbkNTUzp7XCJwYWRkaW5nXCI6XCI1cHggMTBweFwifX0pXHJcbiAgICB0aGlzLnN3aXRjaFByb2plY3RTZWxlY3Rvcj1zd2l0Y2hQcm9qZWN0U2VsZWN0b3JcclxuICAgIHJvdzEuYXBwZW5kKHN3aXRjaFByb2plY3RTZWxlY3Rvci5ET00pXHJcbiAgICB2YXIgam9pbmVkUHJvamVjdHM9Z2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uam9pbmVkUHJvamVjdHNcclxuICAgIGpvaW5lZFByb2plY3RzLmZvckVhY2goYVByb2plY3Q9PntcclxuICAgICAgICB2YXIgc3RyID0gYVByb2plY3QubmFtZVxyXG4gICAgICAgIGlmKGFQcm9qZWN0Lm93bmVyIT1nbG9iYWxDYWNoZS5hY2NvdW50SW5mby5hY2NvdW50SUQpIHN0cis9XCIgKGZyb20gXCIrYVByb2plY3Qub3duZXIrXCIpXCJcclxuICAgICAgICBzd2l0Y2hQcm9qZWN0U2VsZWN0b3IuYWRkT3B0aW9uKHN0cixhUHJvamVjdC5pZClcclxuICAgIH0pXHJcbiAgICBzd2l0Y2hQcm9qZWN0U2VsZWN0b3IuY2FsbEJhY2tfY2xpY2tPcHRpb249KG9wdGlvblRleHQsb3B0aW9uVmFsdWUpPT57XHJcbiAgICAgICAgc3dpdGNoUHJvamVjdFNlbGVjdG9yLmNoYW5nZU5hbWUob3B0aW9uVGV4dClcclxuICAgICAgICB0aGlzLmNob29zZVByb2plY3Qob3B0aW9uVmFsdWUpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lZGl0UHJvamVjdEJ0bj0kKCc8YSBjbGFzcz1cInczLWJhci1pdGVtIHczLWJ1dHRvblwiIGhyZWY9XCIjXCI+PGkgY2xhc3M9XCJmYSBmYS1lZGl0IGZhLWxnXCI+PC9pPjwvYT4nKVxyXG4gICAgdGhpcy5kZWxldGVQcm9qZWN0QnRuPSQoJzxhIGNsYXNzPVwidzMtYnV0dG9uXCIgaHJlZj1cIiNcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoIGZhLWxnXCI+PC9pPjwvYT4nKVxyXG4gICAgdGhpcy5uZXdQcm9qZWN0QnRuPSQoJzxhIGNsYXNzPVwidzMtYnV0dG9uXCIgaHJlZj1cIiNcIj48aSBjbGFzcz1cImZhIGZhLXBsdXMgZmEtbGdcIj48L2k+PC9hPicpXHJcbiAgICByb3cxLmFwcGVuZCh0aGlzLmVkaXRQcm9qZWN0QnRuLHRoaXMuZGVsZXRlUHJvamVjdEJ0bix0aGlzLm5ld1Byb2plY3RCdG4pXHJcblxyXG4gICAgdmFyIHBhbmVsSGVpZ2h0PTQwMFxyXG4gICAgdmFyIHJvdzI9JCgnPGRpdiBjbGFzcz1cInczLWNlbGwtcm93XCI+PC9kaXY+JylcclxuICAgIHRoaXMuY29udGVudERPTS5hcHBlbmQocm93MilcclxuICAgIHZhciBsZWZ0U3Bhbj0kKCc8ZGl2IHN0eWxlPVwicGFkZGluZzo1cHg7d2lkdGg6MjYwcHg7cGFkZGluZy1yaWdodDo1cHg7b3ZlcmZsb3c6aGlkZGVuXCI+PC9kaXY+JylcclxuICAgIHJvdzIuYXBwZW5kKGxlZnRTcGFuKVxyXG4gICAgdGhpcy5sZWZ0U3Bhbj1sZWZ0U3BhblxyXG5cclxuICAgIHZhciByaWdodFNwYW49JCgnPGRpdiBjbGFzcz1cInczLWNvbnRhaW5lciB3My1jZWxsXCIgc3R5bGU9XCJwYWRkaW5nLXRvcDoxMHB4O1wiPjwvZGl2PicpXHJcbiAgICByb3cyLmFwcGVuZChyaWdodFNwYW4pIFxyXG4gICAgcmlnaHRTcGFuLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwidzMtY29udGFpbmVyIHczLWNhcmRcIiBzdHlsZT1cImNvbG9yOmdyYXk7aGVpZ2h0OicrKHBhbmVsSGVpZ2h0LTEwKSsncHg7b3ZlcmZsb3c6YXV0bzt3aWR0aDozOTBweDtcIj48L2Rpdj4nKSlcclxuICAgIHZhciBzZWxlY3RlZFR3aW5zRE9NPSQoXCI8dGFibGUgc3R5bGU9J3dpZHRoOjEwMCUnPjwvdGFibGU+XCIpXHJcbiAgICBzZWxlY3RlZFR3aW5zRE9NLmNzcyh7XCJib3JkZXItY29sbGFwc2VcIjpcImNvbGxhcHNlXCJ9KVxyXG4gICAgcmlnaHRTcGFuLmNoaWxkcmVuKCc6Zmlyc3QnKS5hcHBlbmQoc2VsZWN0ZWRUd2luc0RPTSlcclxuICAgIHRoaXMuc2VsZWN0ZWRUd2luc0RPTT1zZWxlY3RlZFR3aW5zRE9NIFxyXG5cclxuICAgIHZhciByb3cxPSQoXCI8ZGl2IHN0eWxlPSdtYXJnaW46OHB4IDBweDtmb250LXdlaWdodDpib2xkO2NvbG9yOmdyYXk7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtoZWlnaHQ6MjRweCc+PC9kaXY+XCIpXHJcbiAgICB0aGlzLmxlZnRTcGFuLmFwcGVuZChyb3cxKVxyXG4gICAgcm93MS5hcHBlbmQoJCgnPGxhYmVsIHN0eWxlPVwicGFkZGluZy1yaWdodDo1cHhcIj5DaG9vc2UgdHdpbnM8L2xhYmVsPicpKVxyXG5cclxuICAgIHZhciByYWRpb0J5TW9kZWw9JCgnPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJTZWxlY3RUd2luc1wiIHZhbHVlPVwibW9kZWxcIiBjaGVja2VkPjxsYWJlbCBzdHlsZT1cImZvbnQtd2VpZ2h0Om5vcm1hbDtwYWRkaW5nLXJpZ2h0OjhweFwiPkJ5IE1vZGVsPC9sYWJlbD4nKVxyXG4gICAgdmFyIHJhZGlvQlRhZz0kKCc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cIlNlbGVjdFR3aW5zXCIgdmFsdWU9XCJ0YWdcIj48bGFiZWwgIHN0eWxlPVwiZm9udC13ZWlnaHQ6bm9ybWFsXCI+QnkgVGFnPC9sYWJlbD4nKVxyXG4gICAgcm93MS5hcHBlbmQocmFkaW9CeU1vZGVsLHJhZGlvQlRhZylcclxuICAgIHJhZGlvQlRhZy5vbihcImNoYW5nZVwiLChlKT0+e3RoaXMuY2hvb3NlVHdpbkJ5PVwidGFnXCI7IHRoaXMuZmlsbEF2YWlsYWJsZVRhZ3MoKSB9KVxyXG4gICAgcmFkaW9CeU1vZGVsLm9uKFwiY2hhbmdlXCIsKGUpPT57dGhpcy5jaG9vc2VUd2luQnk9XCJtb2RlbFwiOyB0aGlzLmZpbGxBdmFpbGFibGVNb2RlbHMoKSB9KVxyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsc0NoZWNrQm94ZXM9JCgnPGZvcm0gY2xhc3M9XCJ3My1jb250YWluZXIgdzMtYm9yZGVyXCIgc3R5bGU9XCJoZWlnaHQ6JysocGFuZWxIZWlnaHQtNDApKydweDtvdmVyZmxvdzphdXRvXCI+PC9mb3JtPicpXHJcbiAgICBsZWZ0U3Bhbi5hcHBlbmQodGhpcy5tb2RlbHNDaGVja0JveGVzKVxyXG4gICAgXHJcbiAgICBpZih0aGlzLnByZXZpb3VzU2VsZWN0ZWRQcm9qZWN0IT1udWxsKXtcclxuICAgICAgICBzd2l0Y2hQcm9qZWN0U2VsZWN0b3IudHJpZ2dlck9wdGlvblZhbHVlKHRoaXMucHJldmlvdXNTZWxlY3RlZFByb2plY3QpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBzd2l0Y2hQcm9qZWN0U2VsZWN0b3IudHJpZ2dlck9wdGlvbkluZGV4KDApXHJcbiAgICB9XHJcblxyXG4gICAgcmFkaW9CeU1vZGVsLnRyaWdnZXIoXCJjaGFuZ2VcIikgXHJcbn1cclxuXHJcbnN0YXJ0U2VsZWN0aW9uRGlhbG9nLnByb3RvdHlwZS5jaG9vc2VQcm9qZWN0ID0gYXN5bmMgZnVuY3Rpb24gKHNlbGVjdGVkUHJvamVjdElEKSB7XHJcbiAgICB0aGlzLmJ1dHRvbkhvbGRlci5lbXB0eSgpXHJcblxyXG4gICAgdmFyIHByb2plY3RJbmZvPWdsb2JhbENhY2hlLmZpbmRQcm9qZWN0SW5mbyhzZWxlY3RlZFByb2plY3RJRClcclxuICAgIGlmKHByb2plY3RJbmZvLm93bmVyPT1nbG9iYWxDYWNoZS5hY2NvdW50SW5mby5hY2NvdW50SUQpe1xyXG4gICAgICAgIHRoaXMuZWRpdFByb2plY3RCdG4uc2hvdygpXHJcbiAgICAgICAgdGhpcy5kZWxldGVQcm9qZWN0QnRuLnNob3coKVxyXG4gICAgICAgIHRoaXMuZWRpdFByb2plY3RCdG4ub24oXCJjbGlja1wiLCAoKSA9PiB7IGVkaXRQcm9qZWN0RGlhbG9nLnBvcHVwKHByb2plY3RJbmZvKSB9KVxyXG4gICAgICAgIHRoaXMuZGVsZXRlUHJvamVjdEJ0bi5vbihcImNsaWNrXCIsYXN5bmMgKCk9PntcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImFjY291bnRNYW5hZ2VtZW50L2RlbGV0ZVByb2plY3RUb1wiLCBcIlBPU1RcIiwge1wicHJvamVjdElEXCI6c2VsZWN0ZWRQcm9qZWN0SUR9KVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VUZXh0KSBhbGVydChlLnJlc3BvbnNlVGV4dClcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuZWRpdFByb2plY3RCdG4uaGlkZSgpXHJcbiAgICAgICAgdGhpcy5kZWxldGVQcm9qZWN0QnRuLmhpZGUoKVxyXG4gICAgfVxyXG4gICAgdGhpcy5uZXdQcm9qZWN0QnRuLm9uKFwiY2xpY2tcIixhc3luYyAoKT0+e1xyXG4gICAgICAgIHZhciB0c1N0cj0obmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpKSBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UHJvamVjdEluZm8gPSBhd2FpdCBtc2FsSGVscGVyLmNhbGxBUEkoXCJhY2NvdW50TWFuYWdlbWVudC9uZXdQcm9qZWN0VG9cIiwgXCJQT1NUXCIsIHsgXCJwcm9qZWN0TmFtZVwiOiBcIk5ldyBQcm9qZWN0IFwiICsgdHNTdHIgfSlcclxuICAgICAgICAgICAgZ2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uam9pbmVkUHJvamVjdHMudW5zaGlmdChuZXdQcm9qZWN0SW5mbylcclxuICAgICAgICAgICAgdGhpcy5zd2l0Y2hQcm9qZWN0U2VsZWN0b3IuY2xlYXJPcHRpb25zKClcclxuICAgICAgICAgICAgdmFyIGpvaW5lZFByb2plY3RzID0gZ2xvYmFsQ2FjaGUuYWNjb3VudEluZm8uam9pbmVkUHJvamVjdHNcclxuICAgICAgICAgICAgam9pbmVkUHJvamVjdHMuZm9yRWFjaChhUHJvamVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gYVByb2plY3QubmFtZVxyXG4gICAgICAgICAgICAgICAgaWYoYVByb2plY3Qub3duZXIhPWdsb2JhbENhY2hlLmFjY291bnRJbmZvLmFjY291bnRJRCkgc3RyKz1cIiAoZnJvbSBcIithUHJvamVjdC5vd25lcitcIilcIlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hQcm9qZWN0U2VsZWN0b3IuYWRkT3B0aW9uKHN0ciwgYVByb2plY3QuaWQpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vTk9URTogbXVzdCBxdWVyeSB0aGUgbmV3IGpvaW5lZCBwcm9qZWN0cyBKV1QgdG9rZW4gYWdhaW5cclxuICAgICAgICAgICAgYXdhaXQgbXNhbEhlbHBlci5yZWxvYWRVc2VyQWNjb3VudERhdGEoKVxyXG4gICAgICAgICAgICB0aGlzLnN3aXRjaFByb2plY3RTZWxlY3Rvci50cmlnZ2VyT3B0aW9uSW5kZXgoMClcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICBcclxuXHJcbiAgICBpZih0aGlzLnByZXZpb3VzU2VsZWN0ZWRQcm9qZWN0PT1udWxsKXtcclxuICAgICAgICB2YXIgcmVwbGFjZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtY2FyZCB3My1ob3Zlci1kZWVwLW9yYW5nZSB3My1ncmVlblwiIHN0eWxlPVwiaGVpZ2h0OjEwMCU7IG1hcmdpbi1yaWdodDo4cHhcIj5TdGFydDwvYnV0dG9uPicpXHJcbiAgICAgICAgcmVwbGFjZUJ1dHRvbi5vbihcImNsaWNrXCIsICgpID0+IHsgdGhpcy51c2VTdGFydFNlbGVjdGlvbihcInJlcGxhY2VcIikgfSlcclxuICAgICAgICB0aGlzLmJ1dHRvbkhvbGRlci5hcHBlbmQocmVwbGFjZUJ1dHRvbilcclxuICAgIH1lbHNlIGlmKHRoaXMucHJldmlvdXNTZWxlY3RlZFByb2plY3QgPT0gc2VsZWN0ZWRQcm9qZWN0SUQpe1xyXG4gICAgICAgIHZhciByZXBsYWNlQnV0dG9uID0gJCgnPGJ1dHRvbiBjbGFzcz1cInczLWJ1dHRvbiB3My1jYXJkIHczLWRlZXAtb3JhbmdlIHczLWhvdmVyLWdyZWVuXCIgc3R5bGU9XCJoZWlnaHQ6MTAwJTsgbWFyZ2luLXJpZ2h0OjhweFwiPlJlcGxhY2UgQWxsIERhdGE8L2J1dHRvbj4nKVxyXG4gICAgICAgIHZhciBhcHBlbmRCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwidzMtYnV0dG9uIHczLWNhcmQgdzMtZGVlcC1vcmFuZ2UgdzMtaG92ZXItZ3JlZW5cIiBzdHlsZT1cImhlaWdodDoxMDAlXCI+QXBwZW5kIERhdGE8L2J1dHRvbj4nKVxyXG4gICAgXHJcbiAgICAgICAgcmVwbGFjZUJ1dHRvbi5vbihcImNsaWNrXCIsICgpID0+IHsgdGhpcy51c2VTdGFydFNlbGVjdGlvbihcInJlcGxhY2VcIikgfSlcclxuICAgICAgICBhcHBlbmRCdXR0b24ub24oXCJjbGlja1wiLCAoKSA9PiB7IHRoaXMudXNlU3RhcnRTZWxlY3Rpb24oXCJhcHBlbmRcIikgfSlcclxuICAgICAgICB0aGlzLmJ1dHRvbkhvbGRlci5hcHBlbmQoYXBwZW5kQnV0dG9uLHJlcGxhY2VCdXR0b24pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgcmVwbGFjZUJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJ3My1idXR0b24gdzMtY2FyZCB3My1kZWVwLW9yYW5nZSB3My1ob3Zlci1ncmVlblwiIHN0eWxlPVwiaGVpZ2h0OjEwMCU7IG1hcmdpbi1yaWdodDo4cHhcIj5SZXBsYWNlIEFsbCBEYXRhPC9idXR0b24+JylcclxuICAgICAgICByZXBsYWNlQnV0dG9uLm9uKFwiY2xpY2tcIiwgKCkgPT4geyB0aGlzLnVzZVN0YXJ0U2VsZWN0aW9uKFwicmVwbGFjZVwiKSB9KVxyXG4gICAgICAgIHRoaXMuYnV0dG9uSG9sZGVyLmFwcGVuZChyZXBsYWNlQnV0dG9uKVxyXG4gICAgfVxyXG4gICAgZ2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRCA9IHNlbGVjdGVkUHJvamVjdElEXHJcblxyXG4gICAgdmFyIHByb2plY3RPd25lcj1wcm9qZWN0SW5mby5vd25lclxyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgcmVzID0gYXdhaXQgbXNhbEhlbHBlci5jYWxsQVBJKFwiZGlnaXRhbHR3aW4vZmV0Y2hQcm9qZWN0TW9kZWxzRGF0YVwiLCBcIlBPU1RcIiwgbnVsbCwgXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVQcm9qZWN0TW9kZWxzRGF0YShyZXMuREJNb2RlbHMsIHJlcy5hZHRNb2RlbHMpXHJcbiAgICAgICAgbW9kZWxBbmFseXplci5jbGVhckFsbE1vZGVscygpO1xyXG4gICAgICAgIG1vZGVsQW5hbHl6ZXIuYWRkTW9kZWxzKHJlcy5hZHRNb2RlbHMpXHJcbiAgICAgICAgbW9kZWxBbmFseXplci5hbmFseXplKCk7XHJcbiAgICAgICAgdmFyIHJlcyA9IGF3YWl0IG1zYWxIZWxwZXIuY2FsbEFQSShcImRpZ2l0YWx0d2luL2ZldGNoUHJvamVjdFR3aW5zQW5kVmlzdWFsRGF0YVwiLCBcIlBPU1RcIiwge1wicHJvamVjdE93bmVyXCI6cHJvamVjdE93bmVyfSwgXCJ3aXRoUHJvamVjdElEXCIpXHJcbiAgICAgICAgZ2xvYmFsQ2FjaGUuc3RvcmVQcm9qZWN0VHdpbnNBbmRWaXN1YWxEYXRhKHJlcylcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIGlmIChlLnJlc3BvbnNlVGV4dCkgYWxlcnQoZS5yZXNwb25zZVRleHQpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBpZih0aGlzLmNob29zZVR3aW5CeT09XCJ0YWdcIikgdGhpcy5maWxsQXZhaWxhYmxlVGFncygpXHJcbiAgICBlbHNlIHRoaXMuZmlsbEF2YWlsYWJsZU1vZGVscygpXHJcbiAgICB0aGlzLmxpc3RUd2lucygpXHJcbn1cclxuXHJcblxyXG5cclxuc3RhcnRTZWxlY3Rpb25EaWFsb2cucHJvdG90eXBlLmNsb3NlRGlhbG9nPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLkRPTS5oaWRlKClcclxuICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IFwibWVzc2FnZVwiOiBcInN0YXJ0U2VsZWN0aW9uRGlhbG9nX2Nsb3NlZFwifSlcclxufVxyXG5cclxuc3RhcnRTZWxlY3Rpb25EaWFsb2cucHJvdG90eXBlLmdldFRhZ3NUd2lucyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdGFnc1R3aW5zPXtcIkFMTFwiOltdLFwiTm9uIFRhZ2dlZFwiOltdfVxyXG4gICAgZm9yKHZhciB0d2luSUQgaW4gZ2xvYmFsQ2FjaGUuREJUd2lucyl7XHJcbiAgICAgICAgdmFyIGFEQlR3aW49Z2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICAgICAgdGFnc1R3aW5zW1wiQUxMXCJdLnB1c2goYURCVHdpbilcclxuICAgICAgICB2YXIgdGFnPWFEQlR3aW4uZ3JvdXBUYWdcclxuICAgICAgICBpZih0YWc9PW51bGwpIHRhZ3NUd2luc1tcIk5vbiBUYWdnZWRcIl0ucHVzaChhREJUd2luKVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGlmKHRhZ3NUd2luc1t0YWddPT1udWxsKXRhZ3NUd2luc1t0YWddPVtdXHJcbiAgICAgICAgICAgIHRhZ3NUd2luc1t0YWddLnB1c2goYURCVHdpbilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFnc1R3aW5zXHJcbn1cclxuXHJcbnN0YXJ0U2VsZWN0aW9uRGlhbG9nLnByb3RvdHlwZS5maWxsQXZhaWxhYmxlVGFncyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdGFnc1R3aW5zPXRoaXMuZ2V0VGFnc1R3aW5zKClcclxuICAgIHRoaXMubW9kZWxzQ2hlY2tCb3hlcy5lbXB0eSgpIFxyXG4gICAgZm9yKHZhciB0YWdOYW1lIGluIHRhZ3NUd2lucyl7XHJcbiAgICAgICAgdmFyIGFycj10YWdzVHdpbnNbdGFnTmFtZV1cclxuICAgICAgICB2YXIgcm93RGl2PSQoXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO21hcmdpbi10b3A6OHB4O2hlaWdodDoyNHB4Jz48L2Rpdj5cIilcclxuICAgICAgICB0aGlzLm1vZGVsc0NoZWNrQm94ZXMuYXBwZW5kKHJvd0RpdilcclxuICAgICAgICByb3dEaXYuYXBwZW5kKGA8aW5wdXQgY2xhc3M9XCJ3My1jaGVja1wiIHN0eWxlPVwidG9wOjBweDtmbG9hdDpsZWZ0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCIke3RhZ05hbWV9XCIvPmApXHJcbiAgICAgICAgcm93RGl2LmFwcGVuZChgPGxhYmVsIHN0eWxlPVwicGFkZGluZy1sZWZ0OjVweFwiPiR7dGFnTmFtZX08L2xhYmVsPjxwLz5gKVxyXG4gICAgICAgIHZhciBudW1iZXJsYWJlbD0kKFwiPGxhYmVsIGNsYXNzPSd3My1saW1lJyBzdHlsZT0nZGlzcGxheTppbmxpbmU7Zm9udC1zaXplOjlweDtwYWRkaW5nOjJweDttYXJnaW4tbGVmdDo1cHg7Zm9udC13ZWlnaHQ6bm9ybWFsO2JvcmRlci1yYWRpdXM6IDJweDsnPlwiK2Fyci5sZW5ndGgrXCI8L2xhYmVsPlwiKVxyXG4gICAgICAgIHJvd0Rpdi5hcHBlbmQobnVtYmVybGFiZWwpXHJcbiAgICB9XHJcbiAgICB0aGlzLm1vZGVsc0NoZWNrQm94ZXMub2ZmKFwiY2hhbmdlXCIpLy9jbGVhciBhbnkgcHJldmlzb3Ugb24gY2hhbmdlIGZ1bmNcclxuICAgIHRoaXMubW9kZWxzQ2hlY2tCb3hlcy5vbihcImNoYW5nZVwiLChldnQpPT57XHJcbiAgICAgICAgdGhpcy5saXN0VHdpbnMoKVxyXG4gICAgfSlcclxufVxyXG5cclxuc3RhcnRTZWxlY3Rpb25EaWFsb2cucHJvdG90eXBlLmZpbGxBdmFpbGFibGVNb2RlbHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubW9kZWxzQ2hlY2tCb3hlcy5lbXB0eSgpXHJcbiAgICB0aGlzLm1vZGVsc0NoZWNrQm94ZXMuYXBwZW5kKCc8ZGl2IHN0eWxlPVwiZGlzcGxheTpibG9ja1wiPjxpbnB1dCBjbGFzcz1cInczLWNoZWNrXCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJBTExcIj48bGFiZWwgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6NXB4XCI+PGI+QUxMPC9iPjwvbGFiZWw+PHAvPjwvZGl2PicpXHJcbiAgICBnbG9iYWxDYWNoZS5EQk1vZGVsc0Fyci5mb3JFYWNoKG9uZU1vZGVsPT57XHJcbiAgICAgICAgdmFyIG1vZGVsTmFtZT1vbmVNb2RlbFtcImRpc3BsYXlOYW1lXCJdXHJcbiAgICAgICAgdmFyIG1vZGVsSUQ9b25lTW9kZWxbXCJpZFwiXVxyXG4gICAgICAgIHZhciBzeW1ib2w9Z2xvYmFsQ2FjaGUuZ2VuZXJhdGVNb2RlbEljb24obW9kZWxJRCw0MCxcImZpeFNpemVcIilcclxuICAgICAgICB2YXIgcm93RGl2PSQoXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO21hcmdpbi10b3A6OHB4O2hlaWdodDo0MHB4Jz48L2Rpdj5cIilcclxuICAgICAgICB0aGlzLm1vZGVsc0NoZWNrQm94ZXMuYXBwZW5kKHJvd0RpdilcclxuICAgICAgICByb3dEaXYuYXBwZW5kKGA8ZGl2IHN0eWxlPVwid2lkdGg6MjRweFwiPjxpbnB1dCBjbGFzcz1cInczLWNoZWNrXCIgc3R5bGU9XCJ0b3A6MHB4O2Zsb2F0OmxlZnRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cIiR7bW9kZWxJRH1cIi8+PC9kaXY+YClcclxuICAgICAgICB2YXIgaW5uZXJEaXY9JChcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7bWFyZ2luLWxlZnQ6NnB4Jz48L2Rpdj5cIilcclxuICAgICAgICByb3dEaXYuYXBwZW5kKGlubmVyRGl2KVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlubmVyRGl2LmFwcGVuZChzeW1ib2wpXHJcbiAgICAgICAgaW5uZXJEaXYuYXBwZW5kKGA8bGFiZWwgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6NXB4XCI+JHttb2RlbE5hbWV9PC9sYWJlbD48cC8+YClcclxuICAgIH0pXHJcbiAgICB0aGlzLm1vZGVsc0NoZWNrQm94ZXMub2ZmKFwiY2hhbmdlXCIpIC8vY2xlYXIgYW55IHByZXZpc291IG9uIGNoYW5nZSBmdW5jXHJcbiAgICB0aGlzLm1vZGVsc0NoZWNrQm94ZXMub24oXCJjaGFuZ2VcIiwoZXZ0KT0+e1xyXG4gICAgICAgIGlmKCQoZXZ0LnRhcmdldCkuYXR0cihcImlkXCIpPT1cIkFMTFwiKXsgXHJcbiAgICAgICAgICAgIC8vc2VsZWN0IGFsbCB0aGUgb3RoZXIgaW5wdXRcclxuICAgICAgICAgICAgdmFyIHZhbD0kKGV2dC50YXJnZXQpLnByb3AoXCJjaGVja2VkXCIpXHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxzQ2hlY2tCb3hlcy5maW5kKCdpbnB1dCcpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wcm9wKFwiY2hlY2tlZFwiLHZhbClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdFR3aW5zKClcclxuICAgIH0pXHJcbn1cclxuXHJcbnN0YXJ0U2VsZWN0aW9uRGlhbG9nLnByb3RvdHlwZS5nZXRTZWxlY3RlZFR3aW5zPWZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcmVBcnI9W11cclxuICAgIHZhciB0YWdzVHdpbnM9dGhpcy5nZXRUYWdzVHdpbnMoKVxyXG4gICAgaWYodGhpcy5jaG9vc2VUd2luQnk9PVwidGFnXCIpe1xyXG4gICAgICAgIHZhciBjaGVja2VkQXJyPVtdXHJcbiAgICAgICAgdGhpcy5tb2RlbHNDaGVja0JveGVzLmZpbmQoJ2lucHV0JykuZWFjaCggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZighJCh0aGlzKS5wcm9wKFwiY2hlY2tlZFwiKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjaGVja2VkQXJyPWNoZWNrZWRBcnIuY29uY2F0KHRhZ3NUd2luc1skKHRoaXMpLmF0dHIoXCJpZFwiKV0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHVzZWRJRD17fVxyXG4gICAgICAgIGNoZWNrZWRBcnIuZm9yRWFjaChvbmVUd2luPT57XHJcbiAgICAgICAgICAgIGlmKHVzZWRJRFtvbmVUd2luW1wiaWRcIl1dKSByZXR1cm47XHJcbiAgICAgICAgICAgIHVzZWRJRFtvbmVUd2luW1wiaWRcIl1dPTFcclxuICAgICAgICAgICAgcmVBcnIucHVzaChvbmVUd2luKVxyXG4gICAgICAgIH0pXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgY2hvc2VuTW9kZWxzPXt9XHJcbiAgICAgICAgdGhpcy5tb2RlbHNDaGVja0JveGVzLmZpbmQoJ2lucHV0JykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCEkKHRoaXMpLnByb3AoXCJjaGVja2VkXCIpKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmKCQodGhpcykuYXR0cihcImlkXCIpPT1cIkFMTFwiKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNob3Nlbk1vZGVsc1skKHRoaXMpLmF0dHIoXCJpZFwiKV09MVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvcih2YXIgdHdpbklEIGluIGdsb2JhbENhY2hlLkRCVHdpbnMpe1xyXG4gICAgICAgICAgICB2YXIgYVR3aW49Z2xvYmFsQ2FjaGUuREJUd2luc1t0d2luSURdXHJcbiAgICAgICAgICAgIGlmKGNob3Nlbk1vZGVsc1thVHdpbltcIm1vZGVsSURcIl1dKSAgcmVBcnIucHVzaChhVHdpbilcclxuICAgICAgICB9ICAgIFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlQXJyO1xyXG59XHJcblxyXG5zdGFydFNlbGVjdGlvbkRpYWxvZy5wcm90b3R5cGUubGlzdFR3aW5zPWZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnNlbGVjdGVkVHdpbnNET00uZW1wdHkoKVxyXG4gICAgdmFyIHRyPSQoJzx0cj48dGQgc3R5bGU9XCJib3JkZXItcmlnaHQ6c29saWQgMXB4IGxpZ2h0Z3JleTtib3JkZXItYm90dG9tOnNvbGlkIDFweCBsaWdodGdyZXk7Zm9udC13ZWlnaHQ6Ym9sZFwiPlRXSU4gSUQ8L3RkPjx0ZCBzdHlsZT1cImJvcmRlci1ib3R0b206c29saWQgMXB4IGxpZ2h0Z3JleTtmb250LXdlaWdodDpib2xkXCI+TU9ERUwgSUQ8L3RkPjwvdHI+JylcclxuICAgIHRoaXMuc2VsZWN0ZWRUd2luc0RPTS5hcHBlbmQodHIpXHJcblxyXG4gICAgdmFyIHNlbGVjdGVkVHdpbnM9dGhpcy5nZXRTZWxlY3RlZFR3aW5zKClcclxuICAgIHNlbGVjdGVkVHdpbnMuZm9yRWFjaChhVHdpbj0+e1xyXG4gICAgICAgIHZhciB0cj0kKCc8dHI+PHRkIHN0eWxlPVwiYm9yZGVyLXJpZ2h0OnNvbGlkIDFweCBsaWdodGdyZXk7Ym9yZGVyLWJvdHRvbTpzb2xpZCAxcHggbGlnaHRncmV5XCI+JythVHdpbltcImRpc3BsYXlOYW1lXCJdKyc8L3RkPjx0ZCBzdHlsZT1cImJvcmRlci1ib3R0b206c29saWQgMXB4IGxpZ2h0Z3JleVwiPicrYVR3aW5bJ21vZGVsSUQnXSsnPC90ZD48L3RyPicpXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFR3aW5zRE9NLmFwcGVuZCh0cilcclxuICAgIH0pXHJcbiAgICBpZihzZWxlY3RlZFR3aW5zLmxlbmd0aD09MCl7XHJcbiAgICAgICAgdmFyIHRyPSQoJzx0cj48dGQgc3R5bGU9XCJjb2xvcjpncmF5XCI+emVybyByZWNvcmQ8L3RkPjx0ZD48L3RkPjwvdHI+JylcclxuICAgICAgICB0aGlzLnNlbGVjdGVkVHdpbnNET00uYXBwZW5kKHRyKSAgICBcclxuICAgIH1cclxufVxyXG5cclxuXHJcbnN0YXJ0U2VsZWN0aW9uRGlhbG9nLnByb3RvdHlwZS51c2VTdGFydFNlbGVjdGlvbj1mdW5jdGlvbihhY3Rpb24pe1xyXG4gICAgdmFyIGJvb2xfYnJvYWRDYXN0UHJvamVjdENoYW5nZWQ9ZmFsc2VcclxuICAgIGlmKHRoaXMucHJldmlvdXNTZWxlY3RlZFByb2plY3QhPWdsb2JhbENhY2hlLmN1cnJlbnRQcm9qZWN0SUQpe1xyXG4gICAgICAgIGdsb2JhbENhY2hlLmluaXRTdG9yZWRJbmZvcm10aW9uKClcclxuICAgICAgICB0aGlzLnByZXZpb3VzU2VsZWN0ZWRQcm9qZWN0PWdsb2JhbENhY2hlLmN1cnJlbnRQcm9qZWN0SURcclxuICAgICAgICBib29sX2Jyb2FkQ2FzdFByb2plY3RDaGFuZ2VkPXRydWVcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2VsZWN0ZWRUd2lucz10aGlzLmdldFNlbGVjdGVkVHdpbnMoKVxyXG4gICAgdmFyIHR3aW5JRHM9W11cclxuICAgIHNlbGVjdGVkVHdpbnMuZm9yRWFjaChhVHdpbj0+e3R3aW5JRHMucHVzaChhVHdpbltcImlkXCJdKX0pXHJcblxyXG4gICAgdmFyIG1vZGVsSURzPVtdXHJcbiAgICBnbG9iYWxDYWNoZS5EQk1vZGVsc0Fyci5mb3JFYWNoKG9uZU1vZGVsPT57bW9kZWxJRHMucHVzaChvbmVNb2RlbFtcImlkXCJdKX0pXHJcblxyXG4gICAgdGhpcy5icm9hZGNhc3RNZXNzYWdlKHsgXCJtZXNzYWdlXCI6IFwic3RhcnRTZWxlY3Rpb25fXCIrYWN0aW9uLCBcInR3aW5JRHNcIjogdHdpbklEcyxcIm1vZGVsSURzXCI6bW9kZWxJRHMgfSlcclxuICAgIHZhciBwcm9qZWN0SW5mbz1nbG9iYWxDYWNoZS5maW5kUHJvamVjdEluZm8oZ2xvYmFsQ2FjaGUuY3VycmVudFByb2plY3RJRClcclxuICAgIGlmKHByb2plY3RJbmZvLmRlZmF1bHRMYXlvdXQgJiYgcHJvamVjdEluZm8uZGVmYXVsdExheW91dCE9XCJcIikgZ2xvYmFsQ2FjaGUuY3VycmVudExheW91dE5hbWU9cHJvamVjdEluZm8uZGVmYXVsdExheW91dFxyXG4gICAgXHJcbiAgICBpZihib29sX2Jyb2FkQ2FzdFByb2plY3RDaGFuZ2VkKXtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJwcm9qZWN0SXNDaGFuZ2VkXCIsXCJwcm9qZWN0SURcIjpnbG9iYWxDYWNoZS5jdXJyZW50UHJvamVjdElEfSlcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJyb2FkY2FzdE1lc3NhZ2UoeyBcIm1lc3NhZ2VcIjogXCJsYXlvdXRzVXBkYXRlZFwiLFwic2VsZWN0TGF5b3V0XCI6cHJvamVjdEluZm8uZGVmYXVsdExheW91dH0pXHJcbiAgICB0aGlzLmNsb3NlRGlhbG9nKClcclxuXHJcbiAgICBpZihnbG9iYWxDYWNoZS5EQk1vZGVsc0Fyci5sZW5ndGg9PTApe1xyXG4gICAgICAgIC8vZGlyZWN0bHkgcG9wdXAgdG8gbW9kZWwgbWFuYWdlbWVudCBkaWFsb2cgYWxsb3cgdXNlciBpbXBvcnQgb3IgY3JlYXRlIG1vZGVsXHJcbiAgICAgICAgbW9kZWxNYW5hZ2VyRGlhbG9nLnBvcHVwKClcclxuICAgICAgICBtb2RlbE1hbmFnZXJEaWFsb2cuRE9NLmhpZGUoKVxyXG4gICAgICAgIG1vZGVsTWFuYWdlckRpYWxvZy5ET00uZmFkZUluKClcclxuICAgICAgICAvL3BvcCB1cCB3ZWxjb21lIHNjcmVlblxyXG4gICAgICAgIHZhciBwb3BXaW49JCgnPGRpdiBjbGFzcz1cInczLWJsdWUgdzMtY2FyZC00IHczLXBhZGRpbmctbGFyZ2VcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtsZWZ0OjUwJTt0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTt6LWluZGV4OjEwNTt3aWR0aDo0MDBweDtjdXJzb3I6ZGVmYXVsdFwiPjwvZGl2PicpXHJcbiAgICAgICAgcG9wV2luLmh0bWwoYFdlbGNvbWUsICR7bXNhbEhlbHBlci51c2VyTmFtZX0hIEZpcnN0bHksIGxldCdzIGltcG9ydCBvciBjcmVhdGUgYSBmZXcgdHdpbiBtb2RlbHMgdG8gc3RhcnQuIDxici8+PGJyLz5DbGljayB0byBjb250aW51ZS4uLmApXHJcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHBvcFdpbilcclxuICAgICAgICBwb3BXaW4ub24oXCJjbGlja1wiLCgpPT57cG9wV2luLnJlbW92ZSgpfSlcclxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIHBvcFdpbi5mYWRlT3V0KFwic2xvd1wiLCgpPT57cG9wV2luLnJlbW92ZSgpfSk7XHJcbiAgICAgICAgfSwzMDAwKVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBzdGFydFNlbGVjdGlvbkRpYWxvZygpOyJdfQ==
